<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no, maximum-scale=1" />
  <meta name="theme-color" content="#071020" id="themeColorMeta">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="msapplication-navbutton-color" content="#000000">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="format-detection" content="telephone=no">
  <title>Tetris — jeu</title>
  <style>
    :root{ --bg:#071021; --card:#0c1720; --accent:#ffd166; --muted:#98a8b9; color-scheme: dark }
    html,body{height:100%;margin:0;overflow:hidden;font-family:Inter, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;background:linear-gradient(180deg,#071020 0%, #071827 70%);color:#e6eef6;transition:background 2s ease-in-out;user-select:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none}
    
    /* Protection contre zoom et sélection sur iOS */
    *{-webkit-user-select:none;-webkit-touch-callout:none;-webkit-tap-highlight-color:transparent;user-select:none}
    input,textarea{-webkit-user-select:auto;user-select:auto}
    
    /* Empêcher le zoom sur double-tap */
    canvas,button,div{touch-action:manipulation}
    
    /* Prévenir le zoom sur iOS */
    @supports (-webkit-touch-callout: none) {
      html{-webkit-text-size-adjust:100%}
      body{-webkit-text-size-adjust:100%;touch-action:manipulation}
      *{-webkit-touch-callout:none;-webkit-user-select:none;user-select:none}
    }
    
    /* Atmosphères par niveau */
    body.atmosphere-0 { background:linear-gradient(180deg,#071020 0%, #071827 70%) !important; }
    body.atmosphere-1 { background:linear-gradient(180deg,#1a0a1a 0%, #2d1b2d 70%) !important; }
    body.atmosphere-2 { background:linear-gradient(180deg,#1a0a2e 0%, #2d1b4e 70%) !important; }
    body.atmosphere-3 { background:linear-gradient(180deg,#2e0a1a 0%, #4e1b2d 70%) !important; }
    body.atmosphere-4 { background:linear-gradient(180deg,#2e1a0a 0%, #4e2d1b 70%) !important; }
    body.atmosphere-5 { background:linear-gradient(180deg,#0a2e1a 0%, #1b4e2d 70%) !important; }
    body.atmosphere-6 { background:linear-gradient(180deg,#1a2e0a 0%, #2d4e1b 70%) !important; }
    body.atmosphere-7 { background:linear-gradient(180deg,#2e2e0a 0%, #4e4e1b 70%) !important; }
    body.atmosphere-8 { background:linear-gradient(180deg,#0a0a2e 0%, #1b1b4e 70%) !important; }
    body.atmosphere-9 { background:linear-gradient(180deg,#2e0a0a 0%, #4e1b1b 70%) !important; }
    
    .gameScreen { transition:background-color 2s ease-in-out; }
    .board-wrap .card canvas { transition:border-color 2s ease-in-out; }
    #mobileBoard { transition:border-color 2s ease-in-out; }
    #board { transition:border-color 2s ease-in-out; }
    .center{display:flex;align-items:center;justify-content:center;height:100vh}

    /* Menu (page complète) */
    #menuScreen{display:flex;align-items:center;justify-content:center;height:100vh;width:100vw;position:relative}
    .menuCard{width:100%;max-width:500px;padding:0;border-radius:0;background:transparent;border:none;box-shadow:none;display:flex;justify-content:center}
    .menuGrid{display:flex;flex-direction:column;align-items:center;justify-content:center;width:100%}
    .menuLeft{width:100%;display:flex;flex-direction:column;align-items:center}
    .menuRight{flex:1}
  .tetrisTitle{display:inline-block;position:relative;padding:10px 0 18px 0;margin:0 0 3vh 0;}
  .tetrisTitle .t{position:absolute;top:50%;left:0;width:16px;height:16px;transform:translate(-50%,-50%);border-radius:5px;display:block;transition:transform .65s cubic-bezier(.4,.8,.3,1),width .55s,height .55s,opacity .4s,border-radius .55s;will-change:transform}
  .tetrisTitle .bI{background:#1FB6FF}.tetrisTitle .bO{background:#FFD166}.tetrisTitle .bS{background:#2BD4A4}.tetrisTitle .bZ{background:#FF6B6B}.tetrisTitle .bT{background:#9B5DE5}
  .tetrisWord{font-weight:900;letter-spacing:3px;font-size:clamp(28px,5vw,40px);text-shadow:0 4px 16px rgba(0,0,0,.5);color:#fff;position:relative;z-index:2;padding:0 4px;border-radius:0;}
  .tetrisTitle .t.bgMorph{z-index:0;border-radius:10px;}
  .tetrisTitle .t.wrapOut{transition:transform .5s ease,opacity .45s ease}
  .tetrisTitle .t.wrapIn{transition:transform .6s ease,opacity .6s ease}
  /* Réduction si petit écran */
  @media (max-width:520px){ .tetrisTitle .t{width:14px;height:14px} }
  /* Centrage & léger décalage pour titres Aide / Paramètres */
  /* Ancienne règle titres secondaires retirée (titres remplacés par badges colorés) */
    p.lead{color:#bcd6df;margin-top:0}
    .menuActions{display:flex;gap:10px;margin-top:0;flex-direction:column;width:100%}
    .menuActions.horiz{flex-direction:row}
    .btn{width:100%;text-align:center}
    button.btn{background:linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.04));padding:10px 14px;border-radius:10px;border:1px solid rgba(255,255,255,0.08);color:#e6eef6;cursor:pointer;font-weight:800;letter-spacing:.4px;box-shadow:0 8px 20px rgba(0,0,0,0.35);font-size:14px}
    button.btn.btn-lg{background:linear-gradient(180deg, rgba(255,255,255,0.12), rgba(255,255,255,0.06));padding:clamp(12px, 2vh, 16px) 20px;border-radius:12px;border:1px solid rgba(255,255,255,0.12);color:#e6eef6;cursor:pointer;font-weight:900;letter-spacing:.5px;box-shadow:0 8px 20px rgba(0,0,0,0.35);font-size:clamp(14px, 2.5vw, 16px)}
    button.btn:hover{transform:translateY(-1px) scale(1.01);filter:brightness(1.06)}
    button.btn:active{transform:translateY(0) scale(0.995)}
    @media (max-width: 520px){ .tetrisTitle{margin-bottom:2vh} .menuActions{gap:8px} }
    @media (max-height: 600px){ 
      .tetrisTitle{margin-bottom:1vh} 
      .tetrisWord{font-size:clamp(18px, 3vw, 22px)} 
      button.btn.btn-lg{padding:10px 18px;font-size:clamp(13px, 2vw, 15px)}
    }

    /* onglets/sections du menu */
    .menuTabs{display:flex;gap:8px;margin:12px 0}
    /* onglets retirés (on utilise pages dédiées avec retour) */
  .menuPage{display:none}
  .menuPage.active{display:flex !important}

    /* Game screen */
    #gameScreen{display:flex;flex-direction:column;align-items:center;gap:clamp(8px,2vh,12px);padding:clamp(8px,2vw,18px);min-height:100vh;box-sizing:border-box}
    .container{width:100%;max-width:980px}
    .board-wrap{display:flex;gap:18px;align-items:flex-start;justify-content:center}
    .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:14px;box-shadow:0 8px 30px rgba(0,0,0,0.5);display:flex;gap:12px}
    canvas#board{background:#04131a;border-radius:10px;display:block}
    .side{width:280px;display:flex;flex-direction:column;gap:12px}
    .panel{background:rgba(255,255,255,0.03);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03)}
/* CSS pour elements supprimés */
    .nextList{display:flex;flex-direction:column;gap:10px;align-items:center}

    /* overlays & gameover */
    .overlayFull{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:90}
    .gameOverWrap{pointer-events:none}
    .gameOverText{font-size:66px;font-weight:900;letter-spacing:3px;color:#ff3b3b;text-shadow:0 2px 0 #7a0b0b, 0 4px 0 #6a0a0a, 0 6px 12px rgba(255,0,0,0.35);transform:translateY(-8px) scale(0.85);opacity:0;animation:goBoom 1.2s cubic-bezier(.2,1,.3,1) forwards, flicker 1.8s linear 1.2s infinite}
    @keyframes goBoom{0%{opacity:0;transform:translateY(-16px) scale(0.6) rotate(-8deg)}35%{opacity:1;transform:translateY(4px) scale(1.08) rotate(3deg)}60%{transform:translateY(-2px) scale(0.96) rotate(-2deg)}85%{transform:translateY(0) scale(1.02) rotate(1deg)}100%{opacity:1;transform:translateY(0) scale(1) rotate(0)}}
    @keyframes flicker{0%,19%,21%,23%,100%{filter:brightness(1)}20%,22%{filter:brightness(1.3)}}

    /* combo badge */
    .comboBadge{position:fixed;right:40px;top:40px;background:linear-gradient(180deg,#ffb86b,#ff8a4c);color:#111;padding:10px 14px;border-radius:12px;font-weight:700;box-shadow:0 8px 20px rgba(255,138,76,0.12);opacity:0;transform:translateY(-10px);transition:all .25s;z-index:5000}
    .comboBadge.show{opacity:1;transform:translateY(0)}

    @media(max-width:820px){ 
      .menuCard{padding:18px} 
      .board-wrap{flex-direction:column;align-items:center} 
      .side{width:100%} 
      #gameScreen{gap:clamp(4px,1vh,8px);padding:clamp(4px,1vw,12px)} 
      .desktop-layout{display:none !important}
      .mobile-layout{display:block !important}
    }
    
    /* Media query spécifique iPhone pour le leaderboard */
    @media screen and (max-width: 480px) and (-webkit-min-device-pixel-ratio: 2) {
      #tab-leaderboard .panel {
        max-height: clamp(35vh, 45vh, 55vh) !important;
      }
      #tab-leaderboard {
        min-height: 60vh !important;
      }
  /* Remonter page aide sur iPhone */
  #tab-help { padding: clamp(8px,2vh,28px) clamp(6px,3vw,32px) clamp(12px,3vh,32px) clamp(6px,3vw,32px) !important; min-height:65vh !important; }
  #tab-help .panel { max-height: clamp(48vh,60vh,68vh) !important; }

      /* Modal quitter moins large sur mobile */
      .quitConfirmContent {
        max-width: 320px !important;
        width: 92vw !important;
        padding-left: clamp(10px,2vw,18px) !important;
        padding-right: clamp(10px,2vw,18px) !important;
      }
    }
    
    /* Media query pour très petits écrans (iPhone SE, etc.) */
    @media screen and (max-height: 700px) and (max-width: 400px) {
      #tab-leaderboard .panel {
        max-height: clamp(30vh, 40vh, 50vh) !important;
      }
      #tab-leaderboard {
        min-height: 55vh !important;
        padding: clamp(10px, 2vh, 30px) clamp(8px, 2vw, 20px) !important;
      }
  /* Petits écrans supplémentaires: aide encore plus haute */
  #tab-help { padding: clamp(6px,1.5vh,20px) clamp(6px,4vw,28px) clamp(10px,2.5vh,26px) clamp(6px,4vw,28px) !important; }
  #tab-help .panel { max-height: clamp(50vh,62vh,70vh) !important; }
    }
    
    /* Custom scrollbar pour la page d'aide */
    .panel::-webkit-scrollbar { width: 8px; }
    .panel::-webkit-scrollbar-track { background: rgba(255,255,255,0.05); border-radius: 4px; }
    .panel::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 4px; }
    .panel::-webkit-scrollbar-thumb:hover { background: rgba(255,255,255,0.3); }
    
    /* Animation de pièces qui tombent en arrière-plan */
    .fallingPieces{position:fixed;top:0;left:0;width:100vw;height:100vh;pointer-events:none;z-index:-1;overflow:hidden}
    .fallingPiece{position:absolute;opacity:0.15;transform:rotate(0deg);animation:fall linear infinite}
    @keyframes fall{0%{transform:translateY(-100px) rotate(0deg);opacity:0.15}10%{opacity:0.15}90%{opacity:0.05}100%{transform:translateY(100vh) rotate(360deg);opacity:0}}
    .tetromino{display:grid;gap:2px}
    .tetromino.I{grid-template-columns:repeat(4,8px);grid-template-rows:8px}
    .tetromino.O{grid-template-columns:repeat(2,8px);grid-template-rows:repeat(2,8px)}
    .tetromino.T,.tetromino.S,.tetromino.Z,.tetromino.J,.tetromino.L{grid-template-columns:repeat(3,8px);grid-template-rows:repeat(2,8px)}
    .block{width:8px;height:8px;border-radius:2px}
    
    /* Modal de confirmation pour quitter */
    .quitConfirmModal{position:fixed;inset:0;background:rgba(0,0,0,0.7);backdrop-filter:blur(8px);display:flex;align-items:center;justify-content:center;z-index:5000;opacity:0;visibility:hidden;transition:all 0.3s ease}
    .quitConfirmModal.show{opacity:1;visibility:visible}
    .quitConfirmContent{background:linear-gradient(180deg,#0a1822,#07141b);border:1px solid rgba(255,255,255,0.1);border-radius:16px;padding:clamp(20px,4vh,32px);max-width:400px;width:90vw;text-align:center;transform:scale(0.9);transition:transform 0.3s ease}
    .quitConfirmModal.show .quitConfirmContent{transform:scale(1)}
    .quitConfirmTitle{font-size:clamp(18px,4vw,24px);font-weight:700;color:#e4f3fa;margin-bottom:clamp(12px,2vh,16px)}
    .quitConfirmStats{background:rgba(255,255,255,0.05);border-radius:8px;padding:clamp(12px,2vh,16px);margin:clamp(12px,2vh,16px) 0;font-size:clamp(13px,3vw,15px);color:#b8d4e3}
    .quitConfirmStats div{margin:4px 0}
    .quitConfirmActions{display:flex;gap:12px;justify-content:center;margin-top:clamp(16px,3vh,24px)}
    .quitConfirmBtn{padding:clamp(10px,2vh,12px) clamp(16px,4vw,20px);border:none;border-radius:8px;font-size:clamp(13px,3vw,15px);font-weight:600;cursor:pointer;transition:all 0.2s ease}
    .quitConfirmBtn.continue{background:linear-gradient(135deg,#064758,#0b6b85);color:#e4f3fa}
    .quitConfirmBtn.continue:hover{background:linear-gradient(135deg,#075a6d,#0e7ea0);transform:translateY(-1px)}
    .quitConfirmBtn.quit{background:rgba(255,59,59,0.2);color:#ff6b6b;border:1px solid rgba(255,59,59,0.3)}
    .quitConfirmBtn.quit:hover{background:rgba(255,59,59,0.3);transform:translateY(-1px)}
  </style>
</head>
<body>
  <!-- Pièces qui tombent en arrière-plan -->
  <div class="fallingPieces" id="fallingPieces"></div>

  <!-- MENU PAGE (séparé) -->
  <div id="menuScreen">
    <div class="menuCard">
      <div class="menuGrid">
        <div class="menuLeft">
          <!-- Page Accueil -->
          <div class="menuPage active" id="tab-home" style="display:flex;flex-direction:column;align-items:center;justify-content:center;height:100vh;gap:2vh;padding:2vh 20px">
            
            <!-- Titre Tetris -->
            <div class="tetrisTitle" aria-label="TETRIS" title="TETRIS">
              <span class="t bI"></span><span class="t bO"></span><span class="t bT"></span><span class="t bS"></span><span class="t bZ"></span>
              <span class="tetrisWord">TETRIS</span>
            </div>
            
            <!-- Statistiques (cartes séparées) -->
            <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(110px,1fr));gap:14px;width:100%;max-width:500px;padding:4px 4px 0 4px">
              <div style="background:linear-gradient(180deg,rgba(31,182,255,0.18),rgba(31,182,255,0.05));border:1px solid rgba(31,182,255,0.35);border-radius:12px;padding:14px 12px;text-align:center;box-shadow:0 4px 18px -4px rgba(31,182,255,0.3)">
                <div style="font-size:22px;font-weight:900;color:#1FB6FF;letter-spacing:.5px" id="hsValue">-</div>
                <div style="font-size:11px;color:#bcd6df;font-weight:600;margin-top:4px;letter-spacing:.5px">SCORE MAX</div>
              </div>
              <div style="background:linear-gradient(180deg,rgba(255,209,102,0.22),rgba(255,209,102,0.05));border:1px solid rgba(255,209,102,0.4);border-radius:12px;padding:14px 12px;text-align:center;box-shadow:0 4px 18px -4px rgba(255,209,102,0.35)">
                <div style="font-size:22px;font-weight:900;color:#FFD166;letter-spacing:.5px" id="hsLevel">-</div>
                <div style="font-size:11px;color:#bcd6df;font-weight:600;margin-top:4px;letter-spacing:.5px">NIVEAU MAX</div>
              </div>
              <div style="background:linear-gradient(180deg,rgba(43,212,164,0.20),rgba(43,212,164,0.05));border:1px solid rgba(43,212,164,0.45);border-radius:12px;padding:14px 12px;text-align:center;box-shadow:0 4px 18px -4px rgba(43,212,164,0.35)">
                <div style="font-size:22px;font-weight:900;color:#2BD4A4;letter-spacing:.5px" id="hsLines">-</div>
                <div style="font-size:11px;color:#bcd6df;font-weight:600;margin-top:4px;letter-spacing:.5px">LIGNES MAX</div>
              </div>
            </div>

            <!-- Boutons du menu -->
            <div class="menuActions" style="align-items:stretch;gap:12px;width:100%;max-width:380px;display:flex;flex-wrap:wrap">
              <div style="display:flex;gap:10px;width:100%">
                <button class="btn btn-lg" id="startGameBtn" style="background:linear-gradient(135deg,rgba(31,182,255,0.15),rgba(31,182,255,0.05));border:1px solid rgba(31,182,255,0.3);color:#1FB6FF;font-weight:900;position:relative;overflow:hidden;padding:14px 20px;flex:1">
                  <span style="position:relative;z-index:1">Solo</span>
                </button>
                <button class="btn btn-lg" id="duoGameBtn" style="background:linear-gradient(135deg,rgba(255,59,59,0.15),rgba(255,59,59,0.05));border:1px solid rgba(255,59,59,0.3);color:#ff6b6b;font-weight:900;position:relative;overflow:hidden;padding:14px 20px;flex:1">
                  <span style="position:relative;z-index:1">Duo</span>
                </button>
              </div>

              <!-- Overlay attente Duo -->
              <div id="duoWaitOverlay" style="display:none;position:fixed;z-index:9999;inset:0;background:rgba(7,16,32,0.98);backdrop-filter:blur(2px);align-items:center;justify-content:center;">
                <div class="menuPage" id="tab-duo-wait" style="display:flex !important;flex-direction:column;align-items:center;justify-content:center;gap:clamp(2vh,4vh,6vh);padding:clamp(20px,4vh,60px) clamp(8px,3vw,40px);height:100vh;text-align:center;width:100vw;max-width:none;box-sizing:border-box">
                <div style="display:flex;flex-direction:column;align-items:center;justify-content:center;gap:clamp(2vh,4vh,6vh);width:100vw;height:100vh;">
                  <div id="duoWaitStatus" style="font-size:clamp(18px,3vw,26px);color:#FFD166;font-weight:800;margin-bottom:18px;">En attente de l'autre joueur<span id='duoWaitDots' style='display:inline-block;width:24px'></span></div>
                  <div id="duoWaitAnimWrap" style="display:flex;justify-content:center;align-items:center;width:100px;height:40px;position:relative;overflow:visible;margin:0 auto;">
                    <div id="duoWaitAnim" style="display:flex;gap:0;justify-content:center;align-items:center;height:38px;position:relative;width:100px;">
                      <!-- Les cubes animés seront gérés par JS -->
                    </div>
                  </div>
                  <div id="duoWaitCount" style="font-size:clamp(15px,2vw,20px);color:#fff;font-weight:700;margin-top:18px">Joueurs connectés : 1/2</div>
                </div>
                <button class="btn" id="duoBackBtn" style="margin-top:24px;max-width:180px">Retour</button>
                </div>
              </div>
              <button class="btn btn-lg" id="helpBtn" style="padding:12px 20px">Aide</button>
              <button class="btn btn-lg" id="leaderboardBtn" style="padding:12px 20px">Leaderboard</button>
              <button class="btn btn-lg" id="settingsBtn" style="padding:12px 20px">Paramètres</button>
            </div>


          </div>

          <!-- Page Aide -->
          <div class="menuPage" id="tab-help" style="display:none;flex-direction:column;align-items:center;justify-content:flex-start;gap:clamp(1vh,2vh,3vh);padding:clamp(20px,4vh,60px) clamp(8px,3vw,40px) clamp(16px,3vh,40px) clamp(8px,3vw,40px);height:auto;min-height:78vh;text-align:center">
            <div style="background:#9B5DE5;padding:clamp(8px,1.5vh,18px) clamp(12px,3vw,24px);border-radius:clamp(8px,2vw,14px);font-size:clamp(16px,3vw,22px);font-weight:900;letter-spacing:.8px;color:#fff;align-self:center;min-width:clamp(180px,40vw,260px);text-align:center">AIDE</div>
            
            <div class="panel" style="background:linear-gradient(180deg,rgba(255,255,255,0.04),rgba(255,255,255,0.02));max-width:clamp(300px,90vw,900px);width:100%;border:1px solid rgba(255,255,255,0.08);max-height:clamp(40vh,60vh,70vh);overflow-y:auto;scrollbar-width:thin;scrollbar-color:rgba(255,255,255,0.3) transparent">

              <!-- Section des pièces Tetris avec visuels -->
              <div style="margin-bottom:20px">
                <div style="font-size:16px;font-weight:800;color:#fff;margin-bottom:12px;text-align:center">Les Tetrominoes</div>
                <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:8px;margin-bottom:16px">
                  <div style="background:rgba(31,182,255,0.15);border:1px solid #1FB6FF;padding:8px;border-radius:8px;text-align:center">
                    <div style="display:grid;grid-template-columns:repeat(4,8px);gap:1px;justify-content:center;margin-bottom:4px">
                      <div style="background:#1FB6FF;height:8px;border-radius:2px"></div>
                      <div style="background:#1FB6FF;height:8px;border-radius:2px"></div>
                      <div style="background:#1FB6FF;height:8px;border-radius:2px"></div>
                      <div style="background:#1FB6FF;height:8px;border-radius:2px"></div>
                    </div>
                    <div style="color:#1FB6FF;font-weight:700;font-size:12px">I - Barre</div>
                  </div>
                  <div style="background:rgba(255,209,102,0.15);border:1px solid #FFD166;padding:8px;border-radius:8px;text-align:center">
                    <div style="display:grid;grid-template-columns:repeat(4,8px);gap:1px;justify-content:center;margin-bottom:4px">
                      <div></div><div style="background:#FFD166;height:8px;border-radius:2px"></div><div style="background:#FFD166;height:8px;border-radius:2px"></div><div></div>
                      <div></div><div style="background:#FFD166;height:8px;border-radius:2px"></div><div style="background:#FFD166;height:8px;border-radius:2px"></div><div></div>
                    </div>
                    <div style="color:#FFD166;font-weight:700;font-size:12px">O - Carré</div>
                  </div>
                  <div style="background:rgba(155,93,229,0.15);border:1px solid #9B5DE5;padding:8px;border-radius:8px;text-align:center">
                    <div style="display:grid;grid-template-columns:repeat(4,8px);gap:1px;justify-content:center;margin-bottom:4px">
                      <div></div><div style="background:#9B5DE5;height:8px;border-radius:2px"></div><div></div><div></div>
                      <div style="background:#9B5DE5;height:8px;border-radius:2px"></div><div style="background:#9B5DE5;height:8px;border-radius:2px"></div><div style="background:#9B5DE5;height:8px;border-radius:2px"></div><div></div>
                    </div>
                    <div style="color:#9B5DE5;font-weight:700;font-size:12px">T - Té</div>
                  </div>
                  <div style="background:rgba(43,212,164,0.15);border:1px solid #2BD4A4;padding:8px;border-radius:8px;text-align:center">
                    <div style="display:grid;grid-template-columns:repeat(4,8px);gap:1px;justify-content:center;margin-bottom:4px">
                      <div></div><div style="background:#2BD4A4;height:8px;border-radius:2px"></div><div style="background:#2BD4A4;height:8px;border-radius:2px"></div><div></div>
                      <div style="background:#2BD4A4;height:8px;border-radius:2px"></div><div style="background:#2BD4A4;height:8px;border-radius:2px"></div><div></div><div></div>
                    </div>
                    <div style="color:#2BD4A4;font-weight:700;font-size:12px">S - Snake</div>
                  </div>
                </div>
                <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px">
                  <div style="background:rgba(255,107,107,0.15);border:1px solid #FF6B6B;padding:8px;border-radius:8px;text-align:center">
                    <div style="display:grid;grid-template-columns:repeat(4,8px);gap:1px;justify-content:center;margin-bottom:4px">
                      <div style="background:#FF6B6B;height:8px;border-radius:2px"></div><div style="background:#FF6B6B;height:8px;border-radius:2px"></div><div></div><div></div>
                      <div></div><div style="background:#FF6B6B;height:8px;border-radius:2px"></div><div style="background:#FF6B6B;height:8px;border-radius:2px"></div><div></div>
                    </div>
                    <div style="color:#FF6B6B;font-weight:700;font-size:12px">Z - Zigzag</div>
                  </div>
                  <div style="background:rgba(58,108,253,0.15);border:1px solid #3A6CFD;padding:8px;border-radius:8px;text-align:center">
                    <div style="display:grid;grid-template-columns:repeat(4,8px);gap:1px;justify-content:center;margin-bottom:4px">
                      <div style="background:#3A6CFD;height:8px;border-radius:2px"></div><div></div><div></div><div></div>
                      <div style="background:#3A6CFD;height:8px;border-radius:2px"></div><div style="background:#3A6CFD;height:8px;border-radius:2px"></div><div style="background:#3A6CFD;height:8px;border-radius:2px"></div><div></div>
                    </div>
                    <div style="color:#3A6CFD;font-weight:700;font-size:12px">J - Jambe</div>
                  </div>
                  <div style="background:rgba(255,159,28,0.15);border:1px solid #FF9F1C;padding:8px;border-radius:8px;text-align:center">
                    <div style="display:grid;grid-template-columns:repeat(4,8px);gap:1px;justify-content:center;margin-bottom:4px">
                      <div></div><div></div><div style="background:#FF9F1C;height:8px;border-radius:2px"></div><div></div>
                      <div style="background:#FF9F1C;height:8px;border-radius:2px"></div><div style="background:#FF9F1C;height:8px;border-radius:2px"></div><div style="background:#FF9F1C;height:8px;border-radius:2px"></div><div></div>
                    </div>
                    <div style="color:#FF9F1C;font-weight:700;font-size:12px">L - Équerre</div>
                  </div>
                </div>
              </div>

              <!-- Commandes détaillées -->
              <div style="margin-bottom:20px">
                <div style="font-size:16px;font-weight:800;color:#fff;margin-bottom:12px;text-align:center">Contrôles</div>
                <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:10px">
                  <div style="background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1);padding:10px;border-radius:8px;text-align:center">
                    <div style="height:26px;margin-bottom:4px;display:flex;justify-content:center;gap:6px;align-items:center">
                      <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="#1FB6FF" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                      <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="#1FB6FF" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 6l6 6-6 6"/></svg>
                    </div>
                    <div style="font-weight:700;color:#1FB6FF;font-size:14px">A / D</div>
                    <div style="font-size:11px;color:#bcd6df">Déplacer gauche/droite</div>
                  </div>
                  <div style="background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1);padding:10px;border-radius:8px;text-align:center">
                    <div style="height:26px;margin-bottom:4px;display:flex;justify-content:center;align-items:center">
                      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#9B5DE5" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 2v6h-6"/><path d="M3 12a9 9 0 0 1 15-6"/><path d="M3 22v-6h6"/><path d="M21 12a9 9 0 0 1-15 6"/></svg>
                    </div>
                    <div style="font-weight:700;color:#9B5DE5;font-size:14px">W</div>
                    <div style="font-size:11px;color:#bcd6df">Rotation horaire</div>
                  </div>
                  <div style="background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1);padding:10px;border-radius:8px;text-align:center">
                    <div style="height:26px;margin-bottom:4px;display:flex;justify-content:center;align-items:center">
                      <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="#FFD166" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5v14"/><path d="M5 12l7 7 7-7"/></svg>
                    </div>
                    <div style="font-weight:700;color:#FFD166;font-size:14px">S</div>
                    <div style="font-size:11px;color:#bcd6df">Descente lente</div>
                  </div>
                  <div style="background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1);padding:10px;border-radius:8px;text-align:center">
                    <div style="height:26px;margin-bottom:4px;display:flex;justify-content:center;align-items:center">
                      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#2BD4A4" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13 2L3 14h7l-1 8 10-12h-7z"/></svg>
                    </div>
                    <div style="font-weight:700;color:#2BD4A4;font-size:14px">ESPACE</div>
                    <div style="font-size:11px;color:#bcd6df">Chute instantanée</div>
                  </div>
                  <div style="background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1);padding:10px;border-radius:8px;text-align:center">
                    <div style="height:26px;margin-bottom:4px;display:flex;justify-content:center;align-items:center">
                      <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="#FF6B6B" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>
                    </div>
                    <div style="font-weight:700;color:#FF6B6B;font-size:14px">P</div>
                    <div style="font-size:11px;color:#bcd6df">Pause/Reprendre</div>
                  </div>
                  <div style="background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1);padding:10px;border-radius:8px;text-align:center">
                    <div style="height:26px;margin-bottom:4px;display:flex;justify-content:center;align-items:center">
                      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#FF9F1C" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 2v6h-6"/><path d="M3 12a9 9 0 0 1 15-6"/><path d="M3 22v-6h6"/><path d="M21 12a9 9 0 0 1-15 6"/></svg>
                    </div>
                    <div style="font-weight:700;color:#FF9F1C;font-size:14px">R</div>
                    <div style="font-size:11px;color:#bcd6df">Recommencer</div>
                  </div>
                </div>
              </div>

              <!-- Scoring système -->
              <div style="margin-bottom:20px">
                <div style="font-size:16px;font-weight:800;color:#fff;margin-bottom:12px;text-align:center">Système de Score</div>
                <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:8px">
                  <div style="background:linear-gradient(135deg,rgba(43,212,164,0.2),rgba(43,212,164,0.1));border:1px solid #2BD4A4;padding:12px;border-radius:8px;text-align:center">
                    <div style="font-size:24px;font-weight:900;color:#2BD4A4">100</div>
                    <div style="font-size:11px;color:#bcd6df;margin-top:2px">1 ligne</div>
                  </div>
                  <div style="background:linear-gradient(135deg,rgba(255,209,102,0.2),rgba(255,209,102,0.1));border:1px solid #FFD166;padding:12px;border-radius:8px;text-align:center">
                    <div style="font-size:24px;font-weight:900;color:#FFD166">300</div>
                    <div style="font-size:11px;color:#bcd6df;margin-top:2px">2 lignes</div>
                  </div>
                  <div style="background:linear-gradient(135deg,rgba(155,93,229,0.2),rgba(155,93,229,0.1));border:1px solid #9B5DE5;padding:12px;border-radius:8px;text-align:center">
                    <div style="font-size:24px;font-weight:900;color:#9B5DE5">500</div>
                    <div style="font-size:11px;color:#bcd6df;margin-top:2px">3 lignes</div>
                  </div>
                  <div style="background:linear-gradient(135deg,rgba(31,182,255,0.2),rgba(31,182,255,0.1));border:1px solid #1FB6FF;padding:12px;border-radius:8px;text-align:center">
                    <div style="font-size:24px;font-weight:900;color:#1FB6FF">800</div>
                    <div style="font-size:11px;color:#bcd6df;margin-top:2px">4 lignes (TETRIS!)</div>
                  </div>
                </div>
                <div style="text-align:center;margin-top:8px;font-size:12px;color:#bcd6df">
                  Astuce: Score multiplié par (Niveau + 1) • Combos donnent des bonus supplémentaires.
                </div>
              </div>



            </div>
            <div class="menuActions" style="max-width:clamp(150px,50vw,250px);margin:clamp(4px,1vh,12px) auto 0">
              <button class="btn" id="helpBackBtn">Retour au Menu</button>
            </div>
          </div>

          <!-- Page Paramètres -->
          <div class="menuPage" id="tab-settings" style="display:none;flex-direction:column;align-items:center;justify-content:flex-start;gap:clamp(1vh,2vh,3vh);padding:clamp(20px,4vh,60px) clamp(8px,3vw,40px) clamp(16px,3vh,40px) clamp(8px,3vw,40px);height:auto;min-height:78vh;text-align:center">
            <div style="background:#FF6B6B;padding:clamp(8px,1.5vh,18px) clamp(12px,3vw,24px);border-radius:clamp(8px,2vw,14px);font-size:clamp(16px,3vw,22px);font-weight:900;letter-spacing:.8px;color:#fff;align-self:center;min-width:clamp(200px,45vw,280px);text-align:center">PARAMÈTRES</div>
            
            <div class="panel" style="background:linear-gradient(180deg,rgba(255,255,255,0.04),rgba(255,255,255,0.02));max-width:clamp(300px,85vw,800px);width:100%;border:1px solid rgba(255,255,255,0.08);max-height:clamp(40vh,60vh,70vh);overflow-y:auto;scrollbar-width:thin;scrollbar-color:rgba(255,255,255,0.3) transparent">
              
              <!-- Header avec titre stylé + utilisateur -->
              <div id="settingsUserIndicator" style="font-size:12px;font-weight:600;color:#bcd6df;display:flex;align-items:center;justify-content:center;gap:6px;margin-bottom:20px">
                <span style="display:inline-flex;width:22px;height:22px;border-radius:50%;background:rgba(255,255,255,0.08);align-items:center;justify-content:center;font-size:12px;color:#fff" id="settingsUserIcon">B</span>
                <span id="settingsUserText">Connecté en tant que <strong>Benjamin</strong></span>
              </div>

              <!-- Configuration Desktop -->
              <div id="desktopSettings" style="margin-bottom:20px">
                <div style="font-size:16px;font-weight:800;color:#fff;margin-bottom:20px;text-align:center">
                  Configuration des Touches
                </div>
                
                <div style="display:grid;grid-template-columns:repeat(2,1fr);gap:16px;margin-bottom:24px">
                  <!-- Gauche -->
                  <div style="background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.08);border-radius:8px;padding:16px">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
                      <div style="font-weight:700;color:#fff;font-size:14px">Gauche</div>
                      <div style="font-size:12px;color:#bcd6df">Déplacer à gauche</div>
                    </div>
                    <input class="btn" id="keyLeft" type="text" readonly value="A" style="width:100%;text-align:center;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.12);color:#e6eef6;font-weight:700">
                  </div>

                  <!-- Droite -->
                  <div style="background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.08);border-radius:8px;padding:16px">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
                      <div style="font-weight:700;color:#fff;font-size:14px">Droite</div>
                      <div style="font-size:12px;color:#bcd6df">Déplacer à droite</div>
                    </div>
                    <input class="btn" id="keyRight" type="text" readonly value="D" style="width:100%;text-align:center;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.12);color:#e6eef6;font-weight:700">
                  </div>

                  <!-- Rotation -->
                  <div style="background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.08);border-radius:8px;padding:16px">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
                      <div style="font-weight:700;color:#fff;font-size:14px">Rotation</div>
                      <div style="font-size:12px;color:#bcd6df">Tourner la pièce</div>
                    </div>
                    <input class="btn" id="keyRotate" type="text" readonly value="W" style="width:100%;text-align:center;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.12);color:#e6eef6;font-weight:700">
                  </div>

                  <!-- Descendre -->
                  <div style="background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.08);border-radius:8px;padding:16px">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
                      <div style="font-weight:700;color:#fff;font-size:14px">Descendre</div>
                      <div style="font-size:12px;color:#bcd6df">Descente lente</div>
                    </div>
                    <input class="btn" id="keyDown" type="text" readonly value="S" style="width:100%;text-align:center;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.12);color:#e6eef6;font-weight:700">
                  </div>

                  <!-- Chute rapide -->
                  <div style="background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.08);border-radius:8px;padding:16px">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
                      <div style="font-weight:700;color:#fff;font-size:14px">Chute Rapide</div>
                      <div style="font-size:12px;color:#bcd6df">Chute instantanée</div>
                    </div>
                    <input class="btn" id="keyDrop" type="text" readonly value="Espace" style="width:100%;text-align:center;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.12);color:#e6eef6;font-weight:700">
                  </div>

                  <!-- Pause -->
                  <div style="background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.08);border-radius:8px;padding:16px">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
                      <div style="font-weight:700;color:#fff;font-size:14px">Pause</div>
                      <div style="font-size:12px;color:#bcd6df">Pause/Reprendre</div>
                    </div>
                    <input class="btn" id="keyPause" type="text" readonly value="P" style="width:100%;text-align:center;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.12);color:#e6eef6;font-weight:700">
                  </div>
                </div>

                <!-- Boutons d'actions Desktop -->
                <div style="display:flex;gap:12px;justify-content:center;margin-bottom:12px">
                  <button class="btn" id="saveSettingsBtn" style="padding:12px 20px">Enregistrer</button>
                  <button class="btn" id="resetBindingsBtn" style="padding:12px 20px">Réinitialiser</button>
                </div>
              </div>

              <!-- Configuration Mobile -->
              <div id="mobileSettings" style="margin-bottom:20px;display:none">
                <div style="font-size:16px;font-weight:800;color:#fff;margin-bottom:20px;text-align:center">
                  Paramètres Mobiles
                </div>

                <!-- Section mobile simplifiée -->
                <div style="margin-bottom:24px">
                  <div style="text-align:center;font-size:12px;color:#bcd6df;font-style:italic">Que sur ordi chouchou :P</div>
                </div>
              </div>
            </div>
            
            <div class="menuActions" style="max-width:clamp(150px,50vw,250px);margin:clamp(4px,1vh,12px) auto 0">
              <button class="btn" id="settingsBackBtn">Retour au Menu</button>
            </div>
          </div>

          <!-- Page Leaderboard -->
          <div class="menuPage" id="tab-leaderboard" style="display:none;flex-direction:column;align-items:center;justify-content:flex-start;gap:clamp(1vh,2vh,3vh);padding:clamp(20px,4vh,60px) clamp(8px,2vw,40px) clamp(16px,3vh,40px) clamp(8px,2vw,40px);height:auto;min-height:78vh;text-align:center;width:100%;box-sizing:border-box">
            <div style="background:#FFD166;padding:clamp(8px,1.5vh,18px) clamp(12px,3vw,24px);border-radius:clamp(8px,2vw,14px);font-size:clamp(16px,3vw,22px);font-weight:900;letter-spacing:.8px;color:#fff;align-self:center;min-width:clamp(220px,50vw,320px);text-align:center">LEADERBOARD</div>
            <div class="panel" style="background:linear-gradient(180deg,rgba(255,255,255,0.04),rgba(255,255,255,0.02));width:100%;max-width:clamp(500px,90vw,2600px);border:1px solid rgba(255,255,255,0.08);padding:clamp(0.5rem,1vw,1.2rem) clamp(0.5rem,1vw,1.5rem);display:flex;flex-direction:column;gap:clamp(8px,1.5vh,16px);max-height:clamp(60vh,70vh,90vh);overflow-y:auto;overflow-x:auto;margin:0 auto;box-sizing:border-box">
              <div style="display:flex;justify-content:space-between;align-items:center;gap:8px;flex-wrap:wrap;margin-bottom:0.2em;margin-top:0.2em">
                <div id="lbStatus" style="font-size:12px;color:#bcd6df">Chargement…</div>
                <div style="display:flex;gap:6px;align-items:center">
                  <button class="btn" id="lbRefreshBtn" aria-label="Actualiser" title="Actualiser" style="padding:4px;display:flex;align-items:center;justify-content:center;width:32px;height:32px;line-height:1">
                    <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="#FFD166" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display:block">
                      <polyline points="23 4 23 10 17 10"></polyline>
                      <polyline points="1 20 1 14 7 14"></polyline>
                      <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10"></path>
                      <path d="M20.49 15a9 9 0 0 1-14.85 3.36L1 14"></path>
                    </svg>
                  </button>
                </div>
              </div>
              <div style="display:flex;justify-content:center;gap:10px;margin:6px 0 10px 0">
                <button id="lbTabSolo" class="btn" style="padding:8px 24px;font-weight:700;background:#1FB6FF;color:#fff;border-radius:8px;border:none;outline:none;box-shadow:0 2px 8px rgba(31,182,255,0.08);">Solo</button>
                <button id="lbTabDuo" class="btn" style="padding:8px 24px;font-weight:700;background:#ff6b6b;color:#fff;border-radius:8px;border:none;outline:none;box-shadow:0 2px 8px rgba(255,59,59,0.08);">Duo</button>
              </div>
              <div id="lbSoloPanel">
                <table style="width:100%;border-collapse:collapse;font-size:14px">
                  <thead>
                    <tr style="background:rgba(255,255,255,0.07);text-align:left">
                      <th style="padding:6px 8px;font-weight:700;color:#fff;width:36px">#</th>
                      <th style="padding:6px 8px;font-weight:700;color:#fff">Joueur</th>
                      <th style="padding:6px 8px;font-weight:700;color:#fff;width:56px;text-align:right">Niv.</th>
                      <th style="padding:6px 8px;font-weight:700;color:#fff;width:70px;text-align:right">Lignes</th>
                      <th style="padding:6px 6px;font-weight:700;color:#fff;text-align:right;white-space:nowrap;width:clamp(70px,10vw,150px)">Score</th>
                      <th style="padding:6px 8px;font-weight:700;color:#fff;width:126px">Date</th>
                    </tr>
                  </thead>
                  <tbody id="lbBody"></tbody>
                </table>
                <div style="font-size:clamp(8px,2vw,12px);color:#6d8089;text-align:center;margin-top:4px">Les 20 meilleurs scores globaux. Les nouveaux scores prennent quelques secondes à apparaître.</div>
              </div>
              <div id="lbDuoPanel" style="display:none">
                <div style="font-size:clamp(15px,3vw,20px);font-weight:700;color:#ff6b6b;margin-bottom:8px">Duo : Sanaa & Benjamin</div>
                <div style="display:flex;justify-content:center;gap:clamp(16px,3vw,32px);margin-bottom:8px">
                  <div style="flex:1;min-width:90px;max-width:160px;background:rgba(255,255,255,0.04);border-radius:10px;padding:10px 8px 8px 8px;display:flex;flex-direction:column;align-items:center">
                    <div style="font-size:clamp(15px,3vw,20px);font-weight:800;color:#FFD166;margin-bottom:2px">Sanaa</div>
                    <div style="font-size:clamp(13px,2vw,16px);color:#fff;font-weight:700;">Victoires : 0</div>
                    <div style="font-size:clamp(12px,2vw,15px);color:#bcd6df;">Meilleur chrono : –</div>
                  </div>
                  <div style="flex:1;min-width:90px;max-width:160px;background:rgba(255,255,255,0.04);border-radius:10px;padding:10px 8px 8px 8px;display:flex;flex-direction:column;align-items:center">
                    <div style="font-size:clamp(15px,3vw,20px);font-weight:800;color:#FFD166;margin-bottom:2px">Benjamin</div>
                    <div style="font-size:clamp(13px,2vw,16px);color:#fff;font-weight:700;">Victoires : 0</div>
                    <div style="font-size:clamp(12px,2vw,15px);color:#bcd6df;">Meilleur chrono : –</div>
                  </div>
                </div>
                <div style="font-size:clamp(13px,2vw,16px);font-weight:700;color:#fff;margin-bottom:6px">Historique des parties Duo</div>
                <table style="width:100%;border-collapse:collapse;font-size:14px">
                  <thead>
                    <tr style="background:rgba(255,255,255,0.07);text-align:left">
                      <th style="padding:6px 8px;font-weight:700;color:#fff;width:36px">#</th>
                      <th style="padding:6px 8px;font-weight:700;color:#fff">Gagnant</th>
                      <th style="padding:6px 8px;font-weight:700;color:#fff;width:120px;text-align:right">Chrono</th>
                      <th style="padding:6px 8px;font-weight:700;color:#fff;width:126px">Date</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr><td colspan="4" style="padding:10px;font-size:12px;color:#6d8089">Aucune partie duo enregistrée.</td></tr>
                  </tbody>
                </table>
              </div>
            </div>
            <div class="menuActions" style="max-width:clamp(180px,50vw,280px);margin:clamp(4px,1vh,12px) auto 0">
              <button class="btn" id="leaderboardBackBtn">Retour au Menu</button>
            </div>
          </div>
        </div>
        <div class="menuRight" style="display:none"></div>
      </div>
    </div>
  </div>

  <!-- GAME SCREEN -->
  <div id="gameScreen" style="display:none" class="center">
    <div class="container" style="padding:clamp(8px,2vh,20px);max-width:100vw;box-sizing:border-box">
      <!-- Version Desktop -->
      <div class="board-wrap desktop-layout" style="gap:clamp(8px,2vw,18px);align-items:flex-start;justify-content:center;flex-wrap:wrap">
        <div class="card" style="flex-shrink:0">
          <canvas id="board" style="max-width:min(70vw,400px);height:auto"></canvas>
        </div>
        <div class="side" style="min-width:clamp(200px,25vw,280px);max-width:300px">
          <div class="panel">
            <div style="display:flex;justify-content:flex-end;align-items:center"><button class="btn" id="backBtn" style="padding:clamp(6px,2vw,12px) clamp(8px,3vw,16px);font-size:clamp(10px,3vw,14px)">Menu</button></div>
            <div style="margin-top:10px;font-size:clamp(12px,3vw,14px)">Score: <strong id="score" style="color:#FFD166;font-size:clamp(14px,3.5vw,18px)">0</strong></div>
            <div style="font-size:clamp(12px,3vw,14px)">Niveau: <strong id="level" style="color:#1FB6FF;font-size:clamp(13px,3.2vw,16px)">0</strong></div>
            <div style="font-size:clamp(12px,3vw,14px)">Lignes: <strong id="lines" style="color:#2BD4A4;font-size:clamp(13px,3.2vw,16px)">0</strong></div>
          </div>
          <div class="panel">
            <div style="text-align:center;margin-bottom:8px;font-size:clamp(11px,3vw,14px)">Prochaines</div>
            <div class="nextList" style="gap:clamp(4px,1vw,8px)">
              <canvas id="next1" width="96" height="64" style="border-radius:10px;overflow:hidden;background:#031318;max-width:15vw;max-height:10vw"></canvas>
              <canvas id="next2" width="96" height="64" style="border-radius:10px;overflow:hidden;background:#031318;max-width:15vw;max-height:10vw"></canvas>
              <canvas id="next3" width="96" height="64" style="border-radius:10px;overflow:hidden;background:#031318;max-width:15vw;max-height:10vw"></canvas>
            </div>
          </div>
        </div>
      </div>

      <!-- Version Mobile optimisée -->
      <div class="mobile-layout" style="display:none;position:relative;width:100vw;height:100vh;box-sizing:border-box">
        <!-- Score/Niveau en haut à gauche avec prochaines pièces en dessous -->
  <div class="mobile-ui" style="position:absolute;top:clamp(4px,1vh,8px);left:clamp(0px,0.2vw,2px);z-index:100">
          <!-- Score/Stats -->
          <div class="mobile-stats" style="background:rgba(0,0,0,0.25);border:1px solid rgba(255,255,255,0.1);border-radius:10px;padding:clamp(6px,1.5vh,10px) clamp(8px,2vw,12px);backdrop-filter:blur(8px);font-size:clamp(12px,3vw,16px);color:#e4f3fa;font-weight:600;margin-bottom:clamp(6px,1.5vh,10px)">
            <div>Score: <strong id="mobileScore" style="color:#FFD166;font-size:clamp(14px,3.5vw,20px)">0</strong></div>
            <div>Niveau: <strong id="mobileLevel" style="color:#1FB6FF;font-size:clamp(12px,3vw,16px)">0</strong></div>
            <div>Lignes: <strong id="mobileLines" style="color:#2BD4A4;font-size:clamp(12px,3vw,16px)">0</strong></div>
          </div>
          
          <!-- Prochaines pièces en dessous du score -->
          <div class="mobile-next" style="background:rgba(0,0,0,0.25);border:1px solid rgba(255,255,255,0.1);border-radius:10px;padding:clamp(4px,1vh,6px) clamp(4px,1vw,6px);backdrop-filter:blur(8px);display:flex;flex-direction:column;align-items:center;gap:clamp(2px,0.5vh,4px);margin-top:clamp(2px,0.5vh,6px)">
            <div style="font-size:clamp(9px,2vw,11px);color:#e4f3fa;text-align:center;opacity:0.7;margin:0 auto 1px auto;width:100%">Suivant</div>
            <canvas id="mobileNext1" width="64" height="40" style="display:block;margin:0 auto;border-radius:6px;background:#031318;border:1px solid rgba(255,255,255,0.08)"></canvas>
            <canvas id="mobileNext2" width="64" height="40" style="display:block;margin:0 auto;border-radius:6px;background:#031318;border:1px solid rgba(255,255,255,0.1)"></canvas>
            <canvas id="mobileNext3" width="64" height="40" style="display:block;margin:0 auto;border-radius:6px;background:#031318;border:1px solid rgba(255,255,255,0.1)"></canvas>
          </div>
        </div>

        <!-- Jeu parfaitement centré - 80% de l'écran -->
  <div style="position:absolute;top:42%;left:50%;transform:translate(-55%,-50%);z-index:50;display:flex;align-items:center;justify-content:center;width:100vw;height:100vh;pointer-events:none">
          <canvas id="mobileBoard" style="max-width:90vw;max-height:88vh;border:2px solid rgba(255,255,255,0.12);border-radius:10px;background:#000;margin:0 auto;pointer-events:auto"></canvas>
        </div>
      </div>
    </div>
    
    <!-- Contrôles tactiles mobiles discrets -->
  <div id="mobileTouchControls" style="display:none;position:fixed;top:0;left:0;width:100vw;height:100vh;pointer-events:none;z-index:1000">
      <!-- Bouton pause en haut à droite -->
      <div class="mobileBtn" id="pauseBtn" style="position:absolute;top:clamp(8px,2vh,16px);right:clamp(8px,2vw,16px);background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.12);color:rgba(255,255,255,0.7);width:clamp(36px,8vw,44px);height:clamp(36px,8vw,44px);border-radius:8px;display:flex;align-items:center;justify-content:center;backdrop-filter:blur(8px);pointer-events:auto">
        <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor"><rect x="3" y="2" width="3" height="12" rx="1"/><rect x="10" y="2" width="3" height="12" rx="1"/></svg>
      </div>
      
      <!-- Boutons gauche/droite au centre -->
      <div style="position:absolute;top:50%;left:clamp(8px,2vw,10px);transform:translateY(-50%);display:flex;flex-direction:column;gap:20px;pointer-events:auto">
        <div class="mobileBtn" id="mLeft" style="background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.1);color:rgba(255,255,255,0.6);width:clamp(50px,12vw,60px);height:clamp(50px,12vw,60px);border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:clamp(18px,4vw,24px);backdrop-filter:blur(8px)">◀</div>
      </div>
      <div style="position:absolute;top:50%;right:clamp(8px,2vw,10px);transform:translateY(-50%);display:flex;flex-direction:column;gap:20px;pointer-events:auto">
        <div class="mobileBtn" id="mRight" style="background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.1);color:rgba(255,255,255,0.6);width:clamp(50px,12vw,60px);height:clamp(50px,12vw,60px);border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:clamp(18px,4vw,24px);backdrop-filter:blur(8px)">▶</div>
      </div>
      
      <!-- Boutons bas centre -->
  <div style="position:absolute;bottom:clamp(88px,16vh,100px);left:50%;transform:translateX(-50%);display:flex;gap:clamp(12px,3vw,15px);pointer-events:auto">
        <div class="mobileBtn" id="mRotate" style="background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.1);color:rgba(255,255,255,0.6);width:clamp(50px,12vw,55px);height:clamp(50px,12vw,55px);border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:clamp(16px,4vw,20px);backdrop-filter:blur(8px)">⤾</div>
        <div class="mobileBtn" id="mDown" style="background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.1);color:rgba(255,255,255,0.6);width:clamp(50px,12vw,55px);height:clamp(50px,12vw,55px);border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:clamp(16px,4vw,20px);backdrop-filter:blur(8px)">▼</div>
        <div class="mobileBtn" id="mDrop" style="background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.1);color:rgba(255,255,255,0.6);width:clamp(50px,12vw,55px);height:clamp(50px,12vw,55px);border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:clamp(16px,4vw,20px);backdrop-filter:blur(8px)">⤓</div>
      </div>
    </div>
  </div>

  <!-- combo badge -->
  <div class="comboBadge" id="comboBadge">COMBO +1</div>

  <!-- Pause modal responsive -->
  <div id="pauseOverlay" class="overlayFull" style="display:none;background:rgba(0,0,0,0.45);z-index:3000">
    <div style="background:linear-gradient(180deg,#0a1822,#07141b);border:1px solid rgba(255,255,255,0.05);padding:clamp(12px,3vh,18px) clamp(16px,4vw,20px);border-radius:12px;box-shadow:0 20px 60px rgba(0,0,0,0.5);min-width:clamp(200px,60vw,260px);text-align:center;max-width:90vw;display:flex;flex-direction:column;gap:clamp(10px,2vh,14px)">
      <div style="font-size:clamp(16px,5vw,22px);font-weight:800;letter-spacing:.6px">Pause</div>
      <div id="pauseAudioRow" style="display:none;gap:clamp(6px,2.5vw,10px);justify-content:center;flex-wrap:wrap">
        <button class="btn" id="toggleMusicBtn" style="flex:1;min-width:100px;font-size:clamp(11px,3.2vw,13px);padding:clamp(6px,1.6vh,9px) clamp(10px,3vw,14px);background:rgba(255,255,255,0.07)">Musique: ON</button>
        <button class="btn" id="toggleSfxBtn" style="flex:1;min-width:100px;font-size:clamp(11px,3.2vw,13px);padding:clamp(6px,1.6vh,9px) clamp(10px,3vw,14px);background:rgba(255,255,255,0.07)">SFX: ON</button>
      </div>
      <div style="display:flex;gap:clamp(6px,3vw,10px);justify-content:center;flex-wrap:wrap">
        <button class="btn" id="pauseContinueBtn" style="font-size:clamp(12px,3vw,14px);padding:clamp(8px,2vh,10px) clamp(12px,3vw,16px)">Continuer</button>
        <button class="btn" id="pauseMenuBtn" style="font-size:clamp(12px,3vw,14px);padding:clamp(8px,2vh,10px) clamp(12px,3vw,16px)">Menu</button>
      </div>
    </div>
  </div>

  <!-- touch controls -->
  <!-- Game Over responsive overlay -->
  <div id="gameOverOverlay" class="overlayFull" style="display:none;pointer-events:auto;background:rgba(0,0,0,0.55);backdrop-filter:blur(6px);z-index:4000">
    <div class="gameOverWrap" style="display:flex;flex-direction:column;align-items:center;gap:clamp(8px,2vh,14px);pointer-events:auto;padding:clamp(8px,2vw,16px);max-width:90vw">
      <div class="gameOverText" id="gameOverText" style="font-size:clamp(28px,8vw,48px);font-weight:900;margin-bottom:clamp(8px,2vh,16px);background:linear-gradient(45deg,#FF6B6B,#FFD166);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text;letter-spacing:1.5px">GAME OVER</div>
  <div id="gameOverStats" style="opacity:0;transform:translateY(6px);transition:.45s;display:flex;flex-direction:column;gap:clamp(6px,2vh,10px);font-size:clamp(12px,3.5vw,15px);font-weight:600;color:#e4f3fa;background:linear-gradient(180deg,rgba(255,255,255,0.08),rgba(255,255,255,0.03));padding:clamp(12px,3vh,20px) clamp(16px,4vw,26px) clamp(10px,2.5vh,18px) clamp(16px,4vw,26px);border:1px solid rgba(255,255,255,0.09);border-radius:clamp(12px,3vw,18px);backdrop-filter:blur(6px);min-width:clamp(240px,60vw,400px);max-width:90vw;text-align:left;box-shadow:0 8px 32px rgba(0,0,0,0.55)">
  <div style="display:flex;justify-content:space-between;align-items:center"><span style="opacity:.85">Score</span><span id="goScore" style="color:#FFD166;font-weight:800;font-size:clamp(16px,4vw,20px)">0</span></div>
  <div style="display:flex;justify-content:space-between;align-items:center"><span style="opacity:.85">Niveau</span><span id="goLevel" style="color:#4DD2FF;font-weight:700;font-size:clamp(14px,3.5vw,18px)">1</span></div>
  <div style="display:flex;justify-content:space-between;align-items:center"><span style="opacity:.85">Lignes</span><span id="goLines" style="color:#2BD4A4;font-weight:700;font-size:clamp(14px,3.5vw,18px)">0</span></div>
  <div style="margin-top:2px;font-size:clamp(10px,2.5vw,12px);color:#8baebb" id="goHint">Rejouer ou Menu pour revenir</div>
      </div>
      <div style="display:flex;gap:clamp(6px,2vw,10px);justify-content:center;width:100%;flex-wrap:wrap">
        <button class="btn btn-lg" id="replayBtn" style="pointer-events:auto;flex:1;min-width:clamp(80px,20vw,120px);font-size:clamp(12px,3vw,14px);padding:clamp(8px,2vh,12px) clamp(12px,3vw,16px)">Rejouer</button>
        <button class="btn btn-lg" id="menuBtnFromGO" style="pointer-events:auto;flex:1;min-width:clamp(80px,20vw,120px);font-size:clamp(12px,3vw,14px);padding:clamp(8px,2vh,12px) clamp(12px,3vw,16px)">Menu</button>
      </div>
    </div>
  </div>

  <!-- Modal de confirmation pour quitter -->
  <div id="quitConfirmModal" class="quitConfirmModal">
    <div class="quitConfirmContent">
      <div class="quitConfirmTitle">Quitter la partie ?</div>
      <div class="quitConfirmStats">
        <div>Score: <span id="quitScore">0</span></div>
        <div>Niveau: <span id="quitLevel">1</span></div>
        <div>Lignes: <span id="quitLines">0</span></div>
      </div>
      <div style="font-size:clamp(12px,3vw,14px);color:#8baebb;margin-bottom:clamp(12px,2vh,16px)">
        Votre résultat sera sauvegardé automatiquement
      </div>
      <div class="quitConfirmActions">
        <button class="quitConfirmBtn continue" id="quitContinue">Continuer</button>
        <button class="quitConfirmBtn quit" id="quitConfirm">Quitter</button>
      </div>
    </div>
  </div>

<script>
/* Tetris full — features:
   - Menu as separate page
   - built-in music (synth loop)
   - auto AZERTY/QWERTY mapping (based on navigator.language) + settings available
   - 3-next pieces
   - line clear bar animation + particles
   - combo counter
   - animated GAME OVER text
*/

// Board constants
const COLS = 10, ROWS = 20; let BLOCK = 30;
let boardCanvas, ctx;

// Initialiser le canvas selon la plateforme
function initBoard() {
  const isMobileView = window.innerWidth <= 820;
  if (isMobileView) {
    boardCanvas = document.getElementById('mobileBoard');
    // Copier le canvas mobile vers les desktop canvas pour consistance
    const desktopBoard = document.getElementById('board');
    if (desktopBoard) {
      desktopBoard.width = boardCanvas.width;
      desktopBoard.height = boardCanvas.height;
    }
  } else {
    boardCanvas = document.getElementById('board');
    // Copier le canvas desktop vers mobile pour consistance
    const mobileBoard = document.getElementById('mobileBoard');
    if (mobileBoard) {
      mobileBoard.width = boardCanvas.width;
      mobileBoard.height = boardCanvas.height;
    }
  }
  ctx = boardCanvas.getContext('2d');
}
function resizeBoard(){
  // Initialiser le bon canvas selon la taille d'écran
  initBoard();
  
  // compute max block size that fits viewport without scroll, considering side panel width ~ 320px and margins
  const vw = window.innerWidth, vh = window.innerHeight;
  
  // Mobile optimization: ensure full game visibility - 80% de l'écran
  if(vw <= 768) {
    // Mobile: utiliser 85% de l'espace (après recentrage) et autoriser blocs plus grands
    const availableW = vw * 0.85;
    const availableH = vh * 0.85;
    const blockByW = Math.floor(availableW / COLS);
    const blockByH = Math.floor(availableH / ROWS);
    BLOCK = Math.max(16, Math.min(40, Math.min(blockByW, blockByH))); // augmentation du max
  } else {
    // Desktop logic
    const sideW = Math.min(360, Math.max(280, Math.floor(vw*0.28))); // estimate side panel
    const availableW = Math.max(200, vw - (vw>820? sideW + 60 : 40));
    const availableH = vh - 80; // some breathing room for top/bottom
    const blockByW = Math.floor(availableW / COLS);
    const blockByH = Math.floor(availableH / ROWS);
    BLOCK = Math.max(14, Math.min(36, Math.min(blockByW, blockByH))); // clamp for comfort
  }
  
  boardCanvas.width = COLS*BLOCK; boardCanvas.height = ROWS*BLOCK;
  
  // Synchroniser les deux canvas
  const otherCanvas = vw <= 820 ? document.getElementById('board') : document.getElementById('mobileBoard');
  if (otherCanvas) {
    otherCanvas.width = boardCanvas.width;
    otherCanvas.height = boardCanvas.height;
  }
}
resizeBoard();
window.addEventListener('resize', ()=>{ resizeBoard(); drawBoard(); renderNext(); });

const nextCanvases = [document.getElementById('next1'), document.getElementById('next2'), document.getElementById('next3')];
const mobileNextCanvases = [document.getElementById('mobileNext1'), document.getElementById('mobileNext2'), document.getElementById('mobileNext3')];
const nextCtx = nextCanvases.filter(c=>c).map(c=>c.getContext('2d'));
const mobileNextCtx = mobileNextCanvases.filter(c=>c).map(c=>c.getContext('2d'));

const COLORS = { 'I':'#1FB6FF','O':'#FFD166','T':'#9B5DE5','S':'#2BD4A4','Z':'#FF6B6B','J':'#3A6CFD','L':'#FF9F1C' };
const TETROMINOES = { 'I': [[[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]]], 'O': [[[0,1,1,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]]], 'T': [[[0,1,0,0],[1,1,1,0],[0,0,0,0],[0,0,0,0]]], 'S': [[[0,1,1,0],[1,1,0,0],[0,0,0,0],[0,0,0,0]]], 'Z': [[[1,1,0,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]]], 'J': [[[1,0,0,0],[1,1,1,0],[0,0,0,0],[0,0,0,0]]], 'L': [[[0,0,1,0],[1,1,1,0],[0,0,0,0],[0,0,0,0]]] };
function rotateMatrix(mat){ const N=mat.length; const res=Array.from({length:N},()=>Array(N).fill(0)); for(let r=0;r<N;r++) for(let c=0;c<N;c++) res[c][N-1-r]=mat[r][c]; return res; }
for(const k of Object.keys(TETROMINOES)){ let rots=TETROMINOES[k]; let full=rots.slice(); let curr=rots[0]; for(let i=1;i<4;i++){ curr=rotateMatrix(curr); if(!full.some(m=>JSON.stringify(m)===JSON.stringify(curr))) full.push(curr);} TETROMINOES[k]=full; }

// Mobile/Desktop detection and settings management
const isMobile = () => /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
let isOnMobile = isMobile();

// Initialize correct settings UI
function initPlatformSettings() {
  const desktopSettings = document.getElementById('desktopSettings');
  const mobileSettings = document.getElementById('mobileSettings');
  
  if (isOnMobile) {
    if (desktopSettings) desktopSettings.style.display = 'none';
    if (mobileSettings) mobileSettings.style.display = 'block';
  } else {
    if (desktopSettings) desktopSettings.style.display = 'block';
    if (mobileSettings) mobileSettings.style.display = 'none';
  }
}

// Mobile swipe controls
let touchStartX = 0, touchStartY = 0;
let swipeSensitivity = 2; // 1=high, 2=normal, 3=low
let vibrationsEnabled = true;

const swipeThresholds = {
  1: { distance: 30, time: 200 }, // High sensitivity
  2: { distance: 50, time: 300 }, // Normal
  3: { distance: 80, time: 400 }  // Low sensitivity
};

function vibrate(duration = 50) {
  if (vibrationsEnabled && navigator.vibrate) {
    navigator.vibrate(duration);
  }
}

function handleTouchStart(e) {
  if (!isOnMobile || !running) return;
  
  const touch = e.touches[0];
  touchStartX = touch.clientX;
  touchStartY = touch.clientY;
  e.preventDefault();
}

function handleTouchEnd(e) {
  if (!isOnMobile || !running) return;
  
  const touch = e.changedTouches[0];
  const endX = touch.clientX;
  const endY = touch.clientY;
  const diffX = endX - touchStartX;
  const diffY = endY - touchStartY;
  
  const threshold = swipeThresholds[swipeSensitivity];
  const absX = Math.abs(diffX);
  const absY = Math.abs(diffY);
  
  if (Math.max(absX, absY) < threshold.distance) return;
  
  e.preventDefault();
  
  if (absX > absY) {
    // Horizontal swipe
    if (diffX > 0) {
      // Swipe right
      movePiece(1);
      vibrate(30);
    } else {
      // Swipe left
      movePiece(-1);
      vibrate(30);
    }
  } else {
    // Vertical swipe
    if (diffY < 0) {
      // Swipe up
      rotatePiece();
      vibrate(40);
    } else {
      // Swipe down
      dropPiece();
      vibrate(50);
    }
  }
}

// Mobile settings event listeners
function initMobileSettings() {
  // Plus de paramètres mobiles complexes - juste un message personnalisé maintenant
  // Rien à initialiser côté JavaScript
}

function updateMobileConnectionStatus() {
  // Cette fonction n'est plus utilisée car on a remplacé l'indicateur par un message statique
  // Conservée pour éviter les erreurs si appelée ailleurs
}

// Grid
let grid = Array.from({length:ROWS}, ()=>Array(COLS).fill(0));
function resetGrid(){ grid = Array.from({length:ROWS}, ()=>Array(COLS).fill(0)); }

// piece & bag
function createPiece(type){ const rots=TETROMINOES[type]; return { type, rots, rotIndex:0, shape:rots[0], x:Math.floor(COLS/2)-2, y:-1 }; }
function randomBag(){ const seq = Object.keys(TETROMINOES).slice(); for(let i=seq.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [seq[i],seq[j]]=[seq[j],seq[i]]; } return seq; }
let bag = []; function nextFromBag(){ if(!bag.length) bag=randomBag(); return bag.pop(); }

// queue (3 next)
let nextQueue = [];
function fillQueue(){ while(nextQueue.length<3) nextQueue.push(createPiece(nextFromBag())); }

let cur = null;
function spawn(){ cur = nextQueue.shift(); cur.x = Math.floor(COLS/2)-2; cur.y = -1; nextQueue.push(createPiece(nextFromBag())); renderNext(); if(collides(cur,0,0)) onGameOver(); }

// game state
let dropInterval = 800; let lastDrop = 0; let lastTime = 0; let score = 0; let level = 0; let lines = 0; let running = false; var highscore = Number(localStorage.getItem('tetris_hs')||0);
const hsEl = document.getElementById('hsValue'); if(hsEl) hsEl.innerText = highscore;

// combo handling: add number of lines cleared to combo directly
let combo = 0; let lastClearWas = false;
function registerClear(c){
  if(c>0){ combo += c; lastClearWas = true; showCombo(combo); }
  else { lastClearWas = false; combo = 0; }
}
function showCombo(n){ const el = document.getElementById('comboBadge'); el.innerText = `COMBO x${n}`; el.classList.add('show'); clearTimeout(el._t); el._t = setTimeout(()=>el.classList.remove('show'), 900); }

// audio: musique fixe depuis son/Tetris.mp3 + SFX (WebAudio)
let audioCtx = null; let musicOn = true, sfxOn = true;
let audioEl = null; // <audio> pour la musique de fond
function ensureAudio(){ if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }

function startMusic(){
  if(!musicOn) return;
  if(!audioEl){ audioEl = new Audio('Son/Tetris.mp3'); audioEl.loop = true; audioEl.volume = 0.25; }
  const p = audioEl.play(); if(p && p.catch){ p.catch(()=>{}); }
}
function stopMusic(){ if(audioEl){ try{ audioEl.pause(); audioEl.currentTime = 0; }catch(e){} } }

function playNote(time,freq,dur=0.18,type='sine',gain=0.05){ ensureAudio(); const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.type=type; o.frequency.setValueAtTime(freq,time); g.gain.setValueAtTime(gain,time); o.connect(g); g.connect(audioCtx.destination); o.start(time); o.stop(time+dur); }
function playSfx(name){ if(!sfxOn) return; ensureAudio(); const now = audioCtx.currentTime; function n(freq,dur,type,g){ const o=audioCtx.createOscillator(); const gg=audioCtx.createGain(); o.type=type||'sine'; o.frequency.setValueAtTime(freq,now); gg.gain.setValueAtTime(g||0.06,now); o.connect(gg); gg.connect(audioCtx.destination); o.start(now); o.stop(now+dur); }
  if(name==='rotate') n(880,0.08,'triangle',0.08); else if(name==='drop') n(440,0.06,'square',0.12); else if(name==='clear'){ n(523,0.18); n(660,0.18,'sine',0.07); n(784,0.18,'sine',0.05);} else if(name==='lock') n(196,0.12,'sawtooth',0.06);
}

// rendering helpers
function roundRect(c,x,y,w,h,r){ c.beginPath(); c.moveTo(x+r,y); c.arcTo(x+w,y,x+w,y+h,r); c.arcTo(x+w,y+h,x,y+h,r); c.arcTo(x,y+h,x,y,r); c.arcTo(x,y,x+w,y,r); c.closePath(); }
function shadeColor(hex,p){ const f=parseInt(hex.slice(1),16), t=p<0?0:255, pct=Math.abs(p)/100; const R=Math.round((t - (f>>16)) * pct) + (f>>16); const G=Math.round((t - (f>>8 & 0x00FF)) * pct) + (f>>8 & 0x00FF); const B=Math.round((t - (f & 0x0000FF)) * pct) + (f & 0x0000FF); return `rgb(${R},${G},${B})`; }

function drawBlock(c,x,y,color,cell=BLOCK,flash=0){ const px = x*cell, py = y*cell; c.fillStyle = color; roundRect(c,px+1,py+1,cell-2,cell-2,Math.max(3,Math.floor(cell/8))); c.fill(); c.strokeStyle = shadeColor(color,-30); c.lineWidth = 2; roundRect(c,px+1,py+1,cell-2,cell-2,Math.max(3,Math.floor(cell/8))); c.stroke(); const sq = Math.max(2,Math.floor(cell/6)); c.fillStyle = shadeColor(color,12); for(let i=0;i<4;i++){ const sx = px + 4 + (i%2)*(sq+2); const sy = py + 4 + Math.floor(i/2)*(sq+2); c.fillRect(sx,sy,sq,sq); } if(flash>0){ c.fillStyle = `rgba(255,255,255,${flash})`; c.fillRect(px+1,py+1,cell-2,cell-2); } }

function drawBoard(highlightRows=[]){
  ctx.clearRect(0,0,boardCanvas.width,boardCanvas.height);
  ctx.fillStyle = '#06161b';
  ctx.fillRect(0,0,boardCanvas.width,boardCanvas.height);
  // blocs déjà posés
  for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) if(grid[r][c]){ const flash = highlightRows.includes(r)?0.5:0; drawBlock(ctx,c,r,COLORS[grid[r][c]],BLOCK,flash); }

  // ghost piece (prévisualisation de la position finale)
  if(cur){
    let ghostY = cur.y;
    // avancer jusqu'à collision puis revenir implicitement en ne dépassant pas
    while(true){
      if(collides({x:cur.x,y:ghostY,shape:cur.shape},0,1)) break;
      ghostY++;
    }
    if(ghostY > cur.y){
      ctx.save();
      ctx.globalAlpha = 0.28; // transparence du ghost
      const ghostColor = shadeColor(COLORS[cur.type],35);
      for(let r=0;r<4;r++) for(let c=0;c<4;c++) if(cur.shape[r][c]){ const x = cur.x + c; const y = ghostY + r; if(y>=0) drawBlock(ctx,x,y,ghostColor); }
      ctx.restore();
    }
  }

  // pièce courante
  if(cur){ for(let r=0;r<4;r++) for(let c=0;c<4;c++) if(cur.shape[r][c]){ const x = cur.x + c, y = cur.y + r; if(y>=0) drawBlock(ctx,x,y,COLORS[cur.type]); } }

  // grille légère
  ctx.strokeStyle='rgba(0,0,0,0.12)'; ctx.lineWidth=1;
  for(let x=0;x<=COLS;x++){ ctx.beginPath(); ctx.moveTo(x*BLOCK,0); ctx.lineTo(x*BLOCK,boardCanvas.height); ctx.stroke(); }
  for(let y=0;y<=ROWS;y++){ ctx.beginPath(); ctx.moveTo(0,y*BLOCK); ctx.lineTo(boardCanvas.width,y*BLOCK); ctx.stroke(); }
}

function renderNext(){
  const pairsDesktop = nextCanvases.filter(c=>c).map(c=>({c, ctx:c.getContext('2d')}));
  const pairsMobile = mobileNextCanvases.filter(c=>c).map(c=>({c, ctx:c.getContext('2d')}));
  pairsDesktop.forEach((p,idx)=>{
    const {c,ctx} = p; ctx.clearRect(0,0,c.width,c.height); ctx.fillStyle='#031318'; ctx.fillRect(0,0,c.width,c.height);
    const piece = nextQueue[idx]; if(!piece) return; const shape = piece.shape; const cell = Math.floor(Math.min(c.width/4,c.height/4));
    const startX = Math.floor((c.width - cell*4)/2); const startY = Math.floor((c.height - cell*4)/2) + cell;
    for(let r=0;r<4;r++) for(let cc=0;cc<4;cc++) if(shape[r][cc]){ drawBlock(ctx,(startX + cc*cell)/cell,(startY + r*cell)/cell,COLORS[piece.type],cell); }
  });
  pairsMobile.forEach((p,idx)=>{
    const {c,ctx} = p; ctx.clearRect(0,0,c.width,c.height); ctx.fillStyle='#031318'; ctx.fillRect(0,0,c.width,c.height);
    const piece = nextQueue[idx]; if(!piece) return; const shape = piece.shape; const cell = Math.floor(Math.min(c.width/4,c.height/4));
    const startX = Math.floor((c.width - cell*4)/2); const startY = Math.floor((c.height - cell*4)/2) + cell;
    for(let r=0;r<4;r++) for(let cc=0;cc<4;cc++) if(shape[r][cc]){ drawBlock(ctx,(startX + cc*cell)/cell,(startY + r*cell)/cell,COLORS[piece.type],cell); }
  });
}

// collision + lock
function collides(piece,dx,dy,pros=null){ if(!piece) return true; const shape = pros || piece.shape; for(let r=0;r<4;r++) for(let c=0;c<4;c++) if(shape[r][c]){ const x = piece.x + c + dx; const y = piece.y + r + dy; if(x<0 || x>=COLS || y>=ROWS) return true; if(y>=0 && grid[y][x]) return true; } return false; }

// line-clear animation: sweep bars
let sweeps = []; // {row, t, duration}
let particles = [];
let lastClearedRows = [];
let clearEffect = null; // {type, t, duration}
function spawnParticlesForRow(r){ for(let c=0;c<COLS;c++){ const x = c*BLOCK + BLOCK/2; const y = r*BLOCK + BLOCK/2; const angle = Math.random()*Math.PI*2; const speed = 1 + Math.random()*3; particles.push({x,y,vx:Math.cos(angle)*speed, vy:Math.sin(angle)*speed - 2, life:120, color:shadeColor(COLORS[grid[r][c]]||'#fff',0)}); } }
function updateParticles(){ for(let i=particles.length-1;i>=0;i--){ const p=particles[i]; p.x += p.vx; p.y += p.vy; p.vy += 0.12; p.life--; if(p.life<=0) particles.splice(i,1); } }
function drawParticles(){ for(const p of particles){ ctx.fillStyle = p.color; ctx.fillRect(p.x-3,p.y-3,6,6); } }

function clearLinesWithSweep(){ // sweep animation then remove lines
  const full = []; for(let r=0;r<ROWS;r++) if(grid[r].every(cell=>cell)) full.push(r);
  if(!full.length) return 0;
  lastClearedRows = full.slice();
  sweeps.length = 0;
  const duration = 260;
  full.forEach(r=>{ sweeps.push({row:r, t:0, duration}); spawnParticlesForRow(r); });
  return full.length;
}

function triggerClearEffect(count, rows){
  if(!count) return;
  let type = count===2?'double': count===3?'triple': count===4?'tetris':'single';
  if(type==='single') return; // pas d'effet spécial pour 1
  const duration = type==='tetris'?1200: (type==='triple'?800:600);
  clearEffect = {type, t:0, duration};
  // Particules supplémentaires pour triple et tetris
  if(type==='triple' || type==='tetris'){
    rows.forEach(r=>{ for(let c=0;c<COLS;c++){ const x=c*BLOCK+BLOCK/2, y=r*BLOCK+BLOCK/2; for(let i=0;i< (type==='tetris'?8:4); i++){ const ang = Math.random()*Math.PI*2; const sp = (type==='tetris'? 2+Math.random()*5:1+Math.random()*3); particles.push({x,y,vx:Math.cos(ang)*sp, vy:Math.sin(ang)*sp - (type==='tetris'?3:2), life:type==='tetris'?160:120, color: shadeColor(COLORS[grid[r][c]]||'#fff', type==='tetris'? 40:20) }); } }});
  }
}

function updateClearEffect(dt){ if(!clearEffect) return; clearEffect.t += dt; if(clearEffect.t >= clearEffect.duration) clearEffect=null; }

function drawClearEffectOverlay(){ if(!clearEffect) return; const p = clearEffect.t/clearEffect.duration; ctx.save();
  if(clearEffect.type==='double'){
    // pulsation colorée bleue/orange
    const alpha = 0.25 * (1 - p);
    const grd = ctx.createLinearGradient(0,0,boardCanvas.width,boardCanvas.height);
    grd.addColorStop(0,'rgba(31,182,255,'+alpha+')');
    grd.addColorStop(1,'rgba(255,159,28,'+alpha+')');
    ctx.fillStyle = grd; ctx.fillRect(0,0,boardCanvas.width,boardCanvas.height);
  } else if(clearEffect.type==='triple'){
    // vague radiale violette/jaune
    const alpha = 0.30 * (1 - p);
    const cx = boardCanvas.width/2, cy = boardCanvas.height/2;
    const rad = Math.max(cx,cy)*1.2 * p;
    const radial = ctx.createRadialGradient(cx,cy,rad*0.2, cx,cy,rad);
    radial.addColorStop(0,'rgba(155,93,229,'+alpha+')');
    radial.addColorStop(1,'rgba(255,209,102,0)');
    ctx.fillStyle = radial; ctx.fillRect(0,0,boardCanvas.width,boardCanvas.height);
  } else if(clearEffect.type==='tetris'){
    // arc-en-ciel + flash + scan vertical
    const scanProgress = p;
    const bandY = scanProgress * boardCanvas.height;
    // flash initial
    const flash = Math.max(0, 0.5 - p*0.5);
    if(flash>0){ ctx.fillStyle='rgba(255,255,255,'+flash+')'; ctx.fillRect(0,0,boardCanvas.width,boardCanvas.height); }
    // arc-en-ciel global
    const rainbow = ctx.createLinearGradient(0,0,boardCanvas.width,0);
    const cols=['#1FB6FF','#9B5DE5','#FF6B6B','#FFD166','#2BD4A4'];
    cols.forEach((cl,i)=> rainbow.addColorStop(i/(cols.length-1), cl));
    ctx.globalAlpha = 0.22 * (1 - p);
    ctx.fillStyle = rainbow; ctx.fillRect(0,0,boardCanvas.width,boardCanvas.height);
    // bande descendante
    ctx.globalAlpha = 0.35 * (1 - p*0.7);
    ctx.fillStyle = 'rgba(255,255,255,0.25)';
    ctx.fillRect(0, Math.max(0, bandY - 30 - 80*(1-p)), boardCanvas.width, 60);
  }
  ctx.restore();
  // screen shake pour tetris
  if(clearEffect.type==='tetris'){
    const prog = p;
    const amp = 6 * (1 - prog);
    const ox = (Math.random()*2-1)*amp;
    const oy = (Math.random()*2-1)*amp;
    boardCanvas.style.transform = `translate(${ox}px,${oy}px)`;
  } else {
    boardCanvas.style.transform = '';
  }
}

function drawHardDropEffect(){
  if(!hardDropEffect) return;
  hardDropEffect.t += lastTime ? 0 : 0; // placeholder (time progression via frame diff not stored; use timestamp difference?)
  // Utiliser performance.now diff: on stocke pas dt ici, donc on piggyback sur t via Date
  if(!hardDropEffect._start) hardDropEffect._start = performance.now();
  const elapsed = performance.now() - hardDropEffect._start;
  const p = elapsed / hardDropEffect.duration;
  const cells = hardDropEffect.cells;
  if(p>=1){ hardDropEffect=null; boardCanvas.style.filter=''; return; }
  ctx.save();
  // halo expansif depuis centre de masse des cellules
  let cx=0, cy=0; cells.forEach(c=>{ cx += (c.x+0.5)*BLOCK; cy += (c.y+0.5)*BLOCK; }); cx/=cells.length; cy/=cells.length;
  const maxR = Math.max(boardCanvas.width, boardCanvas.height)*0.6;
  const r = maxR * p;
  const g = ctx.createRadialGradient(cx,cy, r*0.15, cx,cy,r);
  const base = hardDropEffect.color;
  g.addColorStop(0, base + '');
  g.addColorStop(0.3, shadeColor(base,40));
  g.addColorStop(1, 'rgba(255,255,255,0)');
  ctx.globalAlpha = 0.25 * (1 - p);
  ctx.fillStyle = g;
  ctx.fillRect(0,0,boardCanvas.width,boardCanvas.height);
  // impact flash par bloc
  ctx.globalAlpha = 0.35 * (1 - p);
  cells.forEach(c=>{ ctx.fillStyle=shadeColor(base,30); ctx.fillRect(c.x*BLOCK+2, c.y*BLOCK+2, BLOCK-4, BLOCK-4); });
  ctx.restore();
  // suppression du squash: ne pas modifier transform ici
  if(p>=1) boardCanvas.style.transform='';
}

function processSweeps(dt){ // advance sweeps, when done remove rows
  if(!sweeps.length) return false;
  let allDone = true;
  for(let i=sweeps.length-1;i>=0;i--){ const s=sweeps[i]; s.t += dt; const progress = Math.min(1, s.t/s.duration);
    // draw sweep overlay and flash blocks simultaneously
    const y = s.row*BLOCK; const width = boardCanvas.width*progress; ctx.fillStyle = `rgba(255,255,255,${0.18*(1-progress)})`; ctx.fillRect(0, y, width, BLOCK);
    if(progress < 1) allDone = false;
  }
  if(allDone){
    // remove all rows in one go so multiple full rows vanish together
    const rowsToRemove = sweeps.map(s=>s.row).sort((a,b)=>a-b);
    for(let k=0;k<rowsToRemove.length;k++){
      const rowIndex = rowsToRemove[k];
      grid.splice(rowIndex,1); grid.unshift(Array(COLS).fill(0));
      // Adjust following indices because splice shifts rows down
      for(let m=k+1;m<rowsToRemove.length;m++) rowsToRemove[m]++;
    }
    sweeps.length = 0;
  }
  return sweeps.length>0;
}

function lockPiece(){ if(!cur) return; const shape = cur.shape; for(let r=0;r<4;r++) for(let c=0;c<4;c++) if(shape[r][c]){ const x=cur.x+c, y=cur.y+r; if(y>=0 && y<ROWS && x>=0 && x<COLS) grid[y][x] = cur.type; }
  playSfx('lock'); const cleared = clearLinesWithSweep(); if(cleared) { triggerClearEffect(cleared, lastClearedRows); registerClear(cleared); updateScore(cleared); playSfx('clear'); cur = null; } else { registerClear(0); spawn(); } }

// Niveau interne commence à 0, on affiche +1 pour l'utilisateur
function updateScore(cleared){ 
  const pts = [0,100,300,500,800]; 
  score += (pts[cleared]||0) * (level+1); 
  lines += cleared; 
  const prevLevel = level;
  
  // Niveau monte encore plus rapidement : tous les 2 lignes au lieu de 3
  level = Math.floor(lines/2); 
  
  // Difficulté augmente moins vite (était level*70, maintenant level*25)
  dropInterval = Math.max(100, 800 - level*25); 
  
  // Changer l'atmosphère tous les 5 niveaux
  // Utiliser (level+1) pour que ça se déclenche au niveau affiché à l'utilisateur
  const atmosphereLevel = Math.floor((level+1)/5);
  const prevAtmosphereLevel = Math.floor((prevLevel+1)/5);
  if(atmosphereLevel !== prevAtmosphereLevel) {
    changeAtmosphere(atmosphereLevel);
  }
  
  // Update desktop UI
  document.getElementById('score').innerText = score; 
  document.getElementById('level').innerText = (level+1); 
  document.getElementById('lines').innerText = lines; 
  
  // Update mobile UI
  const mobileScore = document.getElementById('mobileScore');
  const mobileLevel = document.getElementById('mobileLevel');
  const mobileLines = document.getElementById('mobileLines');
  if(mobileScore) mobileScore.innerText = score;
  if(mobileLevel) mobileLevel.innerText = (level+1);
  if(mobileLines) mobileLines.innerText = lines;
  
  if(score > highscore){ 
    highscore = score; 
    localStorage.setItem('tetris_hs', highscore); 
    document.getElementById('hsValue').innerText = highscore; 
  }
}

function changeAtmosphere(atmosphereLevel) {
  const atmosphereIndex = atmosphereLevel % 10; // Cycle tous les 10 paliers d'atmosphère
  
  // Supprimer toutes les classes d'atmosphère existantes
  for(let i = 0; i < 10; i++) {
    document.body.classList.remove(`atmosphere-${i}`);
  }
  
  // Ajouter la nouvelle classe d'atmosphère
  document.body.classList.add(`atmosphere-${atmosphereIndex}`);
  
  // Changer la couleur de bordure iPhone selon l'atmosphère
  const themeColors = [
    '#071020', // atmosphère 0 : bleu foncé
    '#1a0a1a', // atmosphère 1 : magenta foncé
    '#1a0a2e', // atmosphère 2 : violet
    '#2e0a1a', // atmosphère 3 : rouge foncé
    '#2e1a0a', // atmosphère 4 : orange
    '#0a2e1a', // atmosphère 5 : vert
    '#1a2e0a', // atmosphère 6 : vert-jaune
    '#2e2e0a', // atmosphère 7 : jaune
    '#0a0a2e', // atmosphère 8 : violet foncé
    '#2e0a0a'  // atmosphère 9 : rouge vif
  ];
  
  const themeColorMeta = document.getElementById('themeColorMeta');
  if(themeColorMeta) {
    themeColorMeta.setAttribute('content', themeColors[atmosphereIndex]);
  }
  
  // Optionnel: changer aussi la couleur de bordure du canvas
  const boardCanvas = document.getElementById('board') || document.getElementById('mobileBoard');
  if(boardCanvas) {
    const atmosphereColors = [
      'rgba(255,255,255,0.12)', // atmosphère 0 : bleu foncé (niveaux 1-4)
      'rgba(199,21,133,0.15)',  // atmosphère 1 : magenta foncé (niveaux 5-9)
      'rgba(186,85,211,0.15)',   // atmosphère 2 : violet (niveaux 10-14)
      'rgba(220,20,60,0.15)',    // atmosphère 3 : rouge foncé (niveaux 15-19)
      'rgba(255,140,0,0.15)',    // atmosphère 4 : orange (niveaux 20-24)
      'rgba(50,205,50,0.15)',    // atmosphère 5 : vert (niveaux 25-29)
      'rgba(154,205,50,0.15)',   // atmosphère 6 : vert-jaune (niveaux 30-34)
      'rgba(255,255,0,0.15)',    // atmosphère 7 : jaune (niveaux 35-39)
      'rgba(138,43,226,0.15)',   // atmosphère 8 : violet foncé (niveaux 40-44)
      'rgba(255,0,0,0.15)'       // atmosphère 9 : rouge vif (niveaux 45+)
    ];
    
    // Transition smooth immédiate - plus de setTimeout
    boardCanvas.style.borderColor = atmosphereColors[atmosphereIndex];
  }
}

let hardDropEffect = null; // {t,duration,xs:[],ys:[],color}
function hardDrop(){
  if(!cur) return;
  let dist=0; while(!collides(cur,0,1)){ cur.y++; dist++; }
  playSfx('drop');
  // enregistrer positions des blocs pour effet
  const cells=[]; for(let r=0;r<4;r++) for(let c=0;c<4;c++) if(cur.shape[r][c]){ const x=cur.x+c, y=cur.y+r; if(y>=0) cells.push({x,y}); }
  const color = COLORS[cur.type];
  hardDropEffect = { t:0, duration:300, cells, color, dist };
  lockPiece();
}
function rotatePiece(){
  if(!cur) return;
  // Empêcher la rotation de la pièce O (carré) ou garder identique
  if(cur.type === 'O') return; // ne rien faire
  const nextIndex = (cur.rotIndex+1) % cur.rots.length;
  const nextShape = cur.rots[nextIndex];
  const kicks = [0,-1,1,-2,2];
  for(const k of kicks){
    if(!collides(cur,k,0,nextShape)){
      cur.rotIndex = nextIndex;
      cur.shape = nextShape;
      cur.x += k;
      playSfx('rotate');
      return;
    }
  }
}
function movePiece(dx,dy){ if(!cur) return false; if(!collides(cur,dx,dy)){ cur.x += dx; cur.y += dy; return true; } return false; }

// main loop
function loop(now=0){ if(!running) return; if(pauseOpen) { requestAnimationFrame(loop); return; }
  const dt = now - lastTime; lastTime = now; lastDrop += dt;
  const sweeping = processSweeps(dt);
  if(!sweeping){
    if(lastDrop > dropInterval){ lastDrop = 0; if(!movePiece(0,1)) lockPiece(); }
  } else {
    // during sweep animation: do not fall; when sweep ends, respawn if needed
  }
  if(!sweeps.length && !cur){ spawn(); }
  updateParticles(); updateClearEffect(dt);
  drawBoard(); drawParticles(); drawClearEffectOverlay(); drawHardDropEffect(); requestAnimationFrame(loop); }

// game over
function onGameOver(){ running = false; stopMusic(); const overlay = document.getElementById('gameOverOverlay'); overlay.style.display='flex'; const goText = document.getElementById('gameOverText');
  // restart animation
  goText.style.opacity = 0; void goText.offsetWidth; goText.style.opacity = 1;
  const replayBtn = document.getElementById('replayBtn');
  // snapshot niveau avant éventuelle modification
  const finalLevel = level;
  const finalScore = score;
  // maj stats overlay
  const st = document.getElementById('gameOverStats');
  if(st){
    const sEl = document.getElementById('goScore'); if(sEl) sEl.textContent = finalScore;
    const lEl = document.getElementById('goLevel'); if(lEl) lEl.textContent = finalLevel+1;
    const liEl = document.getElementById('goLines'); if(liEl) liEl.textContent = lines;
    requestAnimationFrame(()=>{ st.style.opacity = 1; st.style.transform='translateY(0)'; });
  }
  const menuBtn = document.getElementById('menuBtnFromGO');
  if(menuBtn){ menuBtn.onclick = ()=>{ overlay.style.display='none'; showMenu(); } }
  if(replayBtn){ replayBtn.onclick = (ev)=>{ ev.stopPropagation(); overlay.style.display='none';
      // full reset before restart to avoid any lingering state
  resetGrid(); bag=[]; nextQueue=[]; fillQueue(); cur=null; sweeps.length=0; particles.length=0; combo=0; lines=0; level=0; score=0; 
  changeAtmosphere(0); // Reset atmosphere to level 0
  
  // Update desktop UI
  document.getElementById('score').innerText = 0; 
  document.getElementById('level').innerText = 1; 
  document.getElementById('lines').innerText = 0;
  
  // Update mobile UI
  const mobileScore = document.getElementById('mobileScore');
  const mobileLevel = document.getElementById('mobileLevel');
  const mobileLines = document.getElementById('mobileLines');
  if(mobileScore) mobileScore.innerText = 0;
  if(mobileLevel) mobileLevel.innerText = 1;
  if(mobileLines) mobileLines.innerText = 0;
      startGameFromMenu();
    } }
  // tentative d’enregistrement du score
  submitScoreToLeaderboard(finalScore, finalLevel).catch(()=>{});
}

// keyboard bindings: default WASD
let bindings = JSON.parse(localStorage.getItem('tetris_bindings')||'null') || { left:'KeyA', right:'KeyD', rotate:'KeyW', down:'KeyS', hardDrop:'Space', pause:'KeyP', restart:'KeyR' };

// keyboard handler
window.addEventListener('keydown', (e)=>{ if(e.repeat && e.code !== bindings.down) return;
  // Menu visible -> seules certaines touches utiles
  if(menuScreen.style.display !== 'none'){ // on est au menu
    if(typeof waitingFor === 'string' && waitingFor){ e.preventDefault(); const code = e.code==='Space' ? 'Space' : e.code; bindings[waitingFor] = code; localStorage.setItem('tetris_bindings', JSON.stringify(bindings)); const rf = (window.refreshKeyFields||null); if(rf) rf(); waitingFor = null; return; }
    if(e.code === 'Enter' || e.code === 'Space'){
      const btn = document.getElementById('startGameBtn'); if(btn) btn.click();
    }
    return;
  }
  // Input capture for remapping
  if(typeof waitingFor === 'string' && waitingFor){ e.preventDefault(); const code = e.code==='Space' ? 'Space' : e.code; bindings[waitingFor] = code; localStorage.setItem('tetris_bindings', JSON.stringify(bindings)); const rf = (window.refreshKeyFields||null); if(rf) rf(); waitingFor = null; return; }
  // In-game
  if(pauseOpen){ 
    // Si la modal de confirmation est ouverte, la fermer d'abord
    if(quitConfirmModal.classList.contains('show')) {
      if(e.code==='KeyP' || e.code==='Escape'){ 
        hideQuitConfirmModal(); 
        hidePause(); 
      }
    } else {
      if(e.code==='KeyP' || e.code==='Escape'){ hidePause(); }
    }
    return; 
  }
  if(!running) return;
  if(e.code === bindings.left) movePiece(-1,0);
  else if(e.code === bindings.right) movePiece(1,0);
  else if(e.code === bindings.down) movePiece(0,1);
  else if(e.code === bindings.rotate) rotatePiece();
  else if(e.code === bindings.hardDrop){ e.preventDefault(); hardDrop(); }
  else if(e.code === bindings.pause){ togglePause(); }
});

// touch controls
function hookTouch(id,fn){ const el=document.getElementById(id); if(!el) return; el.addEventListener('touchstart',(ev)=>{ ev.preventDefault(); fn(); }); el.addEventListener('mousedown',(ev)=>{ ev.preventDefault(); fn(); }); }

// Fonction spéciale pour le hold (maintenir appuyé)
function hookTouchHold(id, fn, interval = 150) {
  const el = document.getElementById(id);
  if (!el) return;
  
  let holdTimer = null;
  let isHolding = false;
  
  const startHold = (ev) => {
    ev.preventDefault();
    if (isHolding) return;
    isHolding = true;
    fn(); // Premier appel immédiat
    holdTimer = setInterval(fn, interval);
  };
  
  const stopHold = (ev) => {
    if (ev) ev.preventDefault();
    isHolding = false;
    if (holdTimer) {
      clearInterval(holdTimer);
      holdTimer = null;
    }
  };
  
  el.addEventListener('touchstart', startHold);
  el.addEventListener('mousedown', startHold);
  el.addEventListener('touchend', stopHold);
  el.addEventListener('mouseup', stopHold);
  el.addEventListener('touchcancel', stopHold);
  el.addEventListener('mouseleave', stopHold);
}

// Gestionnaire des nouveaux contrôles mobiles
function setupMobileControls(){
  hookTouch('mLeft', ()=>{ if(running && !pauseOpen) movePiece(-1,0); });
  hookTouch('mRight', ()=>{ if(running && !pauseOpen) movePiece(1,0); });
  hookTouch('mRotate', ()=>{ if(running && !pauseOpen) rotatePiece(); });
  hookTouchHold('mDown', ()=>{ if(running && !pauseOpen) movePiece(0,1); }, 100); // Hold avec interval de 100ms
  hookTouch('mDrop', ()=>{ if(running && !pauseOpen) hardDrop(); });
  hookTouch('pauseBtn', ()=>{ if(running) togglePause(); });
}

// Initialiser les contrôles mobiles
document.addEventListener('DOMContentLoaded', setupMobileControls);

// UI bindings: menu <-> game
const menuScreen = document.getElementById('menuScreen');
const gameScreen = document.getElementById('gameScreen');
const pauseOverlay = document.getElementById('pauseOverlay');
const pauseContinueBtn = document.getElementById('pauseContinueBtn');
const pauseMenuBtn = document.getElementById('pauseMenuBtn');
const toggleMusicBtn = document.getElementById('toggleMusicBtn');
const toggleSfxBtn = document.getElementById('toggleSfxBtn');
const pauseAudioRow = document.getElementById('pauseAudioRow');
let pauseOpen = false;
function showPause(){
  pauseOpen = true; pauseOverlay.style.display='flex';
  // afficher boutons audio seulement mobile
  if(isMobile && pauseAudioRow){ pauseAudioRow.style.display='flex'; updateAudioToggleButtons(); }
  // pause musique sans réinitialiser
  if(audioEl && !audioEl.paused){ try{ audioEl.pause(); audioEl._wasPlaying = true; }catch(e){} }
  
  // Ajouter l'écouteur pour fermer en cliquant en dehors du contenu
  setTimeout(() => {
    pauseOverlay.addEventListener('click', closePauseOnClickOutside);
  }, 100);
}
function hidePause(){
  pauseOpen = false; pauseOverlay.style.display='none';
  if(isMobile && pauseAudioRow){ pauseAudioRow.style.display='none'; }
  // reprendre musique si elle jouait
  if(audioEl && audioEl._wasPlaying && musicOn){ try{ audioEl.play(); }catch(e){} audioEl._wasPlaying=false; }
  
  // Retirer l'écouteur de clic en dehors
  pauseOverlay.removeEventListener('click', closePauseOnClickOutside);
}

function closePauseOnClickOutside(event) {
  // Vérifier si le clic est en dehors du contenu du modal de pause
  const pauseContent = event.target.closest('div[style*="background:linear-gradient(180deg,#0a1822,#07141b)"]');
  if (!pauseContent) {
    hidePause(); // Reprendre le jeu
  }
}
function togglePause(){ if(!running) return; pauseOpen ? hidePause() : showPause(); }
if(pauseContinueBtn) pauseContinueBtn.addEventListener('click', ()=>{ hidePause(); });
if(pauseMenuBtn) pauseMenuBtn.addEventListener('click', ()=>{ showQuitConfirmModal(); });

// Modal de confirmation pour quitter
const quitConfirmModal = document.getElementById('quitConfirmModal');
const quitContinueBtn = document.getElementById('quitContinue');
const quitConfirmBtn = document.getElementById('quitConfirm');

function showQuitConfirmModal() {
  if (!running) return; // Jeu déjà arrêté

  // Si aucun point encore (score==0), pas de confirmation: retour direct menu
  if (score <= 0) {
    if (pauseOpen) hidePause(); // fermer pause si ouverte
    showMenu();
    return;
  }

  // Mettre à jour les stats dans la modal (partie avancée seulement si score>0)
  const qs = document.getElementById('quitScore'); if(qs) qs.textContent = score;
  const ql = document.getElementById('quitLevel'); if(ql) ql.textContent = level + 1;
  const qlignes = document.getElementById('quitLines'); if(qlignes) qlignes.textContent = lines;

  quitConfirmModal.classList.add('show');
}

function hideQuitConfirmModal() {
  quitConfirmModal.classList.remove('show');
}

function saveResultAndQuit() {
  // Sauvegarder le résultat actuel avant de quitter
  const finalScore = score;
  const finalLevel = level;
  
  // Soumettre le score au leaderboard (même logique que dans onGameOver)
  submitScoreToLeaderboard(finalScore, finalLevel).catch(() => {});
  
  // Cacher la modal, fermer la pause et aller au menu
  hideQuitConfirmModal();
  hidePause();
  showMenu();
}

// Event listeners pour la modal de confirmation
if(quitContinueBtn) quitContinueBtn.addEventListener('click', () => {
  hideQuitConfirmModal();
  hidePause(); // Reprendre le jeu
});

if(quitConfirmBtn) quitConfirmBtn.addEventListener('click', saveResultAndQuit);

// Fermer la modal en cliquant en dehors
quitConfirmModal.addEventListener('click', (e) => {
  if (e.target === quitConfirmModal) {
    hideQuitConfirmModal();
    hidePause(); // Reprendre le jeu
  }
});

function updateAudioToggleButtons(){
  if(toggleMusicBtn) toggleMusicBtn.textContent = 'Musique: ' + (musicOn? 'ON':'OFF');
  if(toggleSfxBtn) toggleSfxBtn.textContent = 'SFX: ' + (sfxOn? 'ON':'OFF');
  if(toggleMusicBtn) toggleMusicBtn.style.background = musicOn? 'linear-gradient(135deg,#064758,#0b6b85)':'rgba(255,255,255,0.07)';
  if(toggleSfxBtn) toggleSfxBtn.style.background = sfxOn? 'linear-gradient(135deg,#064758,#0b6b85)':'rgba(255,255,255,0.07)';
}
if(toggleMusicBtn){
  toggleMusicBtn.addEventListener('click', ()=>{
    musicOn = !musicOn;
    if(musicOn){ ensureAudio(); startMusic(); } else { stopMusic(); }
    updateAudioToggleButtons();
  });
}
if(toggleSfxBtn){
  toggleSfxBtn.addEventListener('click', ()=>{
    sfxOn = !sfxOn;
    updateAudioToggleButtons();
  });
}

// Menu pages (no tabs): show/hide pages
const menuPages = {
  home: document.getElementById('tab-home'),
  help: document.getElementById('tab-help'),
  settings: document.getElementById('tab-settings'),
  leaderboard: document.getElementById('tab-leaderboard'),
};
function showMenuPage(name){
  Object.values(menuPages).forEach(el=>el.style.display='none');
  if(menuPages[name]){
    menuPages[name].style.display = 'flex';
    if(window.refreshTitleLayouts){
      // recalcul initial
      setTimeout(()=>refreshTitleLayouts(),40);
      // recalcul après stabilisation (padding/marges)
      setTimeout(()=>refreshTitleLayouts(),180);
  // second passage après éventuel scroll bar apparition
  setTimeout(()=>refreshTitleLayouts(),400);
    }
  }
}

// Primary buttons
document.getElementById('startGameBtn').addEventListener('click', ()=>{ startGameFromMenu(); });
const duoBtn = document.getElementById('duoGameBtn');
if(duoBtn){
  duoBtn.addEventListener('click', ()=>{
    document.getElementById('duoWaitOverlay').style.display = 'flex';
    
    // Initialiser la connexion duo avec Supabase
    handleDuoConnection();
    
    // Animation points
    let dots = 0;
    const dotsEl = document.getElementById('duoWaitDots');
    if(dotsEl){
      clearInterval(window._duoDotsIntv);
      window._duoDotsIntv = setInterval(()=>{
        dots = (dots+1)%4;
        dotsEl.textContent = '.'.repeat(dots);
      }, 500);
    }
    // Animation carrousel cubes améliorée
    const colors = [
      '#FFD166', // jaune
      '#1FB6FF', // bleu
      '#2BD4A4', // vert
      '#FF6B6B', // rouge
      '#9B5DE5'  // violet
    ];
    const animWrap = document.getElementById('duoWaitAnim');
    if(animWrap){
      animWrap.innerHTML = '';
      let pos = 0;
      let cubes = [];
      const cubeSize = 20;
      const spacing = 24;
      const centerOffset = -((4-1)*spacing)/2; // Centre les 4 cubes

      for(let i=0;i<4;i++){
        const div = document.createElement('div');
        div.className = 'duoCube';
        div.style.width = cubeSize + 'px';
        div.style.height = cubeSize + 'px';
        div.style.background = colors[(pos+i)%5];
        div.style.borderRadius = '5px';
        div.style.position = 'absolute';
        div.style.left = '50%';
        div.style.top = '50%';
        div.style.transition = 'transform .65s cubic-bezier(.4,.8,.3,1), opacity .4s ease';
        div.style.opacity = '1';
        div.style.transform = `translate(-50%, -50%) translateX(${centerOffset + i*spacing}px)`;
        div.style.zIndex = 1;
        animWrap.appendChild(div);
        cubes.push(div);
      }

      let isMoving = false;
      clearInterval(window._duoCubeIntv);

      function animateCarousel(){
        if(isMoving) return;
        isMoving = true;

        // Le dernier cube (index 3) disparaît en se déplaçant vers la droite
        cubes[3].style.opacity = '0';
        cubes[3].style.transform = `translate(-50%, -50%) translateX(${centerOffset + 4*spacing}px) scale(0.7)`;

        // Déplacement fluide des cubes 0 et 2 vers la droite
        cubes[0].style.transform = `translate(-50%, -50%) translateX(${centerOffset + 1*spacing}px)`;
        cubes[2].style.transform = `translate(-50%, -50%) translateX(${centerOffset + 3*spacing}px)`;

        // Rotation simple du cube 1 de la case 2 à la case 3
        cubes[1].style.zIndex = 10;
        cubes[1].style.transition = 'transform .6s cubic-bezier(.4,.8,.3,1), opacity .4s ease';
        cubes[1].style.transform = `translate(-50%, -50%) translateX(${centerOffset + 2*spacing}px) rotate(180deg)`;

        // Pas de setTimeout nécessaire, juste la rotation fluide

        setTimeout(()=>{
          // Mise à jour des positions et couleurs (recule pour faire avancer visuellement)
          pos = (pos-1+5)%5;

          // Réorganise l'ordre des cubes (le dernier sort, nouveau arrive au début)
          const exitedCube = cubes.pop();
          cubes.unshift(exitedCube);

          // Reset toutes les transitions et positions
          for(let i=0;i<4;i++){
            cubes[i].style.transition = 'none';
            cubes[i].style.background = colors[(pos+i)%5];
            cubes[i].style.opacity = '1';
            cubes[i].style.transform = `translate(-50%, -50%) translateX(${centerOffset + i*spacing}px)`;
            cubes[i].style.zIndex = 1;
          }

          // Animation d'entrée du nouveau cube (vient de la gauche)
          cubes[0].style.opacity = '0';
          cubes[0].style.transform = `translate(-50%, -50%) translateX(${centerOffset - 1*spacing}px) scale(0.7)`;

          setTimeout(()=>{
            cubes[0].style.transition = 'transform .5s cubic-bezier(.4,.8,.3,1), opacity .4s ease';
            cubes[0].style.opacity = '1';
            cubes[0].style.transform = `translate(-50%, -50%) translateX(${centerOffset}px) scale(1)`;

            // Remettre la transition normale pour tous
            setTimeout(()=>{
              for(let i=0;i<4;i++){
                cubes[i].style.transition = 'transform .65s cubic-bezier(.4,.8,.3,1), opacity .4s ease';
              }
              isMoving = false;
            }, 100);
          }, 50);
        }, 700);
      }

      window._duoCubeIntv = setInterval(animateCarousel, 1800);
    }
    // Texte visible
    const duoWaitStatus = document.getElementById('duoWaitStatus');
    if(duoWaitStatus) duoWaitStatus.style.display = '';
    const duoWaitCount = document.getElementById('duoWaitCount');
    if(duoWaitCount) duoWaitCount.style.display = '';
  });
}

const duoBackBtn = document.getElementById('duoBackBtn');
if(duoBackBtn){
  duoBackBtn.addEventListener('click', ()=>{
    // Masque l'overlay d'attente duo
    document.getElementById('duoWaitOverlay').style.display = 'none';
    // Nettoyer la connexion Supabase
    if(window.duoConnectionId) {
      cleanupDuoConnection();
    }
  });
}

// Variables globales pour le mode duo
let duoConnectionId = null;
let duoPlayerId = null;
let duoSubscription = null;
let duoHandshakeComplete = false;

// Fonction pour nettoyer la connexion duo
async function cleanupDuoConnection() {
  if(duoSubscription) {
    await supabase.removeChannel(duoSubscription);
    duoSubscription = null;
  }
  if(duoConnectionId && duoPlayerId) {
    try {
      await supabase.from('duo_live').delete().eq('connection_id', duoConnectionId).eq('player_id', duoPlayerId);
    } catch(e) {
      console.warn('Erreur cleanup duo:', e);
    }
  }
  duoConnectionId = null;
  duoPlayerId = null;
  duoHandshakeComplete = false;
  window.duoConnectionId = null;
}

// Fonction principale pour gérer la connexion duo
async function handleDuoConnection() {
  try {
    const user = sessionStorage.getItem('currentUser') || localStorage.getItem('lastUser') || 'Benjamin';
    duoPlayerId = user;
    
    // Générer ou rejoindre une connection
    duoConnectionId = generateConnectionId();
    window.duoConnectionId = duoConnectionId;
    
    // Insérer notre présence dans duo_live
    const { error: insertError } = await supabase
      .from('duo_live')
      .insert({
        connection_id: duoConnectionId,
        player_id: duoPlayerId,
        status: 'waiting',
        last_ping: new Date().toISOString()
      });
    
    if(insertError) {
      console.error('Erreur insertion duo_live:', insertError);
      return;
    }
    
    // Vérifier combien de joueurs sont connectés
    await checkPlayerCount();
    
    // S'abonner aux changements temps réel
    duoSubscription = supabase
      .channel('duo_live_changes')
      .on('postgres_changes', 
        { event: '*', schema: 'public', table: 'duo_live', filter: `connection_id=eq.${duoConnectionId}` },
        (payload) => {
          console.log('Changement duo_live:', payload);
          handleDuoLiveChange(payload);
        }
      )
      .subscribe();
      
  } catch(e) {
    console.error('Erreur handleDuoConnection:', e);
  }
}

// Vérifier le nombre de joueurs connectés
async function checkPlayerCount() {
  try {
    const { data, error } = await supabase
      .from('duo_live')
      .select('player_id, status')
      .eq('connection_id', duoConnectionId)
      .gte('last_ping', new Date(Date.now() - 30000).toISOString()); // dernières 30 secondes
    
    if(error) {
      console.error('Erreur checkPlayerCount:', error);
      return;
    }
    
    const playerCount = data.length;
    const duoWaitCount = document.getElementById('duoWaitCount');
    
    if(playerCount === 1) {
      if(duoWaitCount) duoWaitCount.textContent = 'Joueurs connectés : 1/2';
    } else if(playerCount === 2) {
      if(duoWaitCount) duoWaitCount.textContent = 'Joueurs connectés : 2/2';
      
      // Attendre 1 seconde puis commencer le handshake
      setTimeout(() => {
        startDuoHandshake(data);
      }, 1000);
    }
    
  } catch(e) {
    console.error('Erreur checkPlayerCount:', e);
  }
}

// Commencer le handshake entre les deux joueurs
async function startDuoHandshake(players) {
  try {
    const duoWaitCount = document.getElementById('duoWaitCount');
    if(duoWaitCount) duoWaitCount.textContent = 'Connexion :P';
    
    // Envoyer signal de handshake
    const { error } = await supabase
      .from('duo_live')
      .update({ 
        status: 'handshake_sent',
        last_ping: new Date().toISOString()
      })
      .eq('connection_id', duoConnectionId)
      .eq('player_id', duoPlayerId);
    
    if(error) {
      console.error('Erreur handshake:', error);
      return;
    }
    
    // Vérifier si les deux joueurs ont envoyé le handshake
    setTimeout(() => {
      checkHandshakeComplete();
    }, 2000);
    
  } catch(e) {
    console.error('Erreur startDuoHandshake:', e);
  }
}

// Vérifier si le handshake est complet
async function checkHandshakeComplete() {
  try {
    const { data, error } = await supabase
      .from('duo_live')
      .select('player_id, status')
      .eq('connection_id', duoConnectionId)
      .eq('status', 'handshake_sent');
    
    if(error) {
      console.error('Erreur checkHandshakeComplete:', error);
      return;
    }
    
    if(data.length === 2) {
      // Les deux joueurs ont envoyé le handshake, marquer comme ready
      await supabase
        .from('duo_live')
        .update({ 
          status: 'ready',
          last_ping: new Date().toISOString()
        })
        .eq('connection_id', duoConnectionId)
        .eq('player_id', duoPlayerId);
      
      duoHandshakeComplete = true;
      
      // Lancer le jeu après 1 seconde
      setTimeout(() => {
        startDuoGame();
      }, 1000);
    }
    
  } catch(e) {
    console.error('Erreur checkHandshakeComplete:', e);
  }
}

// Lancer le jeu duo
function startDuoGame() {
  console.log('Lancement du jeu duo !');
  
  // Masquer l'overlay d'attente
  document.getElementById('duoWaitOverlay').style.display = 'none';
  
  // Démarrer le jeu Tetris
  resetGame();
  startGame();
  showGameScreen();
  
  // TODO: Ajouter la logique de synchronisation du jeu duo
}

// Gérer les changements temps réel de duo_live
function handleDuoLiveChange(payload) {
  if(payload.eventType === 'INSERT' || payload.eventType === 'UPDATE') {
    // Un joueur s'est connecté ou a changé de statut
    setTimeout(() => {
      checkPlayerCount();
    }, 500);
  } else if(payload.eventType === 'DELETE') {
    // Un joueur s'est déconnecté
    const duoWaitCount = document.getElementById('duoWaitCount');
    if(duoWaitCount && !duoHandshakeComplete) {
      duoWaitCount.textContent = 'Joueurs connectés : 1/2';
    }
  }
}

// Générer un ID de connexion unique
function generateConnectionId() {
  return 'duo_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
}

// Maintenir la connexion active (ping toutes les 10 secondes)
setInterval(async () => {
  if(duoConnectionId && duoPlayerId) {
    try {
      await supabase
        .from('duo_live')
        .update({ last_ping: new Date().toISOString() })
        .eq('connection_id', duoConnectionId)
        .eq('player_id', duoPlayerId);
    } catch(e) {
      console.warn('Erreur ping duo:', e);
    }
  }
}, 10000);
document.getElementById('backBtn').addEventListener('click', ()=>{ 
  // Si le jeu est en cours, afficher la modal de confirmation
  if(running) {
    showQuitConfirmModal();
  } else {
    showMenu();
  }
});
const helpBtn = document.getElementById('helpBtn');
const settingsBtn = document.getElementById('settingsBtn');
const helpBackBtn = document.getElementById('helpBackBtn');
const settingsBackBtn = document.getElementById('settingsBackBtn');
const leaderboardBtn = document.getElementById('leaderboardBtn');
if(helpBtn){ helpBtn.addEventListener('click', ()=>{ showMenuPage('help'); }); }
if(settingsBtn){ settingsBtn.addEventListener('click', ()=>{ showMenuPage('settings'); }); }
if(helpBackBtn){ helpBackBtn.addEventListener('click', ()=>{ showMenuPage('home'); }); }
if(settingsBackBtn){ settingsBackBtn.addEventListener('click', ()=>{ showMenuPage('home'); }); }
if(leaderboardBtn){ leaderboardBtn.addEventListener('click', ()=>{ showMenuPage('leaderboard'); fetchLeaderboard(); }); }

// Switch leaderboard solo/duo
const lbTabSolo = document.getElementById('lbTabSolo');
const lbTabDuo = document.getElementById('lbTabDuo');
const lbSoloPanel = document.getElementById('lbSoloPanel');
const lbDuoPanel = document.getElementById('lbDuoPanel');
if(lbTabSolo && lbTabDuo && lbSoloPanel && lbDuoPanel){
  lbTabSolo.addEventListener('click', ()=>{
    lbTabSolo.style.background = '#1FB6FF';
    lbTabSolo.style.color = '#fff';
    lbTabDuo.style.background = '#ff6b6b22';
    lbTabDuo.style.color = '#ff6b6b';
    lbSoloPanel.style.display = '';
    lbDuoPanel.style.display = 'none';
  });
  lbTabDuo.addEventListener('click', ()=>{
    lbTabSolo.style.background = '#1FB6FF22';
    lbTabSolo.style.color = '#1FB6FF';
    lbTabDuo.style.background = '#ff6b6b';
    lbTabDuo.style.color = '#fff';
    lbSoloPanel.style.display = 'none';
    lbDuoPanel.style.display = '';
  });
  // Par défaut solo actif
  lbTabSolo.style.background = '#1FB6FF';
  lbTabSolo.style.color = '#fff';
  lbTabDuo.style.background = '#ff6b6b22';
  lbTabDuo.style.color = '#ff6b6b';
  lbSoloPanel.style.display = '';
  lbDuoPanel.style.display = 'none';
}

// Settings: key rebinding
function codeToLabel(code){ if(code==='Space') return 'Espace'; return code.replace('Key',''); }
const keyFields = {
  left: document.getElementById('keyLeft'),
  right: document.getElementById('keyRight'),
  rotate: document.getElementById('keyRotate'),
  down: document.getElementById('keyDown'),
  hardDrop: document.getElementById('keyDrop'),
  pause: document.getElementById('keyPause'),
};
window.refreshKeyFields = function(){ if(!keyFields.left) return; keyFields.left.value = codeToLabel(bindings.left); keyFields.right.value = codeToLabel(bindings.right); keyFields.rotate.value = codeToLabel(bindings.rotate); keyFields.down.value = codeToLabel(bindings.down); keyFields.hardDrop.value = codeToLabel(bindings.hardDrop); keyFields.pause.value = codeToLabel(bindings.pause); };
window.refreshKeyFields();
let waitingFor = null;
Object.entries(keyFields).forEach(([name, input])=>{
  if(!input) return;
  input.addEventListener('click', ()=>{ waitingFor = name; input.value = '...'; input.focus(); });
});
const saveSettingsBtn = document.getElementById('saveSettingsBtn');
if(saveSettingsBtn){ saveSettingsBtn.addEventListener('click', ()=>{
  localStorage.setItem('tetris_bindings', JSON.stringify(bindings));
  saveSettingsBtn.innerText = 'Enregistré ✔';
  setTimeout(()=>{ saveSettingsBtn.innerText='Enregistrer'; }, 1200);
}); }
const resetBindingsBtn = document.getElementById('resetBindingsBtn');
if(resetBindingsBtn){ resetBindingsBtn.addEventListener('click', ()=>{
  bindings = { left:'KeyA', right:'KeyD', rotate:'KeyW', down:'KeyS', hardDrop:'Space', pause:'KeyP', restart:'KeyR' };
  localStorage.setItem('tetris_bindings', JSON.stringify(bindings));
  refreshKeyFields();
}); }

// Default menu page
showMenuPage('home');

function startGameFromMenu(){ 
  menuScreen.style.display='none'; 
  gameScreen.style.display='flex'; 
  resetGrid(); 
  bag=[]; 
  nextQueue=[]; 
  fillQueue(); 
  spawn(); 
  running = true; 
  lastTime = performance.now(); 
  lastDrop = 0; 
  ensureAudio(); 
  startMusic(); 
  pauseOpen=false; 
  // Afficher contrôles mobiles si écran tactile
  if(window.innerWidth <= 768 || 'ontouchstart' in window) {
    document.getElementById('mobileTouchControls').style.display = 'block';
  }
  requestAnimationFrame(loop);
}
function showMenu(){ // stop and return
  running = false; stopMusic(); menuScreen.style.display='flex'; gameScreen.style.display='none'; const go = document.getElementById('gameOverOverlay'); if(go) go.style.display='none';
  // Cacher les contrôles mobiles
  const mtc = document.getElementById('mobileTouchControls'); if(mtc) mtc.style.display='none';
  
  // Réinitialiser complètement le jeu
  score = 0; level = 0; lines = 0; combo = 0;
  resetGrid(); bag=[]; nextQueue=[]; fillQueue(); cur=null; sweeps.length=0; particles.length=0;
  
  // Update desktop UI
  document.getElementById('score').innerText = 0; 
  document.getElementById('level').innerText = 1; 
  document.getElementById('lines').innerText = 0;
  
  // Update mobile UI
  const mobileScore = document.getElementById('mobileScore');
  const mobileLevel = document.getElementById('mobileLevel');
  const mobileLines = document.getElementById('mobileLines');
  if(mobileScore) mobileScore.innerText = 0;
  if(mobileLevel) mobileLevel.innerText = 1;
  if(mobileLines) mobileLines.innerText = 0;
  
  // Réinitialiser l'atmosphère au menu
  changeAtmosphere(0);
}

// mute buttons
// audio boutons desktop supprimés (uniquement dans pause mobile maintenant)

// next rendering
// (ancienne fonction renderNext supprimée - remplacée par version unifiée plus haut)

// init
resetGrid(); fillQueue(); spawn(); renderNext(); changeAtmosphere(0);

// Initialize mobile/desktop specific features
initPlatformSettings();
initMobileSettings();

// small helpers to expose/change keyboard mapping if needed later
window.tetrisSetBindings = function(newBindings){ bindings = Object.assign({}, bindings, newBindings); localStorage.setItem('tetris_bindings', JSON.stringify(bindings)); };



// Animation carrousel personnalisée du titre TETRIS
// Spécifications :
// - 4 cubes défilent (tapis roulant) autour du mot
// - Pause de 2s entre chaque rotation
// - Mouvement vers la droite: chaque cube avance d'une position, le dernier réapparaît à gauche
// - Le cube "au centre" (devant le mot) se dilate et sert de fond dynamique derrière le mot
// - Quand il quitte le centre il redevient un cube normal
// Implémentation: positionnement absolu avec interpolation transform; morph en pleine largeur du mot
function initTitleAnimation(){
  const titles = document.querySelectorAll('.tetrisTitle');
  titles.forEach(title=>{
    const word = title.querySelector('.tetrisWord');
    if(!word) return;
    let cubes = Array.from(title.querySelectorAll('.t')).filter(el=>!el.classList.contains('tetrisWord'));
    if(cubes.length!==5) return; // besoin de 5
    // On force le cube violet (bT) à être centre initial
    const violet = cubes.find(c=>c.classList.contains('bT'));
    if(violet){
      cubes = cubes.filter(c=>c!==violet);
      const midIndex = Math.floor(cubes.length/2);
      cubes.splice(midIndex,0,violet); // replacer au milieu de la liste
    }
    function computeLayout(){
      const rect = word.getBoundingClientRect();
      const titleRect = title.getBoundingClientRect();
      const wordWidth = rect.width;
      const startX = rect.left - titleRect.left; // position du mot
      const centerX = titleRect.width / 2; // centre global
      // Décalage encore plus marqué demandé
      let shiftLeft = Math.min(wordWidth * 0.54, 170); // léger plus
      // Sécurité : ne pas dépasser trop loin (laisser 40px avant le début du mot)
      if(centerX - shiftLeft < startX - 40){
        shiftLeft = centerX - (startX - 40);
      }
      const centerPos = centerX - shiftLeft;
      const gap = Math.max(30, Math.min(64, wordWidth*0.13)); // légère adaptation de l'espacement
      return {wordWidth,startX,gap,centerX,centerPos};
    }
    let layout = computeLayout();
    window.addEventListener('resize', ()=>{ layout = computeLayout(); placeInstant(); });
    let logical = cubes.map((el,i)=>({el,i})); // positions -2,-1,0,+1,+2
    const PAUSE=2000; const MOVE_DUR=700;
    let animating=false, paused=true;

    function posX(pos){ // pos ∈ {-2,-1,0,1,2}
      const {startX, gap, centerPos, wordWidth} = layout;
      if(pos===0) return centerPos;
      const wordRight = startX + wordWidth;
      const base = gap * 0.9; // rapproché
      const outerFactor = 1.85; // un peu moins large
      const globalShiftLeft = gap * 0.35; // décale tout vers la gauche
      if(pos>0){
        const offset = (pos===1? base : base*outerFactor);
        let x = wordRight + offset - globalShiftLeft;
        const minSpace = 8; // garder un léger espace
        if(x < wordRight + minSpace) x = wordRight + minSpace;
        return x;
      } else {
        const p = -pos;
        const offset = (p===1? base : base*outerFactor);
        let x = startX - offset - globalShiftLeft;
        return x;
      }
    }

    function morphCenter(el,instant){
      el.classList.add('bgMorph');
      const {wordWidth,centerPos} = layout;
      // Si page aide ou settings => autoriser un peu plus de largeur
      const parentPage = title.closest('.menuPage');
      // Encore moins large et un peu plus modeste
  const widenFactor = parentPage && (parentPage.id==='tab-help' || parentPage.id==='tab-settings') ? 1.055 : 1.045;
  const targetW = Math.min(wordWidth + 10, wordWidth * widenFactor);
      const targetH = Math.min(62, Math.max(44, wordWidth * 0.19));
      el.style.zIndex=0;
      if(instant){
        el.style.width=targetW+'px';
        el.style.height=targetH+'px';
        el.style.borderRadius='10px';
        el.style.transform = `translate(${centerPos}px,-50%)`;
      } else {
        el.style.transition='transform .7s cubic-bezier(.4,.85,.25,1),width .55s,height .55s,border-radius .55s';
        requestAnimationFrame(()=>{
          el.style.width=targetW+'px';
          el.style.height=targetH+'px';
          el.style.borderRadius='10px';
          el.style.transform = `translate(${centerPos}px,-50%)`;
        });
      }
    }
    function demorph(el){
      if(!el.classList.contains('bgMorph')) return;
      // on conserve une transition fluide pour width/height/border-radius
      el.classList.remove('bgMorph');
      el.style.transition = 'transform .65s cubic-bezier(.4,.85,.25,1), width .55s, height .55s, border-radius .55s, opacity .55s';
      requestAnimationFrame(()=>{
        el.style.width='16px';
        el.style.height='16px';
        el.style.borderRadius='5px';
        el.style.zIndex=1;
      });
    }
    function placeInstant(){
      logical.forEach((obj,index)=>{
        const pos = index-2; // map index 0..4 -> -2..2
        const {el}=obj; if(pos===0) morphCenter(el,true); else demorph(el);
        el.style.transition='none';
        el.style.opacity=1;
        el.style.transform = `translate(${posX(pos)}px,-50%)`;
      });
      requestAnimationFrame(()=>logical.forEach(o=>o.el.style.transition=''));
    }
    function step(){
      if(animating) return; animating=true; paused=false;
      // cube de droite (pos +2) disparaît (shrink + fade) SANS translation re-apparente
      const outgoing = logical[logical.length-1].el;
      outgoing.style.transition='transform .45s ease,opacity .45s ease';
      // figer sa position actuelle avant shrink
      const current = outgoing.getBoundingClientRect(); // (force layout)
      requestAnimationFrame(()=>{
        outgoing.style.opacity='0';
        outgoing.style.transform += ' scale(0.1)';
      });
      setTimeout(()=>{
        const moved = logical.pop();
        logical.unshift(moved);
        // réapparaît directement à gauche (pos -2) sans translation animée (seulement scale/opacity)
        const leftPos = posX(-2);
        moved.el.style.transition='none';
        demorph(moved.el);
        moved.el.style.opacity='0';
        moved.el.style.transform = `translate(${leftPos}px,-50%) scale(0.1)`;
        // forcer reflow
        void moved.el.offsetWidth;
        moved.el.style.transition='opacity .55s ease, transform .55s cubic-bezier(.4,.85,.25,1)';
        requestAnimationFrame(()=>{
          moved.el.style.opacity='1';
          moved.el.style.transform = `translate(${leftPos}px,-50%) scale(1)`;
        });
        // autres cubes se déplacent vers leur nouvelle position
        logical.forEach((obj,index)=>{
          const pos = index-2;
          if(obj.el===moved.el) return; // déjà positionné
          if(pos===0) morphCenter(obj.el,false); else if(obj.el.classList.contains('bgMorph')) demorph(obj.el);
          obj.el.style.transition = obj.el.classList.contains('bgMorph')
            ? 'transform .7s cubic-bezier(.4,.85,.25,1), width .55s, height .55s, border-radius .55s'
            : 'transform .65s cubic-bezier(.4,.85,.25,1), width .55s, height .55s, border-radius .55s';
          requestAnimationFrame(()=>{ obj.el.style.transform = `translate(${posX(pos)}px,-50%)`; });
        });
        setTimeout(()=>{ animating=false; paused=true; schedule(); }, MOVE_DUR+90);
      }, 460);
    }
    function schedule(){ if(paused) setTimeout(step, PAUSE); }
    placeInstant(); schedule();
  });
}
initTitleAnimation();

// Relancer layout sur changement de page (aide / paramètres)
function refreshTitleLayouts(){
  document.querySelectorAll('.tetrisTitle').forEach(t=>{
    // Forcer re-init en relançant initTitleAnimation sur ce titre unique: simple approche -> supprimer attribut data-inited
    // Pour rester léger, on ne reconstruit pas tout; on peut déclencher un resize pour recalculer positions.
  });
  window.dispatchEvent(new Event('resize'));
}

</script>
<script>
// Indicateur utilisateur (session) pour Tetris paramètres
document.addEventListener('DOMContentLoaded', ()=>{
  const user = sessionStorage.getItem('currentUser') || localStorage.getItem('lastUser') || 'Benjamin';
  const ind = document.getElementById('settingsUserIndicator');
  if(ind){
    const iconSpan = document.getElementById('settingsUserIcon');
    const textSpan = document.getElementById('settingsUserText');
    let base = user.trim().toLowerCase();
    let badgeLetter = base.startsWith('ben')? 'B' : base.startsWith('san')? 'S' : user[0]?.toUpperCase()||'?';
    if(iconSpan) iconSpan.textContent = badgeLetter;
    if(textSpan){
      let label = (base.startsWith('ben'))? 'Benjamin' : (base.startsWith('san')? 'Sanaa' : user);
      textSpan.innerHTML = `Connecté en tant que <strong>${label}</strong>`;
    }
  }
});
</script>
<script type="module">
// ====== SUPABASE LEADERBOARD INTEGRATION ======
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
const SUPA_URL = 'https://ocdloxagawjkokiheuiu.supabase.co';
const SUPA_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im9jZGxveGFnYXdqa29raWhldWl1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTI1MTM1NTQsImV4cCI6MjA2ODA4OTU1NH0.OFC4QyrCKtyY_2JA2I5MnI8JjmuFBYHuJH7nO1Vyu5o';
const supabase = createClient(SUPA_URL, SUPA_ANON_KEY);

async function fetchLeaderboard(){
  const bodyEl = document.getElementById('lbBody');
  const status = document.getElementById('lbStatus');
  if(status) status.textContent = 'Chargement…';
  if(bodyEl) bodyEl.innerHTML = '<tr><td colspan="6" style="padding:12px;font-size:12px;color:#6d8089">Chargement…</td></tr>';
  const { data, error } = await supabase.from('tetris_scores').select('*').order('score',{ascending:false}).limit(20);
  if(error){ if(status) status.textContent = 'Erreur chargement'; console.error(error); return; }
  if(status) status.textContent = `Top ${data.length}`;
  if(bodyEl){
    bodyEl.innerHTML = '';
  if(!data.length){ bodyEl.innerHTML = '<tr><td colspan="6" style="padding:10px;font-size:12px;color:#6d8089">Aucun score pour le moment.</td></tr>'; return; }
    data.forEach((row,idx)=>{
      const tr = document.createElement('tr');
      // Couleurs podium ligne complète
      if(idx===0){
        tr.style.background = 'linear-gradient(90deg,rgba(255,209,102,0.22),rgba(255,209,102,0.06))';
      } else if(idx===1){
        tr.style.background = 'linear-gradient(90deg,rgba(215,222,226,0.25),rgba(215,222,226,0.07))';
      } else if(idx===2){
        tr.style.background = 'linear-gradient(90deg,rgba(205,138,50,0.25),rgba(205,138,50,0.07))';
      } else {
        tr.style.background = idx%2? 'rgba(255,255,255,0.03)': 'transparent';
      }
      const created = row.created_at? new Date(row.created_at): null;
      const dateStr = created? created.toLocaleDateString('fr-FR',{day:'2-digit',month:'2-digit'})+' '+created.toLocaleTimeString('fr-FR',{hour:'2-digit',minute:'2-digit'}): '';
      let lvl = (row.level != null ? row.level : null);
      let lineCount = (typeof row.lines === 'number') ? row.lines : null;
      if((lvl === null || lvl === 0) && lineCount && lineCount>0){ lvl = Math.floor(lineCount/10)+1; }
      if(lvl === null) lvl = Math.floor((row.score||0)/1000)+1; // fallback (approx) +1 car affichage humain
      if(lineCount === null){ // estimer approx: inverse: lignes ~ lvl*10 (grossier)
        lineCount = (lvl-1)*10;
      }
      let rankStyle = '', playerStyle = 'color:#fff;font-weight:600;', scoreStyle = 'color:#FFD166;font-weight:700;';
      if(idx===0){
        playerStyle = 'color:#FFD166;font-weight:800;text-shadow:0 0 6px rgba(255,209,102,0.35)';
        scoreStyle = 'color:#FFD166;font-weight:900;text-shadow:0 0 8px rgba(255,209,102,0.35)';
        rankStyle = 'color:#FFD166;font-weight:800;';
      } else if(idx===1){
        playerStyle = 'color:#d7dee2;font-weight:700;';
        scoreStyle = 'color:#d7dee2;font-weight:800;';
        rankStyle = 'color:#d7dee2;font-weight:700;';
      } else if(idx===2){
        playerStyle = 'color:#d2904a;font-weight:700;';
        scoreStyle = 'color:#d2904a;font-weight:800;';
        rankStyle = 'color:#d2904a;font-weight:700;';
      }
    tr.innerHTML = `
  <td style="padding:6px 8px;color:#9bb4c0;font-weight:600;${rankStyle}">${idx+1}</td>
  <td style="padding:6px 8px;${playerStyle}">${escapeHtml(row.player||'Anonyme')}</td>
  <td style="padding:6px 8px;color:#4DD2FF;font-weight:700;text-align:right">${lvl}</td>
  <td style="padding:6px 8px;color:#2BD4A4;font-weight:700;text-align:right">${lineCount}</td>
  <td style="padding:4px 6px;${scoreStyle};text-align:right;width:clamp(70px,10vw,150px);white-space:nowrap">${row.score}</td>
  <td style="padding:6px 8px;color:#9bb4c0;font-size:11px">${dateStr}</td>`;
      bodyEl.appendChild(tr);
    });
  }
}

function escapeHtml(str){ return String(str).replace(/[&<>'"]/g,s=>({"&":"&amp;","<":"&lt;",">":"&gt;","'":"&#39;","\"":"&quot;"}[s])); }

async function submitScoreToLeaderboard(score, lvl){
  try{
    if(!score || score<=0) return;
    const user = (sessionStorage.getItem('currentUser') || localStorage.getItem('lastUser') || 'Benjamin').substring(0,24);
  // fallback si lvl undefined
  if(typeof lvl !== 'number' || isNaN(lvl)) { try{ lvl = (typeof level !== 'undefined') ? level : null; }catch(_){} }
  const payload = { player:user, score:Math.floor(score) };
  if(typeof lvl === 'number' && !isNaN(lvl)) payload.level = (lvl+1); // stocker niveau humain (>=1)
  // Ajouter lignes si la colonne existe (optionnel) -> retirer si 400
  try{ if(typeof lines === 'number') payload.lines = lines; }catch(_){ }
  // ne pas inclure 'lines' (colonne absente)
  console.log('Envoi score ->', payload, 'niveau:', payload.level, 'pour user:', user);
  const { error } = await supabase.from('tetris_scores').insert(payload);
  if(error) console.warn('Score non enregistré', error.message);
  else { console.log('Score enregistré'); fetchGlobalHighscore().catch(()=>{}); fetchPersonalBest().catch(()=>{}); }
  }catch(e){ console.warn('Submit score error', e); }
}
window.fetchLeaderboard = fetchLeaderboard; // exposer
window.submitScoreToLeaderboard = submitScoreToLeaderboard;

// Récupération du meilleur score global (top 1) pour affichage dans le menu
async function fetchGlobalHighscore(){
  try{
    const { data, error } = await supabase.from('tetris_scores').select('score').order('score',{ascending:false}).limit(1);
    if(error) { console.warn('Fetch global highscore error', error.message); return; }
    if(data && data.length){
      const remote = Number(data[0].score)||0;
      if(remote > highscore){ highscore = remote; }
      const hsEl = document.getElementById('hsValue'); if(hsEl) hsEl.innerText = highscore;
    }
  }catch(e){ console.warn('Global HS fetch failed', e); }
}
window.fetchGlobalHighscore = fetchGlobalHighscore;

// Récupère meilleurs score / niveau / lignes pour l'utilisateur connecté
async function fetchPersonalBest(){
  try{
    const rawUser = sessionStorage.getItem('currentUser') || localStorage.getItem('lastUser') || 'Benjamin';
    const user = rawUser.substring(0,24);
    console.log('Recherche stats pour:', user); // Debug
    // Deux requêtes: 1) meilleur score + level associé 2) max lignes (si stocké)
    // On suppose colonne lines possible. Si absence -> ignore.
    const { data:scoreRows, error:err1 } = await supabase.from('tetris_scores').select('score,level,lines').eq('player', user).order('score',{ascending:false}).limit(1);
    if(err1){ console.warn('PB score error', err1.message); return; }
    console.log('Résultats trouvés:', scoreRows); // Debug
    let bestScore = null, bestLevel = null, bestLines = null;
    if(scoreRows && scoreRows.length){
      bestScore = Number(scoreRows[0].score)||0;
      bestLevel = Number(scoreRows[0].level)||1; // niveau déjà humain (>0)
      if(typeof scoreRows[0].lines === 'number') bestLines = scoreRows[0].lines;
      // Estimation lignes si pas fourni
      if((bestLines===null || bestLines===0) && bestLevel>1) bestLines = (bestLevel-1)*10;
      if(bestLines===null) bestLines = 0;
    }
    const hsEl = document.getElementById('hsValue'); if(hsEl) hsEl.textContent = (bestScore===null || bestScore===0)? '-' : bestScore;
    const lvlEl = document.getElementById('hsLevel'); if(lvlEl) lvlEl.textContent = (bestLevel===null || bestScore===0)? '-' : bestLevel;
    const liEl = document.getElementById('hsLines'); if(liEl) liEl.textContent = (bestLines===null || bestScore===0)? '-' : bestLines;
  }catch(e){ console.warn('Personal best fetch failed', e); }
}
window.fetchPersonalBest = fetchPersonalBest;

// Fonctions d'authentification
function isAuthenticated() {
    const authStatus = sessionStorage.getItem('isAuthenticated');
    const authTime = sessionStorage.getItem('authTime');

    if (!authStatus || authStatus !== 'true') {
        return false;
    }

    // Vérifier que l'authentification n'est pas trop ancienne (5 minutes)
    if (authTime) {
        const currentTime = new Date().getTime();
        const timeDiff = currentTime - parseInt(authTime);
        const minutesDiff = timeDiff / (1000 * 60);

        if (minutesDiff > 5) {
            sessionStorage.removeItem('isAuthenticated');
            sessionStorage.removeItem('authTime');
            return false;
        }
    }

    return true;
}

function redirectToLogin() {
    window.location.href = 'index.html';
}

document.addEventListener('DOMContentLoaded', ()=>{
  // Vérifier l'authentification au chargement de la page
  if (!isAuthenticated()) {
    redirectToLogin();
    return;
  }
  
  const lbRefresh = document.getElementById('lbRefreshBtn');
  if(lbRefresh) lbRefresh.addEventListener('click', ()=>fetchLeaderboard());
  const lbBack = document.getElementById('leaderboardBackBtn');
  if(lbBack) lbBack.addEventListener('click', ()=>showMenuPage('home'));
  // lancer récupération du highscore global dès le chargement
  fetchGlobalHighscore();
  fetchPersonalBest();
  
  // Initialisation du jeu seulement si authentifié
  resizeBoard(); 
  drawBoard(); 
  renderNext(); 
  changeAtmosphere(0);
});
</script>

</body>
</html>
