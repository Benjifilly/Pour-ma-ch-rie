<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no, maximum-scale=1" />
  <meta name="theme-color" content="#071020" id="themeColorMeta">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="msapplication-navbutton-color" content="#000000">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="format-detection" content="telephone=no">
  <title>Tetris — jeu</title>
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Crect width='64' height='64' rx='12' fill='%23071320'/%3E%3Crect x='10' y='10' width='14' height='14' rx='3' fill='%231FB6FF'/%3E%3Crect x='26' y='10' width='14' height='14' rx='3' fill='%23FFD166'/%3E%3Crect x='42' y='10' width='14' height='14' rx='3' fill='%232BD4A4'/%3E%3Crect x='10' y='26' width='14' height='14' rx='3' fill='%23FF6B6B'/%3E%3Crect x='26' y='26' width='14' height='14' rx='3' fill='%239B5DE5'/%3E%3C/svg%3E" />
  <style>
    :root{ --bg:#071021; --card:#0c1720; --accent:#ffd166; --muted:#98a8b9; color-scheme: dark }
    html,body{height:100%;margin:0;overflow:hidden;font-family:Inter, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;background:linear-gradient(180deg,#071020 0%, #071827 70%);color:#e6eef6;transition:background 2s ease-in-out;user-select:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none}
    
    /* Protection contre zoom et sélection sur iOS */
    *{-webkit-user-select:none;-webkit-touch-callout:none;-webkit-tap-highlight-color:transparent;user-select:none}
    input,textarea{-webkit-user-select:auto;user-select:auto}
    
    /* Empêcher le zoom sur double-tap */
    canvas,button,div{touch-action:manipulation}
    
    /* Prévenir le zoom sur iOS */
    @supports (-webkit-touch-callout: none) {
      html{-webkit-text-size-adjust:100%}
      body{-webkit-text-size-adjust:100%;touch-action:manipulation}
      *{-webkit-touch-callout:none;-webkit-user-select:none;user-select:none}
    }
    
    /* Atmosphères par niveau */
    body.atmosphere-0 { background:linear-gradient(180deg,#071020 0%, #071827 70%) !important; }
    body.atmosphere-1 { background:linear-gradient(180deg,#1a0a1a 0%, #2d1b2d 70%) !important; }
    body.atmosphere-2 { background:linear-gradient(180deg,#1a0a2e 0%, #2d1b4e 70%) !important; }
    body.atmosphere-3 { background:linear-gradient(180deg,#2e0a1a 0%, #4e1b2d 70%) !important; }
    body.atmosphere-4 { background:linear-gradient(180deg,#2e1a0a 0%, #4e2d1b 70%) !important; }
    body.atmosphere-5 { background:linear-gradient(180deg,#0a2e1a 0%, #1b4e2d 70%) !important; }
    body.atmosphere-6 { background:linear-gradient(180deg,#1a2e0a 0%, #2d4e1b 70%) !important; }
    body.atmosphere-7 { background:linear-gradient(180deg,#2e2e0a 0%, #4e4e1b 70%) !important; }
    body.atmosphere-8 { background:linear-gradient(180deg,#0a0a2e 0%, #1b1b4e 70%) !important; }
    body.atmosphere-9 { background:linear-gradient(180deg,#2e0a0a 0%, #4e1b1b 70%) !important; }
    
    .gameScreen { transition:background-color 2s ease-in-out; }
    .board-wrap .card canvas { transition:border-color 2s ease-in-out; }
    #mobileBoard { transition:border-color 2s ease-in-out; }
    #board { transition:border-color 2s ease-in-out; }
    .center{display:flex;align-items:center;justify-content:center;height:100vh}

    /* Menu (page complète) */
    #menuScreen{display:flex;align-items:center;justify-content:center;height:100vh;width:100vw;position:relative}
    .menuCard{width:100%;max-width:500px;padding:0;border-radius:0;background:transparent;border:none;box-shadow:none;display:flex;justify-content:center}
    .menuGrid{display:flex;flex-direction:column;align-items:center;justify-content:center;width:100%}
    .menuLeft{width:100%;display:flex;flex-direction:column;align-items:center}
    .menuRight{flex:1}
  .tetrisTitle{display:inline-block;position:relative;padding:10px 0 18px 0;margin:0 0 3vh 0;}
  .tetrisTitle .t{position:absolute;top:50%;left:0;width:16px;height:16px;transform:translate(-50%,-50%);border-radius:5px;display:block;transition:transform .65s cubic-bezier(.4,.8,.3,1),width .55s,height .55s,opacity .4s,border-radius .55s;will-change:transform}
  .tetrisTitle .bI{background:#1FB6FF}.tetrisTitle .bO{background:#FFD166}.tetrisTitle .bS{background:#2BD4A4}.tetrisTitle .bZ{background:#FF6B6B}.tetrisTitle .bT{background:#9B5DE5}
  .tetrisWord{font-weight:900;letter-spacing:3px;font-size:clamp(28px,5vw,40px);text-shadow:0 4px 16px rgba(0,0,0,.5);color:#fff;position:relative;z-index:2;padding:0 4px;border-radius:0;}
  .tetrisTitle .t.bgMorph{z-index:0;border-radius:10px;}
  .tetrisTitle .t.wrapOut{transition:transform .5s ease,opacity .45s ease}
  .tetrisTitle .t.wrapIn{transition:transform .6s ease,opacity .6s ease}
  /* Réduction si petit écran */
  @media (max-width:520px){ .tetrisTitle .t{width:14px;height:14px} }
  /* Centrage & léger décalage pour titres Aide / Paramètres */
  /* Ancienne règle titres secondaires retirée (titres remplacés par badges colorés) */
    p.lead{color:#bcd6df;margin-top:0}
    .menuActions{display:flex;gap:10px;margin-top:0;flex-direction:column;width:100%}
    .menuActions.horiz{flex-direction:row}
    .btn{width:100%;text-align:center}
    button.btn{background:linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.04));padding:10px 14px;border-radius:10px;border:1px solid rgba(255,255,255,0.08);color:#e6eef6;cursor:pointer;font-weight:800;letter-spacing:.4px;box-shadow:0 8px 20px rgba(0,0,0,0.35);font-size:14px}
    button.btn.btn-lg{background:linear-gradient(180deg, rgba(255,255,255,0.12), rgba(255,255,255,0.06));padding:clamp(12px, 2vh, 16px) 20px;border-radius:12px;border:1px solid rgba(255,255,255,0.12);color:#e6eef6;cursor:pointer;font-weight:900;letter-spacing:.5px;box-shadow:0 8px 20px rgba(0,0,0,0.35);font-size:clamp(14px, 2.5vw, 16px)}
    button.btn:hover{transform:translateY(-1px) scale(1.01);filter:brightness(1.06)}
    button.btn:active{transform:translateY(0) scale(0.995)}
    @media (max-width: 520px){ .tetrisTitle{margin-bottom:2vh} .menuActions{gap:8px} }
    @media (max-height: 600px){ 
      .tetrisTitle{margin-bottom:1vh} 
      .tetrisWord{font-size:clamp(18px, 3vw, 22px)} 
      button.btn.btn-lg{padding:10px 18px;font-size:clamp(13px, 2vw, 15px)}
    }

    /* onglets/sections du menu */
    .menuTabs{display:flex;gap:8px;margin:12px 0}
    /* onglets retirés (on utilise pages dédiées avec retour) */
  .menuPage{display:none}
  .menuPage.active{display:flex !important}
  /* Checkbox animée */
  .cbx_box{display:inline-flex;align-items:center;justify-content:center;width:26px;height:26px}
  .cbx_svg{overflow:visible}
  .cbx_bg{fill:rgba(255,255,255,0.06);stroke:rgba(255,255,255,0.18);stroke-width:1}
  .cbx_tick{stroke:#2BD4A4;stroke-dasharray:26;stroke-dashoffset:26;transition:stroke-dashoffset .28s ease .05s}
  .cbx{ -webkit-tap-highlight-color: transparent; }
  .cbx:hover .cbx_bg{fill:rgba(255,255,255,0.09)}
  /* Montrer l'outline seulement pour la navigation clavier, pas au clic */
  #toggleTouchControls:focus-visible + .cbx_box .cbx_bg{outline:2px solid #4DD2FF; outline-offset:3px}
  /* état coché: tracer la coche et mettre un fond accentué */
  #toggleTouchControls:checked + .cbx_box .cbx_bg{fill:rgba(43,212,164,0.18);stroke:rgba(43,212,164,0.6)}
  #toggleTouchControls:checked + .cbx_box .cbx_tick{stroke-dashoffset:0}
  /* dé-check: animer le retour */
  #toggleTouchControls:not(:checked) + .cbx_box .cbx_tick{transition:stroke-dashoffset .22s ease}

    /* Game screen */
    #gameScreen{display:flex;flex-direction:column;align-items:center;gap:clamp(8px,2vh,12px);padding:clamp(8px,2vw,18px);min-height:100vh;box-sizing:border-box}
    .container{width:100%;max-width:980px}
    .board-wrap{display:flex;gap:18px;align-items:flex-start;justify-content:center}
    .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:14px;box-shadow:0 8px 30px rgba(0,0,0,0.5);display:flex;gap:12px}
    canvas#board{background:#04131a;border-radius:10px;display:block}
    .side{width:280px;display:flex;flex-direction:column;gap:12px}
    .panel{background:rgba(255,255,255,0.03);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03)}
/* CSS pour elements supprimés */
    .nextList{display:flex;flex-direction:column;gap:10px;align-items:center}

    /* overlays & gameover */
    .overlayFull{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:90}
    .gameOverWrap{pointer-events:none}
    .gameOverText{font-size:66px;font-weight:900;letter-spacing:3px;color:#ff3b3b;text-shadow:0 2px 0 #7a0b0b, 0 4px 0 #6a0a0a, 0 6px 12px rgba(255,0,0,0.35);transform:translateY(-8px) scale(0.85);opacity:0;animation:goBoom 1.2s cubic-bezier(.2,1,.3,1) forwards, flicker 1.8s linear 1.2s infinite}
    @keyframes goBoom{0%{opacity:0;transform:translateY(-16px) scale(0.6) rotate(-8deg)}35%{opacity:1;transform:translateY(4px) scale(1.08) rotate(3deg)}60%{transform:translateY(-2px) scale(0.96) rotate(-2deg)}85%{transform:translateY(0) scale(1.02) rotate(1deg)}100%{opacity:1;transform:translateY(0) scale(1) rotate(0)}}
    @keyframes flicker{0%,19%,21%,23%,100%{filter:brightness(1)}20%,22%{filter:brightness(1.3)}}

    /* combo badge */
    .comboBadge{position:fixed;right:40px;top:40px;background:linear-gradient(180deg,#ffb86b,#ff8a4c);color:#111;padding:10px 14px;border-radius:12px;font-weight:700;box-shadow:0 8px 20px rgba(255,138,76,0.12);opacity:0;transform:translateY(-10px);transition:all .25s;z-index:5000}
    .comboBadge.show{opacity:1;transform:translateY(0)}

    @media(max-width:820px){ 
      .menuCard{padding:18px} 
      .board-wrap{flex-direction:column;align-items:center} 
      .side{width:100%} 
      #gameScreen{gap:clamp(4px,1vh,8px);padding:clamp(4px,1vw,12px)} 
      .desktop-layout{display:none !important}
      .mobile-layout{display:block !important}
    }
    
    /* Media query spécifique iPhone pour le leaderboard */
    @media screen and (max-width: 480px) and (-webkit-min-device-pixel-ratio: 2) {
      #tab-leaderboard .panel {
        max-height: clamp(35vh, 45vh, 55vh) !important;
      }
      #tab-leaderboard {
        min-height: 60vh !important;
      }
  /* Remonter page aide sur iPhone */
  #tab-help { padding: clamp(8px,2vh,28px) clamp(6px,3vw,32px) clamp(12px,3vh,32px) clamp(6px,3vw,32px) !important; min-height:65vh !important; }
  #tab-help .panel { max-height: clamp(48vh,60vh,68vh) !important; }

      /* Modal quitter moins large sur mobile */
      .quitConfirmContent {
        max-width: 320px !important;
        width: 92vw !important;
        padding-left: clamp(10px,2vw,18px) !important;
        padding-right: clamp(10px,2vw,18px) !important;
      }
    }
    
    /* Media query pour très petits écrans (iPhone SE, etc.) */
    @media screen and (max-height: 700px) and (max-width: 400px) {
      #tab-leaderboard .panel {
        max-height: clamp(30vh, 40vh, 50vh) !important;
      }
      #tab-leaderboard {
        min-height: 55vh !important;
        padding: clamp(10px, 2vh, 30px) clamp(8px, 2vw, 20px) !important;
      }
  /* Petits écrans supplémentaires: aide encore plus haute */
  #tab-help { padding: clamp(6px,1.5vh,20px) clamp(6px,4vw,28px) clamp(10px,2.5vh,26px) clamp(6px,4vw,28px) !important; }
  #tab-help .panel { max-height: clamp(50vh,62vh,70vh) !important; }
    }
    
    /* Custom scrollbar pour la page d'aide */
    .panel::-webkit-scrollbar { width: 8px; }
    .panel::-webkit-scrollbar-track { background: rgba(255,255,255,0.05); border-radius: 4px; }
    .panel::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 4px; }
    .panel::-webkit-scrollbar-thumb:hover { background: rgba(255,255,255,0.3); }
    
    /* Animation de pièces qui tombent en arrière-plan */
    .fallingPieces{position:fixed;top:0;left:0;width:100vw;height:100vh;pointer-events:none;z-index:-1;overflow:hidden}
    .fallingPiece{position:absolute;opacity:0.15;transform:rotate(0deg);animation:fall linear infinite}
    @keyframes fall{0%{transform:translateY(-100px) rotate(0deg);opacity:0.15}10%{opacity:0.15}90%{opacity:0.05}100%{transform:translateY(100vh) rotate(360deg);opacity:0}}
    .tetromino{display:grid;gap:2px}
    .tetromino.I{grid-template-columns:repeat(4,8px);grid-template-rows:8px}
    .tetromino.O{grid-template-columns:repeat(2,8px);grid-template-rows:repeat(2,8px)}
    .tetromino.T,.tetromino.S,.tetromino.Z,.tetromino.J,.tetromino.L{grid-template-columns:repeat(3,8px);grid-template-rows:repeat(2,8px)}
    .block{width:8px;height:8px;border-radius:2px}
    
    /* Modal de confirmation pour quitter */
    .quitConfirmModal{position:fixed;inset:0;background:rgba(0,0,0,0.7);backdrop-filter:blur(8px);display:flex;align-items:center;justify-content:center;z-index:5000;opacity:0;visibility:hidden;transition:all 0.3s ease}
    .quitConfirmModal.show{opacity:1;visibility:visible}
    .quitConfirmContent{background:linear-gradient(180deg,#0a1822,#07141b);border:1px solid rgba(255,255,255,0.1);border-radius:16px;padding:clamp(20px,4vh,32px);max-width:400px;width:90vw;text-align:center;transform:scale(0.9);transition:transform 0.3s ease}
    .quitConfirmModal.show .quitConfirmContent{transform:scale(1)}
    .quitConfirmTitle{font-size:clamp(18px,4vw,24px);font-weight:700;color:#e4f3fa;margin-bottom:clamp(12px,2vh,16px)}
    .quitConfirmStats{background:rgba(255,255,255,0.05);border-radius:8px;padding:clamp(12px,2vh,16px);margin:clamp(12px,2vh,16px) 0;font-size:clamp(13px,3vw,15px);color:#b8d4e3}
    .quitConfirmStats div{margin:4px 0}
    .quitConfirmActions{display:flex;gap:12px;justify-content:center;margin-top:clamp(16px,3vh,24px)}
    .quitConfirmBtn{padding:clamp(10px,2vh,12px) clamp(16px,4vw,20px);border:none;border-radius:8px;font-size:clamp(13px,3vw,15px);font-weight:600;cursor:pointer;transition:all 0.2s ease}
    .quitConfirmBtn.continue{background:linear-gradient(135deg,#064758,#0b6b85);color:#e4f3fa}
    .quitConfirmBtn.continue:hover{background:linear-gradient(135deg,#075a6d,#0e7ea0);transform:translateY(-1px)}
    .quitConfirmBtn.quit{background:rgba(255,59,59,0.2);color:#ff6b6b;border:1px solid rgba(255,59,59,0.3)}
    .quitConfirmBtn.quit:hover{background:rgba(255,59,59,0.3);transform:translateY(-1px)}
  </style>
</head>
<body>
  <!-- Pièces qui tombent en arrière-plan -->
  <div class="fallingPieces" id="fallingPieces"></div>

  <!-- MENU PAGE (séparé) -->
  <div id="menuScreen">
    <div class="menuCard">
      <div class="menuGrid">
        <div class="menuLeft">
          <!-- Page Accueil -->
          <div class="menuPage active" id="tab-home" style="display:flex;flex-direction:column;align-items:center;justify-content:center;height:100vh;gap:2vh;padding:2vh 20px">
            
            <!-- Titre Tetris -->
            <div class="tetrisTitle" aria-label="TETRIS" title="TETRIS">
              <span class="t bI"></span><span class="t bO"></span><span class="t bT"></span><span class="t bS"></span><span class="t bZ"></span>
              <span class="tetrisWord">TETRIS</span>
            </div>
            
            <!-- Statistiques (cartes séparées) -->
            <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(110px,1fr));gap:14px;width:100%;max-width:500px;padding:4px 4px 0 4px">
              <div style="background:linear-gradient(180deg,rgba(31,182,255,0.18),rgba(31,182,255,0.05));border:1px solid rgba(31,182,255,0.35);border-radius:12px;padding:14px 12px;text-align:center;box-shadow:0 4px 18px -4px rgba(31,182,255,0.3)">
                <div style="font-size:22px;font-weight:900;color:#1FB6FF;letter-spacing:.5px" id="hsValue">-</div>
                <div style="font-size:11px;color:#bcd6df;font-weight:600;margin-top:4px;letter-spacing:.5px">SCORE MAX</div>
              </div>
              <div style="background:linear-gradient(180deg,rgba(255,209,102,0.22),rgba(255,209,102,0.05));border:1px solid rgba(255,209,102,0.4);border-radius:12px;padding:14px 12px;text-align:center;box-shadow:0 4px 18px -4px rgba(255,209,102,0.35)">
                <div style="font-size:22px;font-weight:900;color:#FFD166;letter-spacing:.5px" id="hsLevel">-</div>
                <div style="font-size:11px;color:#bcd6df;font-weight:600;margin-top:4px;letter-spacing:.5px">NIVEAU MAX</div>
              </div>
              <div style="background:linear-gradient(180deg,rgba(43,212,164,0.20),rgba(43,212,164,0.05));border:1px solid rgba(43,212,164,0.45);border-radius:12px;padding:14px 12px;text-align:center;box-shadow:0 4px 18px -4px rgba(43,212,164,0.35)">
                <div style="font-size:22px;font-weight:900;color:#2BD4A4;letter-spacing:.5px" id="hsLines">-</div>
                <div style="font-size:11px;color:#bcd6df;font-weight:600;margin-top:4px;letter-spacing:.5px">LIGNES MAX</div>
              </div>
            </div>

            <!-- Boutons du menu -->
            <div class="menuActions" style="align-items:stretch;gap:12px;width:100%;max-width:380px;display:flex;flex-wrap:wrap">
              <div style="display:flex;gap:10px;width:100%">
                <button class="btn btn-lg" id="startGameBtn" style="background:linear-gradient(135deg,rgba(31,182,255,0.15),rgba(31,182,255,0.05));border:1px solid rgba(31,182,255,0.3);color:#1FB6FF;font-weight:900;position:relative;overflow:hidden;padding:14px 20px;flex:1">
                  <span style="position:relative;z-index:1">Solo</span>
                </button>
                <button class="btn btn-lg" id="duoGameBtn" style="background:linear-gradient(135deg,rgba(255,59,59,0.15),rgba(255,59,59,0.05));border:1px solid rgba(255,59,59,0.3);color:#ff6b6b;font-weight:900;position:relative;overflow:hidden;padding:14px 20px;flex:1">
                  <span style="position:relative;z-index:1">Duo</span>
                </button>
              </div>

              <!-- Overlay attente Duo -->
              <div id="duoWaitOverlay" style="display:none;position:fixed;z-index:9999;inset:0;background:rgba(7,16,32,0.98);backdrop-filter:blur(2px);align-items:center;justify-content:center;">
                <div class="menuPage" id="tab-duo-wait" style="display:flex !important;flex-direction:column;align-items:center;justify-content:center;gap:clamp(2vh,4vh,6vh);padding:clamp(20px,4vh,60px) clamp(8px,3vw,40px);height:100vh;text-align:center;width:100vw;max-width:none;box-sizing:border-box">
                <div style="display:flex;flex-direction:column;align-items:center;justify-content:center;gap:clamp(2vh,4vh,6vh);width:100vw;height:100vh;">
                  <div id="duoWaitStatus" style="font-size:clamp(18px,3vw,26px);color:#FFD166;font-weight:800;margin-bottom:18px;">En attente de l'autre joueur<span id='duoWaitDots' style='display:inline-block;width:24px'></span></div>
                  <div id="duoWaitAnimWrap" style="display:flex;justify-content:center;align-items:center;width:100px;height:40px;position:relative;overflow:visible;margin:0 auto;">
                    <div id="duoWaitAnim" style="display:flex;gap:0;justify-content:center;align-items:center;height:38px;position:relative;width:100px;">
                      <!-- Les cubes animés seront gérés par JS -->
                    </div>
                  </div>
                  <div id="duoWaitCount" style="font-size:clamp(15px,2vw,20px);color:#fff;font-weight:700;margin-top:18px">Joueurs connectés : 1/2</div>
                </div>
                <button class="btn" id="duoBackBtn" style="margin-top:8px;max-width:180px;position:relative;top:-12px">Retour</button>
                </div>
              </div>
              <button class="btn btn-lg" id="helpBtn" style="padding:12px 20px">Aide</button>
              <button class="btn btn-lg" id="leaderboardBtn" style="padding:12px 20px">Leaderboard</button>
              <button class="btn btn-lg" id="settingsBtn" style="padding:12px 20px">Paramètres</button>
            </div>


          </div>

          <!-- Page Aide -->
          <div class="menuPage" id="tab-help" style="display:none;flex-direction:column;align-items:center;justify-content:flex-start;gap:clamp(1vh,2vh,3vh);padding:clamp(20px,4vh,60px) clamp(8px,3vw,40px) clamp(16px,3vh,40px) clamp(8px,3vw,40px);height:auto;min-height:78vh;text-align:center">
            <div style="background:#9B5DE5;padding:clamp(8px,1.5vh,18px) clamp(12px,3vw,24px);border-radius:clamp(8px,2vw,14px);font-size:clamp(16px,3vw,22px);font-weight:900;letter-spacing:.8px;color:#fff;align-self:center;min-width:clamp(180px,40vw,260px);text-align:center">AIDE</div>
            
            <div class="panel" style="background:linear-gradient(180deg,rgba(255,255,255,0.04),rgba(255,255,255,0.02));max-width:clamp(300px,90vw,900px);width:100%;border:1px solid rgba(255,255,255,0.08);max-height:clamp(40vh,60vh,70vh);overflow-y:auto;scrollbar-width:thin;scrollbar-color:rgba(255,255,255,0.3) transparent">

              <!-- Section des pièces Tetris avec visuels -->
              <div style="margin-bottom:20px">
                <div style="font-size:16px;font-weight:800;color:#fff;margin-bottom:12px;text-align:center">Les Tetrominoes</div>
                <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:8px;margin-bottom:16px">
                  <div style="background:rgba(31,182,255,0.15);border:1px solid #1FB6FF;padding:8px;border-radius:8px;text-align:center">
                    <div style="display:grid;grid-template-columns:repeat(4,8px);gap:1px;justify-content:center;margin-bottom:4px">
                      <div style="background:#1FB6FF;height:8px;border-radius:2px"></div>
                      <div style="background:#1FB6FF;height:8px;border-radius:2px"></div>
                      <div style="background:#1FB6FF;height:8px;border-radius:2px"></div>
                      <div style="background:#1FB6FF;height:8px;border-radius:2px"></div>
                    </div>
                    <div style="color:#1FB6FF;font-weight:700;font-size:12px">I - Barre</div>
                  </div>
                  <div style="background:rgba(255,209,102,0.15);border:1px solid #FFD166;padding:8px;border-radius:8px;text-align:center">
                    <div style="display:grid;grid-template-columns:repeat(4,8px);gap:1px;justify-content:center;margin-bottom:4px">
                      <div></div><div style="background:#FFD166;height:8px;border-radius:2px"></div><div style="background:#FFD166;height:8px;border-radius:2px"></div><div></div>
                      <div></div><div style="background:#FFD166;height:8px;border-radius:2px"></div><div style="background:#FFD166;height:8px;border-radius:2px"></div><div></div>
                    </div>
                    <div style="color:#FFD166;font-weight:700;font-size:12px">O - Carré</div>
                  </div>
                  <div style="background:rgba(155,93,229,0.15);border:1px solid #9B5DE5;padding:8px;border-radius:8px;text-align:center">
                    <div style="display:grid;grid-template-columns:repeat(4,8px);gap:1px;justify-content:center;margin-bottom:4px">
                      <div></div><div style="background:#9B5DE5;height:8px;border-radius:2px"></div><div></div><div></div>
                      <div style="background:#9B5DE5;height:8px;border-radius:2px"></div><div style="background:#9B5DE5;height:8px;border-radius:2px"></div><div style="background:#9B5DE5;height:8px;border-radius:2px"></div><div></div>
                    </div>
                    <div style="color:#9B5DE5;font-weight:700;font-size:12px">T - Té</div>
                  </div>
                  <div style="background:rgba(43,212,164,0.15);border:1px solid #2BD4A4;padding:8px;border-radius:8px;text-align:center">
                    <div style="display:grid;grid-template-columns:repeat(4,8px);gap:1px;justify-content:center;margin-bottom:4px">
                      <div></div><div style="background:#2BD4A4;height:8px;border-radius:2px"></div><div style="background:#2BD4A4;height:8px;border-radius:2px"></div><div></div>
                      <div style="background:#2BD4A4;height:8px;border-radius:2px"></div><div style="background:#2BD4A4;height:8px;border-radius:2px"></div><div></div><div></div>
                    </div>
                    <div style="color:#2BD4A4;font-weight:700;font-size:12px">S - Snake</div>
                  </div>
                </div>
                <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px">
                  <div style="background:rgba(255,107,107,0.15);border:1px solid #FF6B6B;padding:8px;border-radius:8px;text-align:center">
                    <div style="display:grid;grid-template-columns:repeat(4,8px);gap:1px;justify-content:center;margin-bottom:4px">
                      <div style="background:#FF6B6B;height:8px;border-radius:2px"></div><div style="background:#FF6B6B;height:8px;border-radius:2px"></div><div></div><div></div>
                      <div></div><div style="background:#FF6B6B;height:8px;border-radius:2px"></div><div style="background:#FF6B6B;height:8px;border-radius:2px"></div><div></div>
                    </div>
                    <div style="color:#FF6B6B;font-weight:700;font-size:12px">Z - Zigzag</div>
                  </div>
                  <div style="background:rgba(58,108,253,0.15);border:1px solid #3A6CFD;padding:8px;border-radius:8px;text-align:center">
                    <div style="display:grid;grid-template-columns:repeat(4,8px);gap:1px;justify-content:center;margin-bottom:4px">
                      <div style="background:#3A6CFD;height:8px;border-radius:2px"></div><div></div><div></div><div></div>
                      <div style="background:#3A6CFD;height:8px;border-radius:2px"></div><div style="background:#3A6CFD;height:8px;border-radius:2px"></div><div style="background:#3A6CFD;height:8px;border-radius:2px"></div><div></div>
                    </div>
                    <div style="color:#3A6CFD;font-weight:700;font-size:12px">J - Jambe</div>
                  </div>
                  <div style="background:rgba(255,159,28,0.15);border:1px solid #FF9F1C;padding:8px;border-radius:8px;text-align:center">
                    <div style="display:grid;grid-template-columns:repeat(4,8px);gap:1px;justify-content:center;margin-bottom:4px">
                      <div></div><div></div><div style="background:#FF9F1C;height:8px;border-radius:2px"></div><div></div>
                      <div style="background:#FF9F1C;height:8px;border-radius:2px"></div><div style="background:#FF9F1C;height:8px;border-radius:2px"></div><div style="background:#FF9F1C;height:8px;border-radius:2px"></div><div></div>
                    </div>
                    <div style="color:#FF9F1C;font-weight:700;font-size:12px">L - Équerre</div>
                  </div>
                </div>
              </div>

              <!-- Commandes détaillées -->
              <div style="margin-bottom:20px">
                <div style="font-size:16px;font-weight:800;color:#fff;margin-bottom:12px;text-align:center">Contrôles</div>
                <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:10px">
                  <div style="background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1);padding:10px;border-radius:8px;text-align:center">
                    <div style="height:26px;margin-bottom:4px;display:flex;justify-content:center;gap:6px;align-items:center">
                      <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="#1FB6FF" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                      <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="#1FB6FF" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 6l6 6-6 6"/></svg>
                    </div>
                    <div style="font-weight:700;color:#1FB6FF;font-size:14px">A / D</div>
                    <div style="font-size:11px;color:#bcd6df">Déplacer gauche/droite</div>
                  </div>
                  <div style="background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1);padding:10px;border-radius:8px;text-align:center">
                    <div style="height:26px;margin-bottom:4px;display:flex;justify-content:center;align-items:center">
                      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#9B5DE5" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 2v6h-6"/><path d="M3 12a9 9 0 0 1 15-6"/><path d="M3 22v-6h6"/><path d="M21 12a9 9 0 0 1-15 6"/></svg>
                    </div>
                    <div style="font-weight:700;color:#9B5DE5;font-size:14px">W</div>
                    <div style="font-size:11px;color:#bcd6df">Rotation horaire</div>
                  </div>
                  <div style="background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1);padding:10px;border-radius:8px;text-align:center">
                    <div style="height:26px;margin-bottom:4px;display:flex;justify-content:center;align-items:center">
                      <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="#FFD166" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5v14"/><path d="M5 12l7 7 7-7"/></svg>
                    </div>
                    <div style="font-weight:700;color:#FFD166;font-size:14px">S</div>
                    <div style="font-size:11px;color:#bcd6df">Descente lente</div>
                  </div>
                  <div style="background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1);padding:10px;border-radius:8px;text-align:center">
                    <div style="height:26px;margin-bottom:4px;display:flex;justify-content:center;align-items:center">
                      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#2BD4A4" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13 2L3 14h7l-1 8 10-12h-7z"/></svg>
                    </div>
                    <div style="font-weight:700;color:#2BD4A4;font-size:14px">ESPACE</div>
                    <div style="font-size:11px;color:#bcd6df">Chute instantanée</div>
                  </div>
                  <div style="background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1);padding:10px;border-radius:8px;text-align:center">
                    <div style="height:26px;margin-bottom:4px;display:flex;justify-content:center;align-items:center">
                      <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="#FF6B6B" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>
                    </div>
                    <div style="font-weight:700;color:#FF6B6B;font-size:14px">P</div>
                    <div style="font-size:11px;color:#bcd6df">Pause/Reprendre</div>
                  </div>
                  <div style="background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1);padding:10px;border-radius:8px;text-align:center">
                    <div style="height:26px;margin-bottom:4px;display:flex;justify-content:center;align-items:center">
                      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#FF9F1C" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 2v6h-6"/><path d="M3 12a9 9 0 0 1 15-6"/><path d="M3 22v-6h6"/><path d="M21 12a9 9 0 0 1-15 6"/></svg>
                    </div>
                    <div style="font-weight:700;color:#FF9F1C;font-size:14px">R</div>
                    <div style="font-size:11px;color:#bcd6df">Recommencer</div>
                  </div>
                </div>
              </div>

              <!-- Scoring système -->
              <div style="margin-bottom:20px">
                <div style="font-size:16px;font-weight:800;color:#fff;margin-bottom:12px;text-align:center">Système de Score</div>
                <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:8px">
                  <div style="background:linear-gradient(135deg,rgba(43,212,164,0.2),rgba(43,212,164,0.1));border:1px solid #2BD4A4;padding:12px;border-radius:8px;text-align:center">
                    <div style="font-size:24px;font-weight:900;color:#2BD4A4">100</div>
                    <div style="font-size:11px;color:#bcd6df;margin-top:2px">1 ligne</div>
                  </div>
                  <div style="background:linear-gradient(135deg,rgba(255,209,102,0.2),rgba(255,209,102,0.1));border:1px solid #FFD166;padding:12px;border-radius:8px;text-align:center">
                    <div style="font-size:24px;font-weight:900;color:#FFD166">300</div>
                    <div style="font-size:11px;color:#bcd6df;margin-top:2px">2 lignes</div>
                  </div>
                  <div style="background:linear-gradient(135deg,rgba(155,93,229,0.2),rgba(155,93,229,0.1));border:1px solid #9B5DE5;padding:12px;border-radius:8px;text-align:center">
                    <div style="font-size:24px;font-weight:900;color:#9B5DE5">500</div>
                    <div style="font-size:11px;color:#bcd6df;margin-top:2px">3 lignes</div>
                  </div>
                  <div style="background:linear-gradient(135deg,rgba(31,182,255,0.2),rgba(31,182,255,0.1));border:1px solid #1FB6FF;padding:12px;border-radius:8px;text-align:center">
                    <div style="font-size:24px;font-weight:900;color:#1FB6FF">800</div>
                    <div style="font-size:11px;color:#bcd6df;margin-top:2px">4 lignes (TETRIS!)</div>
                  </div>
                </div>
                <div style="text-align:center;margin-top:8px;font-size:12px;color:#bcd6df">
                  Astuce: Score multiplié par (Niveau + 1) • Combos donnent des bonus supplémentaires.
                </div>
              </div>



            </div>
            <div class="menuActions" style="max-width:clamp(150px,50vw,250px);margin:clamp(4px,1vh,12px) auto 0">
              <button class="btn" id="helpBackBtn">Retour au Menu</button>
            </div>
          </div>

          <!-- Page Paramètres -->
          <div class="menuPage" id="tab-settings" style="display:none;flex-direction:column;align-items:center;justify-content:flex-start;gap:clamp(1vh,2vh,3vh);padding:clamp(20px,4vh,60px) clamp(8px,3vw,40px) clamp(16px,3vh,40px) clamp(8px,3vw,40px);height:auto;min-height:78vh;text-align:center">
            <div style="background:#FF6B6B;padding:clamp(8px,1.5vh,18px) clamp(12px,3vw,24px);border-radius:clamp(8px,2vw,14px);font-size:clamp(16px,3vw,22px);font-weight:900;letter-spacing:.8px;color:#fff;align-self:center;min-width:clamp(200px,45vw,280px);text-align:center">PARAMÈTRES</div>
            
            <div class="panel" style="background:linear-gradient(180deg,rgba(255,255,255,0.04),rgba(255,255,255,0.02));max-width:clamp(300px,85vw,800px);width:100%;border:1px solid rgba(255,255,255,0.08);max-height:clamp(40vh,60vh,70vh);overflow-y:auto;scrollbar-width:thin;scrollbar-color:rgba(255,255,255,0.3) transparent">
              
              <!-- Header avec titre stylé + utilisateur -->
              <div id="settingsUserIndicator" style="font-size:12px;font-weight:600;color:#bcd6df;display:flex;align-items:center;justify-content:center;gap:6px;margin-bottom:20px">
                <span style="display:inline-flex;width:22px;height:22px;border-radius:50%;background:rgba(255,255,255,0.08);align-items:center;justify-content:center;font-size:12px;color:#fff" id="settingsUserIcon">B</span>
                <span id="settingsUserText">Connecté en tant que <strong>Benjamin</strong></span>
              </div>

              <!-- Interface: contrôles tactiles (visible partout) -->
              <div style="display:flex;align-items:center;justify-content:space-between;background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.08);padding:14px 16px;border-radius:10px;margin-bottom:16px">
                <div style="display:flex;flex-direction:column;align-items:flex-start;gap:4px">
                  <div style="color:#fff;font-weight:700;font-size:14px">Boutons tactiles</div>
                  <div style="font-size:11px;color:#bcd6df;max-width:280px;text-align:left">Afficher les contrôles à l'écran (activés par défaut sur iPhone).</div>
                </div>
                <label class="cbx" for="toggleTouchControls" style="display:inline-flex;align-items:center;cursor:pointer;gap:10px;user-select:none;padding:4px 6px;border-radius:8px">
                  <input type="checkbox" id="toggleTouchControls" style="position:absolute;opacity:0;width:1px;height:1px;pointer-events:none" aria-label="Boutons tactiles" />
                  <span class="cbx_box" aria-hidden="true">
                    <svg viewBox="0 0 24 24" class="cbx_svg" width="24" height="24">
                      <rect class="cbx_bg" x="3" y="3" width="18" height="18" rx="5"></rect>
                      <path class="cbx_tick" d="M6 12 L10 16 L18 8" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                  </span>
                </label>
              </div>

              <!-- Configuration Desktop -->
              <div id="desktopSettings" style="margin-bottom:20px">
                <div style="font-size:16px;font-weight:800;color:#fff;margin-bottom:20px;text-align:center">
                  Configuration des Touches
                </div>
                
                <div style="display:grid;grid-template-columns:repeat(2,1fr);gap:16px;margin-bottom:24px">
                  <!-- Gauche -->
                  <div style="background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.08);border-radius:8px;padding:16px">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
                      <div style="font-weight:700;color:#fff;font-size:14px">Gauche</div>
                      <div style="font-size:12px;color:#bcd6df">Déplacer à gauche</div>
                    </div>
                    <input class="btn" id="keyLeft" type="text" readonly value="A" style="width:100%;text-align:center;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.12);color:#e6eef6;font-weight:700">
                  </div>

                  <!-- Droite -->
                  <div style="background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.08);border-radius:8px;padding:16px">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
                      <div style="font-weight:700;color:#fff;font-size:14px">Droite</div>
                      <div style="font-size:12px;color:#bcd6df">Déplacer à droite</div>
                    </div>
                    <input class="btn" id="keyRight" type="text" readonly value="D" style="width:100%;text-align:center;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.12);color:#e6eef6;font-weight:700">
                  </div>

                  <!-- Rotation -->
                  <div style="background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.08);border-radius:8px;padding:16px">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
                      <div style="font-weight:700;color:#fff;font-size:14px">Rotation</div>
                      <div style="font-size:12px;color:#bcd6df">Tourner la pièce</div>
                    </div>
                    <input class="btn" id="keyRotate" type="text" readonly value="W" style="width:100%;text-align:center;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.12);color:#e6eef6;font-weight:700">
                  </div>

                  <!-- Descendre -->
                  <div style="background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.08);border-radius:8px;padding:16px">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
                      <div style="font-weight:700;color:#fff;font-size:14px">Descendre</div>
                      <div style="font-size:12px;color:#bcd6df">Descente lente</div>
                    </div>
                    <input class="btn" id="keyDown" type="text" readonly value="S" style="width:100%;text-align:center;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.12);color:#e6eef6;font-weight:700">
                  </div>

                  <!-- Chute rapide -->
                  <div style="background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.08);border-radius:8px;padding:16px">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
                      <div style="font-weight:700;color:#fff;font-size:14px">Chute Rapide</div>
                      <div style="font-size:12px;color:#bcd6df">Chute instantanée</div>
                    </div>
                    <input class="btn" id="keyDrop" type="text" readonly value="Espace" style="width:100%;text-align:center;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.12);color:#e6eef6;font-weight:700">
                  </div>

                  <!-- Pause -->
                  <div style="background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.08);border-radius:8px;padding:16px">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
                      <div style="font-weight:700;color:#fff;font-size:14px">Pause</div>
                      <div style="font-size:12px;color:#bcd6df">Pause/Reprendre</div>
                    </div>
                    <input class="btn" id="keyPause" type="text" readonly value="P" style="width:100%;text-align:center;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.12);color:#e6eef6;font-weight:700">
                  </div>
                </div>

                <!-- Boutons d'actions Desktop -->
                <div style="display:flex;gap:12px;justify-content:center;margin-bottom:12px">
                  <button class="btn" id="saveSettingsBtn" style="padding:12px 20px">Enregistrer</button>
                  <button class="btn" id="resetBindingsBtn" style="padding:12px 20px">Réinitialiser</button>
                </div>
              </div>

              <!-- Configuration Mobile -->
              <div id="mobileSettings" style="margin-bottom:20px;display:none">
                <div style="font-size:16px;font-weight:800;color:#fff;margin-bottom:20px;text-align:center">
                  Paramètres Mobiles
                </div>

                <!-- Section mobile simplifiée -->
                <div style="margin-bottom:24px">
                  <div style="text-align:center;font-size:12px;color:#bcd6df;font-style:italic">Que sur ordi chouchou :P</div>
                </div>

                <!-- (Le toggle des contrôles tactiles est maintenant en haut des paramètres, visible partout) -->
              </div>
            </div>
            
            <div class="menuActions" style="max-width:clamp(150px,50vw,250px);margin:clamp(4px,1vh,12px) auto 0">
              <button class="btn" id="settingsBackBtn">Retour au Menu</button>
            </div>
          </div>

          <!-- Page Leaderboard -->
          <div class="menuPage" id="tab-leaderboard" style="display:none;flex-direction:column;align-items:center;justify-content:flex-start;gap:clamp(1vh,2vh,3vh);padding:clamp(20px,4vh,60px) clamp(8px,2vw,40px) clamp(16px,3vh,40px) clamp(8px,2vw,40px);height:auto;min-height:78vh;text-align:center;width:100%;box-sizing:border-box">
            <div style="background:#FFD166;padding:clamp(8px,1.5vh,18px) clamp(12px,3vw,24px);border-radius:clamp(8px,2vw,14px);font-size:clamp(16px,3vw,22px);font-weight:900;letter-spacing:.8px;color:#fff;align-self:center;min-width:clamp(220px,50vw,320px);text-align:center">LEADERBOARD</div>
            <div class="panel" style="background:linear-gradient(180deg,rgba(255,255,255,0.04),rgba(255,255,255,0.02));width:100%;max-width:clamp(500px,90vw,2600px);border:1px solid rgba(255,255,255,0.08);padding:clamp(0.5rem,1vw,1.2rem) clamp(0.5rem,1vw,1.5rem);display:flex;flex-direction:column;gap:clamp(8px,1.5vh,16px);max-height:clamp(60vh,70vh,90vh);overflow-y:auto;overflow-x:auto;margin:0 auto;box-sizing:border-box">
              <div style="display:flex;justify-content:space-between;align-items:center;gap:8px;flex-wrap:wrap;margin-bottom:0.2em;margin-top:0.2em">
                <div id="lbStatus" style="font-size:12px;color:#bcd6df">Chargement…</div>
                <div style="display:flex;gap:6px;align-items:center">
                  <button class="btn" id="lbRefreshBtn" aria-label="Actualiser" title="Actualiser" style="padding:4px;display:flex;align-items:center;justify-content:center;width:32px;height:32px;line-height:1">
                    <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="#FFD166" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display:block">
                      <polyline points="23 4 23 10 17 10"></polyline>
                      <polyline points="1 20 1 14 7 14"></polyline>
                      <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10"></path>
                      <path d="M20.49 15a9 9 0 0 1-14.85 3.36L1 14"></path>
                    </svg>
                  </button>
                </div>
              </div>
              <div style="display:flex;justify-content:center;gap:10px;margin:6px 0 10px 0">
                <button id="lbTabSolo" class="btn" style="padding:8px 24px;font-weight:700;background:#1FB6FF;color:#fff;border-radius:8px;border:none;outline:none;box-shadow:0 2px 8px rgba(31,182,255,0.08);">Solo</button>
                <button id="lbTabDuo" class="btn" style="padding:8px 24px;font-weight:700;background:#ff6b6b;color:#fff;border-radius:8px;border:none;outline:none;box-shadow:0 2px 8px rgba(255,59,59,0.08);">Duo</button>
              </div>
              <div id="lbSoloPanel">
                <table style="width:100%;border-collapse:collapse;font-size:14px">
                  <thead>
                    <tr style="background:rgba(255,255,255,0.07);text-align:left">
                      <th style="padding:6px 8px;font-weight:700;color:#fff;width:36px">#</th>
                      <th style="padding:6px 8px;font-weight:700;color:#fff">Joueur</th>
                      <th style="padding:6px 8px;font-weight:700;color:#fff;width:56px;text-align:right">Niv.</th>
                      <th style="padding:6px 8px;font-weight:700;color:#fff;width:70px;text-align:right">Lignes</th>
                      <th style="padding:6px 6px;font-weight:700;color:#fff;text-align:right;white-space:nowrap;width:clamp(70px,10vw,150px)">Score</th>
                      <th style="padding:6px 8px;font-weight:700;color:#fff;width:126px">Date</th>
                    </tr>
                  </thead>
                  <tbody id="lbBody"></tbody>
                </table>
                <div style="font-size:clamp(8px,2vw,12px);color:#6d8089;text-align:center;margin-top:4px">Les 20 meilleurs scores globaux. Les nouveaux scores prennent quelques secondes à apparaître.</div>
              </div>
              <div id="lbDuoPanel" style="display:none">
                <div style="font-size:clamp(15px,3vw,20px);font-weight:700;color:#ff6b6b;margin-bottom:8px">Duo : Sanaa & Benjamin</div>
                <div style="display:flex;justify-content:center;gap:clamp(16px,3vw,32px);margin-bottom:8px">
                  <div style="flex:1;min-width:90px;max-width:160px;background:rgba(255,255,255,0.04);border-radius:10px;padding:10px 8px 8px 8px;display:flex;flex-direction:column;align-items:center">
                    <div style="font-size:clamp(15px,3vw,20px);font-weight:800;color:#FFD166;margin-bottom:2px">Sanaa</div>
                    <div id="lbDuoSanaaWins" style="font-size:clamp(13px,2vw,16px);color:#fff;font-weight:700;">Victoires : 0</div>
                    <div id="lbDuoSanaaBest" style="font-size:clamp(12px,2vw,15px);color:#bcd6df;">Meilleur chrono : –</div>
                  </div>
                  <div style="flex:1;min-width:90px;max-width:160px;background:rgba(255,255,255,0.04);border-radius:10px;padding:10px 8px 8px 8px;display:flex;flex-direction:column;align-items:center">
                    <div style="font-size:clamp(15px,3vw,20px);font-weight:800;color:#FFD166;margin-bottom:2px">Benjamin</div>
                    <div id="lbDuoBenWins" style="font-size:clamp(13px,2vw,16px);color:#fff;font-weight:700;">Victoires : 0</div>
                    <div id="lbDuoBenBest" style="font-size:clamp(12px,2vw,15px);color:#bcd6df;">Meilleur chrono : –</div>
                  </div>
                </div>
                <div style="font-size:clamp(13px,2vw,16px);font-weight:700;color:#fff;margin-bottom:6px">Historique des parties Duo</div>
                <table style="width:100%;border-collapse:collapse;font-size:14px">
                  <thead>
                    <tr style="background:rgba(255,255,255,0.07);text-align:left">
                      <th style="padding:6px 8px;font-weight:700;color:#fff;width:36px">#</th>
                      <th style="padding:6px 8px;font-weight:700;color:#fff">Gagnant</th>
                      <th style="padding:6px 8px;font-weight:700;color:#fff;width:120px;text-align:right">Chrono</th>
                      <th style="padding:6px 8px;font-weight:700;color:#fff;width:126px">Date</th>
                    </tr>
                  </thead>
                  <tbody id="lbDuoBody">
                    <tr><td colspan="4" style="padding:10px;font-size:12px;color:#6d8089">Aucune partie duo enregistrée.</td></tr>
                  </tbody>
                </table>
              </div>
            </div>
            <div class="menuActions" style="max-width:clamp(180px,50vw,280px);margin:clamp(4px,1vh,12px) auto 0">
              <button class="btn" id="leaderboardBackBtn">Retour au Menu</button>
            </div>
          </div>
        </div>
        <div class="menuRight" style="display:none"></div>
      </div>
    </div>
  </div>

  <!-- GAME SCREEN -->
  <div id="gameScreen" style="display:none" class="center">
    <div class="container" style="padding:clamp(8px,2vh,20px);max-width:100vw;box-sizing:border-box">
      <!-- Version Desktop -->
  <div class="board-wrap desktop-layout" style="gap:clamp(8px,2vw,18px);align-items:center;justify-content:center;flex-wrap:wrap;min-height:100vh">
        <div class="card" style="flex-shrink:0">
          <canvas id="board" style="max-width:min(70vw,400px);height:auto"></canvas>
        </div>
        <div class="side" style="min-width:clamp(200px,25vw,280px);max-width:300px">
          <div class="panel">
            <div style="display:flex;justify-content:flex-end;align-items:center;gap:8px">
              <button class="btn" id="backBtn" style="padding:clamp(6px,2vw,12px) clamp(8px,3vw,16px);font-size:clamp(10px,3vw,14px)">Menu</button>
            </div>
            <div style="margin-top:10px;font-size:clamp(12px,3vw,14px)">Score: <strong id="score" style="color:#FFD166;font-size:clamp(14px,3.5vw,18px)">0</strong></div>
            <div style="font-size:clamp(12px,3vw,14px)">Niveau: <strong id="level" style="color:#1FB6FF;font-size:clamp(13px,3.2vw,16px)">0</strong></div>
            <div style="font-size:clamp(12px,3vw,14px)">Lignes: <strong id="lines" style="color:#2BD4A4;font-size:clamp(13px,3.2vw,16px)">0</strong></div>
          </div>
          <div class="panel">
            <div style="text-align:center;margin-bottom:8px;font-size:clamp(11px,3vw,14px)">Prochaines</div>
            <div class="nextList" style="gap:clamp(4px,1vw,8px)">
              <canvas id="next1" width="96" height="64" style="border-radius:10px;overflow:hidden;background:#031318;max-width:15vw;max-height:10vw"></canvas>
              <canvas id="next2" width="96" height="64" style="border-radius:10px;overflow:hidden;background:#031318;max-width:15vw;max-height:10vw"></canvas>
              <canvas id="next3" width="96" height="64" style="border-radius:10px;overflow:hidden;background:#031318;max-width:15vw;max-height:10vw"></canvas>
            </div>
          </div>
        </div>
      </div>

      <!-- Version Mobile optimisée -->
      <div class="mobile-layout" style="display:none;position:relative;width:100vw;height:100vh;box-sizing:border-box">
        <!-- Score/Niveau en haut à gauche avec prochaines pièces en dessous -->
  <div class="mobile-ui" style="position:absolute;top:clamp(4px,1vh,8px);left:clamp(0px,0.2vw,2px);z-index:100">
          <!-- Score/Stats -->
          <div class="mobile-stats" style="background:rgba(0,0,0,0.25);border:1px solid rgba(255,255,255,0.1);border-radius:10px;padding:clamp(6px,1.5vh,10px) clamp(8px,2vw,12px);backdrop-filter:blur(8px);font-size:clamp(12px,3vw,16px);color:#e4f3fa;font-weight:600;margin-bottom:clamp(6px,1.5vh,10px)">
            <div>Score: <strong id="mobileScore" style="color:#FFD166;font-size:clamp(14px,3.5vw,20px)">0</strong></div>
            <div>Niveau: <strong id="mobileLevel" style="color:#1FB6FF;font-size:clamp(12px,3vw,16px)">0</strong></div>
            <div>Lignes: <strong id="mobileLines" style="color:#2BD4A4;font-size:clamp(12px,3vw,16px)">0</strong></div>
          </div>
          
          <!-- Prochaines pièces en dessous du score -->
          <div class="mobile-next" style="background:rgba(0,0,0,0.25);border:1px solid rgba(255,255,255,0.1);border-radius:10px;padding:clamp(4px,1vh,6px) clamp(4px,1vw,6px);backdrop-filter:blur(8px);display:flex;flex-direction:column;align-items:center;gap:clamp(2px,0.5vh,4px);margin-top:clamp(2px,0.5vh,6px)">
            <div style="font-size:clamp(9px,2vw,11px);color:#e4f3fa;text-align:center;opacity:0.7;margin:0 auto 1px auto;width:100%">Suivant</div>
            <canvas id="mobileNext1" width="64" height="40" style="display:block;margin:0 auto;border-radius:6px;background:#031318;border:1px solid rgba(255,255,255,0.08)"></canvas>
            <canvas id="mobileNext2" width="64" height="40" style="display:block;margin:0 auto;border-radius:6px;background:#031318;border:1px solid rgba(255,255,255,0.1)"></canvas>
            <canvas id="mobileNext3" width="64" height="40" style="display:block;margin:0 auto;border-radius:6px;background:#031318;border:1px solid rgba(255,255,255,0.1)"></canvas>
          </div>
        </div>

  <!-- Jeu positionné plus en haut à gauche -->
  <div style="position:absolute;top:6%;left:6%;transform:none;z-index:50;display:flex;align-items:flex-start;justify-content:flex-start;width:100vw;height:100vh;pointer-events:none">
    <canvas id="mobileBoard" style="max-width:min(86vw,600px);max-height:min(84vh,880px);border:2px solid rgba(255,255,255,0.12);border-radius:10px;background:#000;margin:0;pointer-events:auto"></canvas>
        </div>
      </div>
    </div>
    
    <!-- Contrôles tactiles mobiles discrets -->
  <div id="mobileTouchControls" style="display:none;position:fixed;top:0;left:0;width:100vw;height:100vh;pointer-events:none;z-index:1000">
      <!-- Bouton pause en haut à droite -->
      <div class="mobileBtn" id="pauseBtn" style="position:absolute;top:clamp(8px,2vh,16px);right:clamp(8px,2vw,16px);background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.12);color:rgba(255,255,255,0.7);width:clamp(36px,8vw,44px);height:clamp(36px,8vw,44px);border-radius:8px;display:flex;align-items:center;justify-content:center;backdrop-filter:blur(8px);pointer-events:auto">
        <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor"><rect x="3" y="2" width="3" height="12" rx="1"/><rect x="10" y="2" width="3" height="12" rx="1"/></svg>
      </div>
      
    <!-- Boutons gauche/droite au centre -->
    <div id="touchLeftWrap" style="position:absolute;top:50%;left:clamp(8px,2vw,10px);transform:translateY(-50%);display:flex;flex-direction:column;gap:20px;pointer-events:auto">
        <div class="mobileBtn" id="mLeft" style="background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.1);color:rgba(255,255,255,0.6);width:clamp(50px,12vw,60px);height:clamp(50px,12vw,60px);border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:clamp(18px,4vw,24px);backdrop-filter:blur(8px)">◀</div>
      </div>
    <div id="touchRightWrap" style="position:absolute;top:50%;right:clamp(8px,2vw,10px);transform:translateY(-50%);display:flex;flex-direction:column;gap:20px;pointer-events:auto">
        <div class="mobileBtn" id="mRight" style="background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.1);color:rgba(255,255,255,0.6);width:clamp(50px,12vw,60px);height:clamp(50px,12vw,60px);border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:clamp(18px,4vw,24px);backdrop-filter:blur(8px)">▶</div>
      </div>
      
      <!-- Boutons bas centre -->
  <div id="touchBottomWrap" style="position:absolute;bottom:clamp(56px,11vh,80px);left:50%;transform:translateX(-50%);display:flex;gap:clamp(12px,3vw,15px);pointer-events:auto">
        <div class="mobileBtn" id="mRotate" style="background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.1);color:rgba(255,255,255,0.6);width:clamp(50px,12vw,55px);height:clamp(50px,12vw,55px);border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:clamp(16px,4vw,20px);backdrop-filter:blur(8px)">⤾</div>
        <div class="mobileBtn" id="mDown" style="background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.1);color:rgba(255,255,255,0.6);width:clamp(50px,12vw,55px);height:clamp(50px,12vw,55px);border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:clamp(16px,4vw,20px);backdrop-filter:blur(8px)">▼</div>
        <div class="mobileBtn" id="mDrop" style="background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.1);color:rgba(255,255,255,0.6);width:clamp(50px,12vw,55px);height:clamp(50px,12vw,55px);border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:clamp(16px,4vw,20px);backdrop-filter:blur(8px)">⤓</div>
      </div>
    </div>

  <!-- Styles placement amélioré du mini plateau adverse -->
  <style>
    /* Positionnement amélioré et réactif du mini-plateau adverse */
    #opponentMini {
      position: fixed !important;
      right: max(12px, env(safe-area-inset-right)) !important;
      top: calc(env(safe-area-inset-top) + 72px) !important;
      z-index: 1400 !important;
      background: rgba(0,0,0,0.28);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 12px;
      padding: 8px 8px 10px 8px;
      backdrop-filter: blur(6px);
      min-width: 132px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
      transition: opacity .25s ease, transform .25s ease, box-shadow .25s ease, border-color .25s ease;
    }
    /* Position top-right sur tous les appareils */
    #opponentMini {
      top: max(8px, calc(env(safe-area-inset-top) + 8px)) !important;
      right: max(8px, 2vw) !important;
      transform: none !important;
    }
    /* Badge déconnexion amélioré */
    #opDiscBadge {
      position: absolute;
      left: 8px;
      right: 8px;
      top: 6px;
      padding: 6px 10px;
      font-size: 12px;
      font-weight: 800;
      color: #fff;
      background: linear-gradient(90deg, rgba(255,86,63,0.95), rgba(255,121,97,0.85));
      border: 1px solid rgba(255,255,255,0.22);
      border-radius: 8px;
      box-shadow: 0 6px 22px rgba(255, 99, 71, 0.25), inset 0 0 12px rgba(0,0,0,0.25);
      z-index: 10;
      text-align: center;
      pointer-events: none;
      user-select: none;
      letter-spacing: .3px;
    }
    /* Effet pulsing quand déconnecté */
    @keyframes opMiniPulse {
      0% { box-shadow: inset 0 0 0 1px rgba(255,99,71,0.25), 0 0 0 0 rgba(255,99,71,0.18); }
      50% { box-shadow: inset 0 0 0 1px rgba(255,99,71,0.45), 0 0 0 6px rgba(255,99,71,0.12); }
      100% { box-shadow: inset 0 0 0 1px rgba(255,99,71,0.25), 0 0 0 0 rgba(255,99,71,0.18); }
    }
    #opponentMini.opponentMini--disconnected {
      border-color: rgba(255,99,71,0.55) !important;
      animation: opMiniPulse 1.4s ease-in-out infinite;
    }
  </style>

  <!-- HUD Duo: chrono en haut centré -->
  <div id="duoHudTop" style="display:none;position:fixed;top:clamp(6px,1.5vh,12px);left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.35);border:1px solid rgba(255,255,255,0.12);color:#e4f3fa;font-weight:800;padding:6px 12px;border-radius:10px;backdrop-filter:blur(6px);z-index:1500;letter-spacing:.5px;min-width:84px;text-align:center">00:00</div>

      <!-- Mini plateau adverse (Duo) -->
      <div id="opponentMini" style="display:none;">
        <canvas id="opBoard" width="120" height="240" style="display:block;border-radius:6px;background:#031318;margin:0 auto"></canvas>
        <div id="opStats" style="margin-top:6px;font-size:10px;color:#e6eef6;text-align:center;opacity:0.85">Niveau: – • Lignes: –</div>
      </div>
  </div>

  <!-- combo badge -->
  <div class="comboBadge" id="comboBadge">COMBO +1</div>

  <!-- Pause modal responsive -->
  <div id="pauseOverlay" class="overlayFull" style="display:none;background:rgba(0,0,0,0.45);z-index:3000">
    <div style="background:linear-gradient(180deg,#0a1822,#07141b);border:1px solid rgba(255,255,255,0.05);padding:clamp(12px,3vh,18px) clamp(16px,4vw,20px);border-radius:12px;box-shadow:0 20px 60px rgba(0,0,0,0.5);min-width:clamp(200px,60vw,260px);text-align:center;max-width:90vw;display:flex;flex-direction:column;gap:clamp(10px,2vh,14px)">
      <div style="font-size:clamp(16px,5vw,22px);font-weight:800;letter-spacing:.6px">Pause</div>
      <div id="pauseAudioRow" style="display:none;gap:clamp(6px,2.5vw,10px);justify-content:center;flex-wrap:wrap">
        <button class="btn" id="toggleMusicBtn" style="flex:1;min-width:100px;font-size:clamp(11px,3.2vw,13px);padding:clamp(6px,1.6vh,9px) clamp(10px,3vw,14px);background:rgba(255,255,255,0.07)">Musique: ON</button>
        <button class="btn" id="toggleSfxBtn" style="flex:1;min-width:100px;font-size:clamp(11px,3.2vw,13px);padding:clamp(6px,1.6vh,9px) clamp(10px,3vw,14px);background:rgba(255,255,255,0.07)">SFX: ON</button>
      </div>
      <div style="display:flex;gap:clamp(6px,3vw,10px);justify-content:center;flex-wrap:wrap">
        <button class="btn" id="pauseContinueBtn" style="font-size:clamp(12px,3vw,14px);padding:clamp(8px,2vh,10px) clamp(12px,3vw,16px)">Continuer</button>
        <button class="btn" id="pauseMenuBtn" style="font-size:clamp(12px,3vw,14px);padding:clamp(8px,2vh,10px) clamp(12px,3vw,16px)">Menu</button>
      </div>
    </div>
  </div>

  <!-- touch controls -->
  <!-- Game Over responsive overlay -->
  <div id="gameOverOverlay" class="overlayFull" style="display:none;pointer-events:auto;background:rgba(0,0,0,0.55);backdrop-filter:blur(6px);z-index:4000">
    <div class="gameOverWrap" style="display:flex;flex-direction:column;align-items:center;gap:clamp(8px,2vh,14px);pointer-events:auto;padding:clamp(8px,2vw,16px);max-width:90vw">
      <div class="gameOverText" id="gameOverText" style="font-size:clamp(28px,8vw,48px);font-weight:900;margin-bottom:clamp(8px,2vh,16px);background:linear-gradient(45deg,#FF6B6B,#FFD166);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text;letter-spacing:1.5px">GAME OVER</div>
  <div id="gameOverStats" style="opacity:0;transform:translateY(6px);transition:.45s;display:flex;flex-direction:column;gap:clamp(6px,2vh,10px);font-size:clamp(12px,3.5vw,15px);font-weight:600;color:#e4f3fa;background:linear-gradient(180deg,rgba(255,255,255,0.08),rgba(255,255,255,0.03));padding:clamp(12px,3vh,20px) clamp(16px,4vw,26px) clamp(10px,2.5vh,18px) clamp(16px,4vw,26px);border:1px solid rgba(255,255,255,0.09);border-radius:clamp(12px,3vw,18px);backdrop-filter:blur(6px);min-width:clamp(240px,60vw,400px);max-width:90vw;text-align:left;box-shadow:0 8px 32px rgba(0,0,0,0.55)">
  <div style="display:flex;justify-content:space-between;align-items:center"><span style="opacity:.85">Score</span><span id="goScore" style="color:#FFD166;font-weight:800;font-size:clamp(16px,4vw,20px)">0</span></div>
  <div style="display:flex;justify-content:space-between;align-items:center"><span style="opacity:.85">Niveau</span><span id="goLevel" style="color:#4DD2FF;font-weight:700;font-size:clamp(14px,3.5vw,18px)">1</span></div>
  <div style="display:flex;justify-content:space-between;align-items:center"><span style="opacity:.85">Lignes</span><span id="goLines" style="color:#2BD4A4;font-weight:700;font-size:clamp(14px,3.5vw,18px)">0</span></div>
  <div style="margin-top:2px;font-size:clamp(10px,2.5vw,12px);color:#8baebb" id="goHint">Rejouer ou Menu pour revenir</div>
      </div>
      <div style="display:flex;gap:clamp(6px,2vw,10px);justify-content:center;width:100%;flex-wrap:wrap">
        <button class="btn btn-lg" id="replayBtn" style="pointer-events:auto;flex:1;min-width:clamp(80px,20vw,120px);font-size:clamp(12px,3vw,14px);padding:clamp(8px,2vh,12px) clamp(12px,3vw,16px)">Rejouer</button>
        <button class="btn btn-lg" id="menuBtnFromGO" style="pointer-events:auto;flex:1;min-width:clamp(80px,20vw,120px);font-size:clamp(12px,3vw,14px);padding:clamp(8px,2vh,12px) clamp(12px,3vw,16px)">Menu</button>
      </div>
    </div>
  </div>

  <!-- Résultat Duo -->
  <div id="duoResultOverlay" class="overlayFull" style="display:none;pointer-events:auto;background:rgba(7,16,32,0.92);backdrop-filter:blur(8px);z-index:5000">
    <div class="gameOverWrap" style="display:flex;flex-direction:column;align-items:center;gap:clamp(10px,2.5vh,16px);pointer-events:auto;padding:clamp(12px,3vw,24px);max-width:92vw">
      <div id="duoWinnerTitle" style="font-size:clamp(20px,6vw,28px);font-weight:900;color:#fff;letter-spacing:1px;text-align:center"></div>
      <div style="display:flex;gap:clamp(10px,3vw,20px);flex-wrap:wrap;justify-content:center">
        <div id="duoCardLocal" style="min-width:220px;background:linear-gradient(180deg,rgba(43,212,164,0.08),rgba(255,255,255,0.04));border:1px solid rgba(43,212,164,0.35);border-radius:12px;padding:12px 16px;color:#e6eef6;position:relative">
          <div style="position:absolute;top:8px;right:10px;font-size:11px;background:rgba(43,212,164,0.18);border:1px solid rgba(43,212,164,0.45);padding:2px 6px;border-radius:999px;color:#2BD4A4" id="duoLocalBadge">Joueur</div>
          <div style="font-weight:800;margin-bottom:6px" id="duoP1Name">Joueur 1</div>
          <div>Temps: <strong id="duoP1Time">00:00</strong></div>
          <div>Score: <strong id="duoP1Score">0</strong></div>
          <div>Niveau: <strong id="duoP1Level">1</strong></div>
          <div>Lignes: <strong id="duoP1Lines">0</strong></div>
        </div>
        <div id="duoCardRemote" style="min-width:220px;background:linear-gradient(180deg,rgba(255,59,59,0.08),rgba(255,255,255,0.04));border:1px solid rgba(255,59,59,0.35);border-radius:12px;padding:12px 16px;color:#e6eef6;position:relative">
          <div style="position:absolute;top:8px;right:10px;font-size:11px;background:rgba(255,59,59,0.18);border:1px solid rgba(255,59,59,0.45);padding:2px 6px;border-radius:999px;color:#ff6b6b" id="duoRemoteBadge">Adversaire</div>
          <div style="font-weight:800;margin-bottom:6px" id="duoP2Name">Joueur 2</div>
          <div>Temps: <strong id="duoP2Time">00:00</strong></div>
          <div>Score: <strong id="duoP2Score">0</strong></div>
          <div>Niveau: <strong id="duoP2Level">1</strong></div>
          <div>Lignes: <strong id="duoP2Lines">0</strong></div>
        </div>
      </div>
      <div style="display:flex;gap:clamp(6px,2vw,10px);justify-content:center;width:100%;flex-wrap:wrap;margin-top:6px">
        <button class="btn btn-lg" id="duoReplayBtn" style="pointer-events:auto;flex:1;min-width:clamp(80px,20vw,120px)">Rejouer</button>
        <button class="btn btn-lg" id="duoMenuBtn" style="pointer-events:auto;flex:1;min-width:clamp(80px,20vw,120px)">Menu</button>
      </div>
    </div>
  </div>

  <!-- Modal de confirmation pour quitter -->
  <div id="quitConfirmModal" class="quitConfirmModal">
    <div class="quitConfirmContent">
      <div class="quitConfirmTitle">Quitter la partie ?</div>
      <div class="quitConfirmStats">
        <div>Score: <span id="quitScore">0</span></div>
        <div>Niveau: <span id="quitLevel">1</span></div>
        <div>Lignes: <span id="quitLines">0</span></div>
      </div>
      <div style="font-size:clamp(12px,3vw,14px);color:#8baebb;margin-bottom:clamp(12px,2vh,16px)">
        Votre résultat sera sauvegardé automatiquement
      </div>
      <div class="quitConfirmActions">
        <button class="quitConfirmBtn continue" id="quitContinue">Continuer</button>
        <button class="quitConfirmBtn quit" id="quitConfirm">Quitter</button>
      </div>
    </div>
  </div>

<script>
/* Tetris full — features:
   - Menu as separate page
   - built-in music (synth loop)
   - auto AZERTY/QWERTY mapping (based on navigator.language) + settings available
   - 3-next pieces
   - line clear bar animation + particles
   - combo counter
*/

// Logger minimaliste: activer pour debug détaillé
const LOG_DEBUG = false;
function dlog(){ if(LOG_DEBUG) try{ console.log.apply(console, arguments); }catch{} }
function dinfo(){ if(LOG_DEBUG) try{ console.info.apply(console, arguments); }catch{} }
function dwarn(){ if(LOG_DEBUG) try{ console.warn.apply(console, arguments); }catch{} }
/*
   - animated GAME OVER text
*/

// Board constants
const COLS = 10, ROWS = 20; let BLOCK = 30;
let boardCanvas, ctx;

// Initialiser le canvas selon la plateforme
function initBoard() {
  const isMobileView = window.innerWidth <= 820;
  if (isMobileView) {
    boardCanvas = document.getElementById('mobileBoard');
    // Copier le canvas mobile vers les desktop canvas pour consistance
    const desktopBoard = document.getElementById('board');
    if (desktopBoard) {
      desktopBoard.width = boardCanvas.width;
      desktopBoard.height = boardCanvas.height;
    }
  } else {
    boardCanvas = document.getElementById('board');
    // Copier le canvas desktop vers mobile pour consistance
    const mobileBoard = document.getElementById('mobileBoard');
    if (mobileBoard) {
      mobileBoard.width = boardCanvas.width;
      mobileBoard.height = boardCanvas.height;
    }
  }
  ctx = boardCanvas.getContext('2d');
}
function resizeBoard(){
  // Initialiser le bon canvas selon la taille d'écran
  initBoard();
  
  // compute max block size that fits viewport without scroll, considering side panel width ~ 320px and margins
  const vw = window.innerWidth, vh = window.innerHeight;
  
  // Mobile optimization: ensure full game visibility - 80% de l'écran
  if(vw <= 768) {
    // Mobile: utiliser 85% de l'espace (après recentrage) et autoriser blocs plus grands
    const availableW = vw * 0.85;
    const availableH = vh * 0.85;
    const blockByW = Math.floor(availableW / COLS);
    const blockByH = Math.floor(availableH / ROWS);
    BLOCK = Math.max(16, Math.min(40, Math.min(blockByW, blockByH))); // augmentation du max
  } else {
    // Desktop logic
    const sideW = Math.min(360, Math.max(280, Math.floor(vw*0.28))); // estimate side panel
    const availableW = Math.max(200, vw - (vw>820? sideW + 60 : 40));
    const availableH = vh - 80; // some breathing room for top/bottom
    const blockByW = Math.floor(availableW / COLS);
    const blockByH = Math.floor(availableH / ROWS);
    BLOCK = Math.max(14, Math.min(36, Math.min(blockByW, blockByH))); // clamp for comfort
  }
  
  boardCanvas.width = COLS*BLOCK; boardCanvas.height = ROWS*BLOCK;
  
  // Synchroniser les deux canvas
  const otherCanvas = vw <= 820 ? document.getElementById('board') : document.getElementById('mobileBoard');
  if (otherCanvas) {
    otherCanvas.width = boardCanvas.width;
    otherCanvas.height = boardCanvas.height;
  }
}
resizeBoard();
window.addEventListener('resize', ()=>{ resizeBoard(); drawBoard(); renderNext(); });

const nextCanvases = [document.getElementById('next1'), document.getElementById('next2'), document.getElementById('next3')];
const mobileNextCanvases = [document.getElementById('mobileNext1'), document.getElementById('mobileNext2'), document.getElementById('mobileNext3')];
const nextCtx = nextCanvases.filter(c=>c).map(c=>c.getContext('2d'));
const mobileNextCtx = mobileNextCanvases.filter(c=>c).map(c=>c.getContext('2d'));

const COLORS = { 'I':'#1FB6FF','O':'#FFD166','T':'#9B5DE5','S':'#2BD4A4','Z':'#FF6B6B','J':'#3A6CFD','L':'#FF9F1C' };
const TETROMINOES = { 'I': [[[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]]], 'O': [[[0,1,1,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]]], 'T': [[[0,1,0,0],[1,1,1,0],[0,0,0,0],[0,0,0,0]]], 'S': [[[0,1,1,0],[1,1,0,0],[0,0,0,0],[0,0,0,0]]], 'Z': [[[1,1,0,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]]], 'J': [[[1,0,0,0],[1,1,1,0],[0,0,0,0],[0,0,0,0]]], 'L': [[[0,0,1,0],[1,1,1,0],[0,0,0,0],[0,0,0,0]]] };
function rotateMatrix(mat){ const N=mat.length; const res=Array.from({length:N},()=>Array(N).fill(0)); for(let r=0;r<N;r++) for(let c=0;c<N;c++) res[c][N-1-r]=mat[r][c]; return res; }
for(const k of Object.keys(TETROMINOES)){ let rots=TETROMINOES[k]; let full=rots.slice(); let curr=rots[0]; for(let i=1;i<4;i++){ curr=rotateMatrix(curr); if(!full.some(m=>JSON.stringify(m)===JSON.stringify(curr))) full.push(curr);} TETROMINOES[k]=full; }

// Duo helpers (globaux)
let isDuoMode = false;
let duoLocal = { startAt:null, finishedAt:null, elapsedSec:null };
let duoRemote = { startAt:null, finishedAt:null, elapsedSec:null, state:null, id:null };
// Flags Duo nécessaires avant toute référence (évite ReferenceError si utilisés avant déclaration)
let duoResultShown = false; // modal résultat déjà affiché
let duoCountdownActive = false; // évite le flicker 2/2 pendant le compte à rebours
function setDuoBackDisabled(disabled){
  const btn = document.getElementById('duoBackBtn');
  if(!btn) return;
  btn.disabled = !!disabled;
  btn.style.opacity = disabled? '0.6':'1';
  btn.style.pointerEvents = disabled? 'none':'auto';
}
function applyDuoUiMode(active){
  // Masquer/afficher uniquement la ligne Score (desktop et mobile)
  const scoreStrong = document.getElementById('score');
  if(scoreStrong && scoreStrong.parentElement){ scoreStrong.parentElement.style.display = active? 'none':''; }
  const mobileScore = document.getElementById('mobileScore');
  if(mobileScore && mobileScore.parentElement){ mobileScore.parentElement.style.display = active? 'none':''; }
  // Masquer le bouton Menu en Duo
  const backBtn = document.getElementById('backBtn');
  if(backBtn){ backBtn.style.display = active? 'none' : ''; }
}
// Exposer pour le module
if(typeof window !== 'undefined'){
  window.isDuoMode = isDuoMode;
  window.setDuoBackDisabled = setDuoBackDisabled;
  window.applyDuoUiMode = applyDuoUiMode;
}

// Mobile/Desktop detection and settings management
const isMobile = () => /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
let isOnMobile = isMobile();

// Initialize correct settings UI
function initPlatformSettings() {
  const desktopSettings = document.getElementById('desktopSettings');
  const mobileSettings = document.getElementById('mobileSettings');
  
  if (isOnMobile) {
    if (desktopSettings) desktopSettings.style.display = 'none';
    if (mobileSettings) mobileSettings.style.display = 'block';
  } else {
    if (desktopSettings) desktopSettings.style.display = 'block';
    if (mobileSettings) mobileSettings.style.display = 'none';
  }
}

// Mobile swipe controls
let touchStartX = 0, touchStartY = 0;
let swipeSensitivity = 2; // 1=high, 2=normal, 3=low
let vibrationsEnabled = true;

const swipeThresholds = {
  1: { distance: 30, time: 200 }, // High sensitivity
  2: { distance: 50, time: 300 }, // Normal
  3: { distance: 80, time: 400 }  // Low sensitivity
};

function vibrate(duration = 50) {
  if (vibrationsEnabled && navigator.vibrate) {
    navigator.vibrate(duration);
  }
}

function handleTouchStart(e) {
  if (!isOnMobile || !running) return;
  
  const touch = e.touches[0];
  touchStartX = touch.clientX;
  touchStartY = touch.clientY;
  e.preventDefault();
}

function handleTouchEnd(e) {
  if (!isOnMobile || !running) return;
  
  const touch = e.changedTouches[0];
  const endX = touch.clientX;
  const endY = touch.clientY;
  const diffX = endX - touchStartX;
  const diffY = endY - touchStartY;
  
  const threshold = swipeThresholds[swipeSensitivity];
  const absX = Math.abs(diffX);
  const absY = Math.abs(diffY);
  
  if (Math.max(absX, absY) < threshold.distance) return;
  
  e.preventDefault();
  
  if (absX > absY) {
    // Horizontal swipe
    if (diffX > 0) {
      // Swipe right
      movePiece(1);
      vibrate(30);
    } else {
      // Swipe left
      movePiece(-1);
      vibrate(30);
    }
  } else {
    // Vertical swipe
    if (diffY < 0) {
      // Swipe up
      rotatePiece();
      vibrate(40);
    } else {
      // Swipe down
      dropPiece();
      vibrate(50);
    }
  }
}

// Mobile settings event listeners
function initMobileSettings() {
  // Plus de paramètres mobiles complexes - juste un message personnalisé maintenant
  // Rien à initialiser côté JavaScript
}

function updateMobileConnectionStatus() {
  // Cette fonction n'est plus utilisée car on a remplacé l'indicateur par un message statique
  // Conservée pour éviter les erreurs si appelée ailleurs
}

// Grid
let grid = Array.from({length:ROWS}, ()=>Array(COLS).fill(0));
function resetGrid(){ grid = Array.from({length:ROWS}, ()=>Array(COLS).fill(0)); }

// piece & bag
function createPiece(type){ const rots=TETROMINOES[type]; return { type, rots, rotIndex:0, shape:rots && rots[0] ? rots[0] : TETROMINOES[type][0], x:Math.floor(COLS/2)-2, y:-1 }; }
// RNG seedée pour mode duo
if(typeof window!=='undefined' && !('duoSeed' in window)) window.duoSeed = null; // garantit existence avant usage
function mulberry32(a){ return function(){ a|=0; a = (a + 0x6D2B79F5) |0; let t = Math.imul(a ^ a>>>15, 1 | a); t = (t + Math.imul(t ^ t>>>7, 61 | t)) ^ t; return ((t ^ t>>>14) >>> 0) / 4294967296; }; }
let duoRng = null;
function initDuoRngFromSeed(seed){ let h=0; for(let i=0;i<seed.length;i++){ h = Math.imul(31,h) + seed.charCodeAt(i) |0; } duoRng = mulberry32(h); }
function randomBag(){ const seq = Object.keys(TETROMINOES).slice(); const activeSeed = (typeof window!=='undefined')? window.duoSeed : null; const rnd = (activeSeed && duoRng)? duoRng : Math.random; for(let i=seq.length-1;i>0;i--){ const j=Math.floor(rnd()*(i+1)); [seq[i],seq[j]]=[seq[j],seq[i]]; } return seq; }
let bag = []; function nextFromBag(){ if(!bag.length) bag=randomBag(); return bag.pop(); }

// queue (3 next)
let nextQueue = [];
function fillQueue(){ while(nextQueue.length<3) nextQueue.push(createPiece(nextFromBag())); }

let cur = null;
function spawn(){
  dlog('SPAWN start'); dlog('NextQueue before shift:', nextQueue.map(p => p?.type));
  
  cur = nextQueue.shift();
  // Normaliser l'état de la pièce au spawn
  if(cur){
    cur.rotIndex = 0;
    if(cur.rots && cur.rots.length){ cur.shape = cur.rots[cur.rotIndex] || cur.shape; }
    cur.x = Math.floor(COLS/2)-2; cur.y = -1;
  }
  
  // Ajouter une nouvelle pièce
  const newPiece = createPiece(nextFromBag());
  nextQueue.push(newPiece);
  
  dlog('After push nextQueue:', nextQueue.map(p => p?.type)); dlog('Current piece:', cur?.type);
  
  // CRITICAL: Forcer le rendu des previews après chaque spawn
  dlog('Render previews');
  try {
    renderNext();
  dlog('RenderNext ok');
  } catch (error) {
  console.error('Error in renderNext during spawn:', error);
    // En cas d'erreur, essayer de forcer le rendu
    setTimeout(() => {
  dlog('Fallback forceRenderPreviews');
      forceRenderPreviews();
    }, 10);
  }
  
  if(cur && collides(cur,0,0)) onGameOver();
  if(isDuoMode) publishDuoState();
  
  dlog('SPAWN end');
}

// game state
let dropInterval = 800; let lastDrop = 0; let lastTime = 0; let score = 0; let level = 0; let lines = 0; let running = false; var highscore = Number(localStorage.getItem('tetris_hs')||0);
// Ne pas afficher immédiatement le score local, laisser "-" jusqu'au chargement des scores utilisateur
const hsEl = document.getElementById('hsValue'); if(hsEl) hsEl.innerText = '-';

// combo handling: add number of lines cleared to combo directly
let combo = 0; let lastClearWas = false;
function registerClear(c){
  if(c>0){ combo += c; lastClearWas = true; showCombo(combo); }
  else { lastClearWas = false; combo = 0; }
}
function showCombo(n){ const el = document.getElementById('comboBadge'); el.innerText = `COMBO x${n}`; el.classList.add('show'); clearTimeout(el._t); el._t = setTimeout(()=>el.classList.remove('show'), 900); }

// audio: musique fixe depuis son/Tetris.mp3 + SFX (WebAudio)
let audioCtx = null; let musicOn = true, sfxOn = true;
let audioEl = null; // <audio> pour la musique de fond
function ensureAudio(){ if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }

function startMusic(){
  if(!musicOn) return;
  if(!audioEl){ audioEl = new Audio('Son/Tetris.mp3'); audioEl.loop = true; audioEl.volume = 0.25; }
  const p = audioEl.play(); if(p && p.catch){ p.catch(()=>{}); }
}
function stopMusic(){ if(audioEl){ try{ audioEl.pause(); audioEl.currentTime = 0; }catch(e){} } }

function playNote(time,freq,dur=0.18,type='sine',gain=0.05){ ensureAudio(); const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.type=type; o.frequency.setValueAtTime(freq,time); g.gain.setValueAtTime(gain,time); o.connect(g); g.connect(audioCtx.destination); o.start(time); o.stop(time+dur); }
function playSfx(name){ if(!sfxOn) return; ensureAudio(); const now = audioCtx.currentTime; function n(freq,dur,type,g){ const o=audioCtx.createOscillator(); const gg=audioCtx.createGain(); o.type=type||'sine'; o.frequency.setValueAtTime(freq,now); gg.gain.setValueAtTime(g||0.06,now); o.connect(gg); gg.connect(audioCtx.destination); o.start(now); o.stop(now+dur); }
  if(name==='rotate') n(880,0.08,'triangle',0.08); else if(name==='drop') n(440,0.06,'square',0.12); else if(name==='clear'){ n(523,0.18); n(660,0.18,'sine',0.07); n(784,0.18,'sine',0.05);} else if(name==='lock') n(196,0.12,'sawtooth',0.06);
}

// rendering helpers
function roundRect(c,x,y,w,h,r){ c.beginPath(); c.moveTo(x+r,y); c.arcTo(x+w,y,x+w,y+h,r); c.arcTo(x+w,y+h,x,y+h,r); c.arcTo(x,y+h,x,y,r); c.arcTo(x,y,x+w,y,r); c.closePath(); }
function shadeColor(hex,p){ const f=parseInt(hex.slice(1),16), t=p<0?0:255, pct=Math.abs(p)/100; const R=Math.round((t - (f>>16)) * pct) + (f>>16); const G=Math.round((t - (f>>8 & 0x00FF)) * pct) + (f>>8 & 0x00FF); const B=Math.round((t - (f & 0x0000FF)) * pct) + (f & 0x0000FF); return `rgb(${R},${G},${B})`; }

function drawBlock(c,x,y,color,cell=BLOCK,flash=0){ const px = x*cell, py = y*cell; c.fillStyle = color; roundRect(c,px+1,py+1,cell-2,cell-2,Math.max(3,Math.floor(cell/8))); c.fill(); c.strokeStyle = shadeColor(color,-30); c.lineWidth = 2; roundRect(c,px+1,py+1,cell-2,cell-2,Math.max(3,Math.floor(cell/8))); c.stroke(); const sq = Math.max(2,Math.floor(cell/6)); c.fillStyle = shadeColor(color,12); for(let i=0;i<4;i++){ const sx = px + 4 + (i%2)*(sq+2); const sy = py + 4 + Math.floor(i/2)*(sq+2); c.fillRect(sx,sy,sq,sq); } if(flash>0){ c.fillStyle = `rgba(255,255,255,${flash})`; c.fillRect(px+1,py+1,cell-2,cell-2); } }

function drawBoard(highlightRows=[]){
  ctx.clearRect(0,0,boardCanvas.width,boardCanvas.height);
  ctx.fillStyle = '#06161b';
  ctx.fillRect(0,0,boardCanvas.width,boardCanvas.height);
  // Si en duo et joueur KO, griser le fond
  if(isDuoMode && !running){
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    ctx.fillRect(0,0,boardCanvas.width,boardCanvas.height);
  }
  // blocs déjà posés
  for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) if(grid[r][c]){ const flash = highlightRows.includes(r)?0.5:0; drawBlock(ctx,c,r,COLORS[grid[r][c]],BLOCK,flash); }

  // ghost piece (prévisualisation de la position finale)
  if(cur){
    let ghostY = cur.y;
    // avancer jusqu'à collision puis revenir implicitement en ne dépassant pas
    while(true){
      if(collides({x:cur.x,y:ghostY,shape:cur.shape},0,1)) break;
      ghostY++;
    }
    if(ghostY > cur.y){
      ctx.save();
      ctx.globalAlpha = 0.28; // transparence du ghost
      const ghostColor = shadeColor(COLORS[cur.type],35);
      for(let r=0;r<4;r++) for(let c=0;c<4;c++) if(cur.shape[r][c]){ const x = cur.x + c; const y = ghostY + r; if(y>=0) drawBlock(ctx,x,y,ghostColor); }
      ctx.restore();
    }
  }

  // pièce courante
  if(cur){ for(let r=0;r<4;r++) for(let c=0;c<4;c++) if(cur.shape[r][c]){ const x = cur.x + c, y = cur.y + r; if(y>=0) drawBlock(ctx,x,y,COLORS[cur.type]); } }

  // grille légère
  ctx.strokeStyle='rgba(0,0,0,0.12)'; ctx.lineWidth=1;
  for(let x=0;x<=COLS;x++){ ctx.beginPath(); ctx.moveTo(x*BLOCK,0); ctx.lineTo(x*BLOCK,boardCanvas.height); ctx.stroke(); }
  for(let y=0;y<=ROWS;y++){ ctx.beginPath(); ctx.moveTo(0,y*BLOCK); ctx.lineTo(boardCanvas.width,y*BLOCK); ctx.stroke(); }

  // En Duo, si KO, dessiner le texte GAME OVER au centre pour qu'il reste visible même après des redraws
  if(isDuoMode && !running){
    try{
      ctx.save();
      ctx.fillStyle = '#ff3b3b';
      ctx.font = `900 ${Math.floor(BLOCK*1.4)}px Inter, system-ui, Arial`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.lineWidth = 6;
      ctx.strokeStyle = 'rgba(0,0,0,0.55)';
      ctx.strokeText('GAME OVER', boardCanvas.width/2, boardCanvas.height/2);
      ctx.fillText('GAME OVER', boardCanvas.width/2, boardCanvas.height/2);
      ctx.restore();
    }catch{}
  }
}

// Variables pour éviter les rendus en double
let lastRenderedQueue = [];

function renderNext(){
  // Vérifier si on a vraiment besoin de re-rendre
  const currentQueueSignature = nextQueue.map(p => p?.type || 'null').join(',');
  const lastQueueSignature = lastRenderedQueue.join(',');
  
  if (currentQueueSignature === lastQueueSignature && currentQueueSignature !== '') {
    dlog('renderNext skip:', currentQueueSignature);
    return;
  }
  
  // Log clé
  dinfo('renderNext ->', currentQueueSignature);
  
  // Sauvegarder la nouvelle queue
  lastRenderedQueue = nextQueue.map(p => p?.type || 'null');
  
  if (!nextQueue || nextQueue.length === 0) {
  dlog('renderNext: empty queue');
    return;
  }
  
  const pairsDesktop = nextCanvases.filter(c=>c).map(c=>({c, ctx:c.getContext('2d')}));
  const pairsMobile = mobileNextCanvases.filter(c=>c).map(c=>({c, ctx:c.getContext('2d')}));
  
  dlog('renderNext canvases', pairsDesktop.length, pairsMobile.length);
  
  // Nettoyer TOUS les canvases d'abord
  [...pairsDesktop, ...pairsMobile].forEach(({c, ctx}, index) => {
    ctx.clearRect(0,0,c.width,c.height); 
    ctx.fillStyle='#031318'; 
    ctx.fillRect(0,0,c.width,c.height);
  });
  
  // Rendu desktop
  pairsDesktop.forEach((p,idx)=>{
    const {c,ctx} = p; 
    const piece = nextQueue[idx]; 
    
    if(!piece || !piece.shape || !piece.type) {
  dlog(`Desktop ${idx}: skip`);
      return; 
    }
    const shape = piece.shape; 
    const cell = Math.floor(Math.min(c.width/4,c.height/4));
    const startX = Math.floor((c.width - cell*4)/2); 
    const startY = Math.floor((c.height - cell*4)/2) + cell;
    
    for(let r=0;r<4;r++) {
      for(let cc=0;cc<4;cc++) {
        if(shape[r] && shape[r][cc]){ 
          drawBlock(ctx,(startX + cc*cell)/cell,(startY + r*cell)/cell,COLORS[piece.type],cell); 
        }
      }
    }
  dlog(`Desktop ${idx}: ${piece.type}`);
  });
  
  // Rendu mobile
  pairsMobile.forEach((p,idx)=>{
    const {c,ctx} = p; 
    const piece = nextQueue[idx];
    
    if(!piece || !piece.shape || !piece.type) {
  dlog(`Mobile ${idx}: skip`);
      return; 
    }
    const shape = piece.shape; 
    const cell = Math.floor(Math.min(c.width/4,c.height/4));
    const startX = Math.floor((c.width - cell*4)/2); 
    const startY = Math.floor((c.height - cell*4)/2) + cell;
    
    for(let r=0;r<4;r++) {
      for(let cc=0;cc<4;cc++) {
        if(shape[r] && shape[r][cc]){ 
          drawBlock(ctx,(startX + cc*cell)/cell,(startY + r*cell)/cell,COLORS[piece.type],cell); 
        }
      }
    }
    dlog(`Mobile ${idx}: ${piece.type}`);
  });
  dlog('renderNext done');
}

// Nettoyage explicite des canvases de preview (utile avant relance)
function clearNextPreviews(){
  dlog('clearNextPreviews');
  
  // TRÈS IMPORTANT: Reset la queue mémorisée pour forcer un nouveau rendu
  lastRenderedQueue = [];
  
  const all = [...(nextCanvases||[]), ...(mobileNextCanvases||[])].filter(Boolean);
  dlog('clear count:', all.length);
  
  for(const c of all){
    try{
  dlog('clear', c.id || 'no-id', c.width, 'x', c.height);
      const cx = c.getContext('2d');
      // Triple clear pour être sûr
      cx.clearRect(0,0,c.width,c.height);
      cx.fillStyle = '#031318';
      cx.fillRect(0,0,c.width,c.height);
      cx.clearRect(0,0,c.width,c.height); // Re-clear après fill
    }catch(e){
      console.error('Error clearing canvas:', e);
    }
  }
  
  // CRITICAL: Force plusieurs repaints
  requestAnimationFrame(() => {
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
  dlog('Triple RAF: cleared');
      });
    });
  });
  
  dlog('clear previews done');
}

// Force un rerendu complet des previews
function forceRenderPreviews(){
  // Vider complètement les canvases d'abord
  clearNextPreviews();
  
  // Attendre une frame puis rendre
  requestAnimationFrame(() => {
    try {
      renderNext();
    } catch(e) {
      console.error('Error in forceRenderPreviews:', e);
    }
  });
}

// collision + lock
function collides(piece,dx,dy,pros=null){ if(!piece) return true; const shape = pros || piece.shape; for(let r=0;r<4;r++) for(let c=0;c<4;c++) if(shape[r][c]){ const x = piece.x + c + dx; const y = piece.y + r + dy; if(x<0 || x>=COLS || y>=ROWS) return true; if(y>=0 && grid[y][x]) return true; } return false; }

// line-clear animation: sweep bars
let sweeps = []; // {row, t, duration}
let sweepsWillRemove = true; // si false, les lignes ont déjà été retirées du grid
let particles = [];
let lastClearedRows = [];
let clearEffect = null; // {type, t, duration}
function spawnParticlesForRow(r){ for(let c=0;c<COLS;c++){ const x = c*BLOCK + BLOCK/2; const y = r*BLOCK + BLOCK/2; const angle = Math.random()*Math.PI*2; const speed = 1 + Math.random()*3; particles.push({x,y,vx:Math.cos(angle)*speed, vy:Math.sin(angle)*speed - 2, life:120, color:shadeColor(COLORS[grid[r][c]]||'#fff',0)}); } }
function updateParticles(){ for(let i=particles.length-1;i>=0;i--){ const p=particles[i]; p.x += p.vx; p.y += p.vy; p.vy += 0.12; p.life--; if(p.life<=0) particles.splice(i,1); } }
function drawParticles(){ for(const p of particles){ ctx.fillStyle = p.color; ctx.fillRect(p.x-3,p.y-3,6,6); } }

function clearLinesWithSweep(){ // retire les lignes immédiatement, garde une animation visuelle légère
  const full = []; for(let r=0;r<ROWS;r++) if(grid[r].every(cell=>cell)) full.push(r);
  if(!full.length) return 0;
  lastClearedRows = full.slice();
  // Démarrer une animation de sweep (visuelle) mais ne plus différer le retrait
  sweeps.length = 0;
  const duration = 220;
  // Spawner les particules avant retrait pour conserver les couleurs
  full.forEach(r=>{ spawnParticlesForRow(r); });
  full.forEach(r=>{ sweeps.push({row:r, t:0, duration}); });
  // Retirer immédiatement du grid (ordre décroissant)
  const rowsToRemove = full.slice().sort((a,b)=>b-a);
  for(const rowIndex of rowsToRemove){
    grid.splice(rowIndex, 1);
    grid.unshift(Array(COLS).fill(0));
  }
  sweepsWillRemove = false;
  return full.length;
}

// ===== Duo sync: publication et rendu adversaire =====
// Throttling des publications pour éviter trop d'écritures DB
let duoPublishTimer = null;
let duoLastSentAt = 0;
let duoPendingData = null;
let duoLastSig = '';
const DUO_PUBLISH_MIN_MS = 120; // envoi au plus toutes les ~120ms

function compactGrid(g){ // compresser en string lignes de 20 x 10 (caractères A..Z pour types, '.' vide)
  return g.map(row=> row.map(cell=> cell? cell : '.').join('')).join('\n');
}
function expandGrid(str){
  const rows = str.split('\n'); const g = Array.from({length:ROWS},()=>Array(COLS).fill(null));
  for(let r=0;r<Math.min(rows.length,ROWS);r++){
    const line = rows[r]||''; for(let c=0;c<Math.min(line.length,COLS);c++){
      const ch = line[c]; g[r][c] = (ch==='.'? null : ch);
    }
  }
  return g;
}
function computeDuoStateAndSig(){
  const gridStr = compactGrid(grid);
  const curSig = cur ? `${cur.type}:${cur.x}:${cur.y}:${cur.rotIndex}` : '-';
  const nextSig = nextQueue.slice(0,3).map(p=>p? p.type : '.').join('');
  const aliveSig = running ? '1' : '0';
  const finishAt = running ? null : (typeof window!=='undefined' ? (window.duoFinishedAt||null) : null);
  const elapsedSec = running ? null : (typeof window!=='undefined' ? (window.duoElapsedSec|| ( (window.duoFinishedAt && (typeof duoStartAt==='number')) ? Math.max(0, Math.floor((window.duoFinishedAt - duoStartAt)/1000)) : (typeof duoLocal!=='undefined' && duoLocal.startAt ? Math.max(0, Math.floor(((window.duoFinishedAt||Date.now()) - duoLocal.startAt)/1000)) : null))) : null);
  const sig = `${gridStr}|${curSig}|${nextSig}|${score}|${level}|${lines}|${aliveSig}|${finishAt||'-'}|${elapsedSec??'-'}`;
  const data = {
    role: (typeof duoRole !== 'undefined' && duoRole) ? duoRole : 'player',
    seed: (typeof duoSeed !== 'undefined') ? duoSeed : (window.duoSeed||null),
    startAt: (typeof duoStartAt !== 'undefined') ? duoStartAt : null,
    state: {
      grid: gridStr,
      cur: cur? { type: cur.type, x: cur.x, y: cur.y, shape: cur.shape } : null,
      next: nextQueue.slice(0,3).map(p=> p? {type:p.type, shape:p.shape} : null),
      score, level, lines,
  alive: running,
  finishedAt: finishAt,
  elapsedSec: elapsedSec
    }
  };
  return { data, sig };
}

async function sendPendingDuoState(){
  const connId = window.duoConnectionId || (typeof duoConnectionId!=='undefined'? duoConnectionId : null);
  const playerId = window.duoPlayerId || (typeof duoPlayerId!=='undefined'? duoPlayerId : null);
  const sb = (typeof supabase !== 'undefined') ? supabase : (window.supabase || window._supabaseClient || null);
  if(!connId || !playerId || !sb || !duoPendingData) { duoPublishTimer = null; return; }
  try{
    await sb.from('duo_live').update({ data: duoPendingData.data }).eq('room_id', connId).eq('joueur', playerId);
    duoLastSentAt = Date.now();
    duoLastSig = duoPendingData.sig;
  }catch(e){ /* ignorer erreurs transitoires */ }
  finally{
    duoPublishTimer = null;
    duoPendingData = null;
  }
}

function scheduleDuoStateSend(){
  const now = Date.now();
  const dueIn = Math.max(0, DUO_PUBLISH_MIN_MS - (now - duoLastSentAt));
  if(dueIn === 0){
    // envoyer immédiatement
    sendPendingDuoState();
  } else if(!duoPublishTimer){
    duoPublishTimer = setTimeout(()=>{ sendPendingDuoState(); }, dueIn);
  }
}

async function publishDuoState(){
  if(!isDuoMode) return;
  const connId = window.duoConnectionId || (typeof duoConnectionId!=='undefined'? duoConnectionId : null);
  const playerId = window.duoPlayerId || (typeof duoPlayerId!=='undefined'? duoPlayerId : null);
  if(!connId || !playerId) return;
  const payload = computeDuoStateAndSig();
  if(payload.sig === duoLastSig) return; // inchangé
  duoPendingData = payload;
  scheduleDuoStateSend();
}
function drawOpponentMini(state){
  const wrap = document.getElementById('opponentMini'); const cv = document.getElementById('opBoard'); if(!wrap || !cv) return;
  const c = cv.getContext('2d'); c.clearRect(0,0,cv.width,cv.height);
  // Atmosphère adverse: choisir une couleur de fond selon son niveau (même logique que changeAtmosphere)
  try{
    const lvl = (typeof state.level === 'number' ? state.level : 0);
    const atmosphereIndex = Math.floor((lvl+1)/5) % 10;
    const bgColors = ['#04131a','#1a0a1a','#1a0a2e','#2e0a1a','#2e1a0a','#0a2e1a','#1a2e0a','#2e2e0a','#0a0a2e','#2e0a0a'];
    c.fillStyle = bgColors[atmosphereIndex] || '#031318';
    c.fillRect(0,0,cv.width,cv.height);
  }catch{ c.fillStyle='#031318'; c.fillRect(0,0,cv.width,cv.height); }
  const og = expandGrid(state.grid||''); const cell = Math.floor(Math.min(cv.width/COLS, cv.height/ROWS));
  for(let r=0;r<ROWS;r++) for(let cc=0;cc<COLS;cc++){ const t = og[r][cc]; if(t){ const x=cc*cell, y=r*cell; c.fillStyle = COLORS[t]||'#999'; c.fillRect(x+1,y+1,cell-2,cell-2); }}
  // pièce courante adverse
  if(state.cur){ const {type,x,y,shape} = state.cur; for(let r=0;r<4;r++) for(let cc=0;cc<4;cc++) if(shape[r][cc]){ const px=(x+cc)*cell, py=(y+r)*cell; if(py>=0){ c.fillStyle = COLORS[type]||'#aaa'; c.fillRect(px+1,py+1,cell-2,cell-2); } } }
  // Mettre à jour stats adverses
  try{
    const st = document.getElementById('opStats');
    if(st){
      const humanLvl = (typeof state.level === 'number' ? state.level+1 : 1);
      const li = (typeof state.lines === 'number' ? state.lines : 0);
      st.textContent = `Niveau: ${humanLvl} • Lignes: ${li}`;
    }
  }catch{}
}

function triggerClearEffect(count, rows){
  if(!count) return;
  let type = count===2?'double': count===3?'triple': count===4?'tetris':'single';
  if(type==='single') return; // pas d'effet spécial pour 1
  const duration = type==='tetris'?1200: (type==='triple'?800:600);
  clearEffect = {type, t:0, duration};
  // Particules supplémentaires pour triple et tetris
  if(type==='triple' || type==='tetris'){
    rows.forEach(r=>{ for(let c=0;c<COLS;c++){ const x=c*BLOCK+BLOCK/2, y=r*BLOCK+BLOCK/2; for(let i=0;i< (type==='tetris'?8:4); i++){ const ang = Math.random()*Math.PI*2; const sp = (type==='tetris'? 2+Math.random()*5:1+Math.random()*3); particles.push({x,y,vx:Math.cos(ang)*sp, vy:Math.sin(ang)*sp - (type==='tetris'?3:2), life:type==='tetris'?160:120, color: shadeColor(COLORS[grid[r][c]]||'#fff', type==='tetris'? 40:20) }); } }});
  }
}

function updateClearEffect(dt){ if(!clearEffect) return; clearEffect.t += dt; if(clearEffect.t >= clearEffect.duration) clearEffect=null; }

function drawClearEffectOverlay(){ if(!clearEffect) return; const p = clearEffect.t/clearEffect.duration; ctx.save();
  if(clearEffect.type==='double'){
    // pulsation colorée bleue/orange
    const alpha = 0.25 * (1 - p);
    const grd = ctx.createLinearGradient(0,0,boardCanvas.width,boardCanvas.height);
    grd.addColorStop(0,'rgba(31,182,255,'+alpha+')');
    grd.addColorStop(1,'rgba(255,159,28,'+alpha+')');
    ctx.fillStyle = grd; ctx.fillRect(0,0,boardCanvas.width,boardCanvas.height);
  } else if(clearEffect.type==='triple'){
    // vague radiale violette/jaune
    const alpha = 0.30 * (1 - p);
    const cx = boardCanvas.width/2, cy = boardCanvas.height/2;
    const rad = Math.max(cx,cy)*1.2 * p;
    const radial = ctx.createRadialGradient(cx,cy,rad*0.2, cx,cy,rad);
    radial.addColorStop(0,'rgba(155,93,229,'+alpha+')');
    radial.addColorStop(1,'rgba(255,209,102,0)');
    ctx.fillStyle = radial; ctx.fillRect(0,0,boardCanvas.width,boardCanvas.height);
  } else if(clearEffect.type==='tetris'){
    // arc-en-ciel + flash + scan vertical
    const scanProgress = p;
    const bandY = scanProgress * boardCanvas.height;
    // flash initial
    const flash = Math.max(0, 0.5 - p*0.5);
    if(flash>0){ ctx.fillStyle='rgba(255,255,255,'+flash+')'; ctx.fillRect(0,0,boardCanvas.width,boardCanvas.height); }
    // arc-en-ciel global
    const rainbow = ctx.createLinearGradient(0,0,boardCanvas.width,0);
    const cols=['#1FB6FF','#9B5DE5','#FF6B6B','#FFD166','#2BD4A4'];
    cols.forEach((cl,i)=> rainbow.addColorStop(i/(cols.length-1), cl));
    ctx.globalAlpha = 0.22 * (1 - p);
    ctx.fillStyle = rainbow; ctx.fillRect(0,0,boardCanvas.width,boardCanvas.height);
    // bande descendante
    ctx.globalAlpha = 0.35 * (1 - p*0.7);
    ctx.fillStyle = 'rgba(255,255,255,0.25)';
    ctx.fillRect(0, Math.max(0, bandY - 30 - 80*(1-p)), boardCanvas.width, 60);
  }
  ctx.restore();
  // screen shake pour tetris
  if(clearEffect.type==='tetris'){
    const prog = p;
    const amp = 6 * (1 - prog);
    const ox = (Math.random()*2-1)*amp;
    const oy = (Math.random()*2-1)*amp;
    boardCanvas.style.transform = `translate(${ox}px,${oy}px)`;
  } else {
    boardCanvas.style.transform = '';
  }
}

function drawHardDropEffect(){
  if(!hardDropEffect) return;
  hardDropEffect.t += lastTime ? 0 : 0; // placeholder (time progression via frame diff not stored; use timestamp difference?)
  // Utiliser performance.now diff: on stocke pas dt ici, donc on piggyback sur t via Date
  if(!hardDropEffect._start) hardDropEffect._start = performance.now();
  const elapsed = performance.now() - hardDropEffect._start;
  const p = elapsed / hardDropEffect.duration;
  const cells = hardDropEffect.cells;
  if(p>=1){ hardDropEffect=null; boardCanvas.style.filter=''; return; }
  ctx.save();
  // halo expansif depuis centre de masse des cellules
  let cx=0, cy=0; cells.forEach(c=>{ cx += (c.x+0.5)*BLOCK; cy += (c.y+0.5)*BLOCK; }); cx/=cells.length; cy/=cells.length;
  const maxR = Math.max(boardCanvas.width, boardCanvas.height)*0.6;
  const r = maxR * p;
  const g = ctx.createRadialGradient(cx,cy, r*0.15, cx,cy,r);
  const base = hardDropEffect.color;
  g.addColorStop(0, base + '');
  g.addColorStop(0.3, shadeColor(base,40));
  g.addColorStop(1, 'rgba(255,255,255,0)');
  ctx.globalAlpha = 0.25 * (1 - p);
  ctx.fillStyle = g;
  ctx.fillRect(0,0,boardCanvas.width,boardCanvas.height);
  // impact flash par bloc
  ctx.globalAlpha = 0.35 * (1 - p);
  cells.forEach(c=>{ ctx.fillStyle=shadeColor(base,30); ctx.fillRect(c.x*BLOCK+2, c.y*BLOCK+2, BLOCK-4, BLOCK-4); });
  ctx.restore();
  // suppression du squash: ne pas modifier transform ici
  if(p>=1) boardCanvas.style.transform='';
}

function processSweeps(dt){ // avance l'animation; le retrait du grid peut déjà être fait
  if(!sweeps.length) return false;
  let allDone = true;
  for(let i=sweeps.length-1;i>=0;i--){ const s=sweeps[i]; s.t += dt; const progress = Math.min(1, s.t/s.duration);
    // draw sweep overlay and flash blocks simultaneously
    const y = s.row*BLOCK; const width = boardCanvas.width*progress; ctx.fillStyle = `rgba(255,255,255,${0.18*(1-progress)})`; ctx.fillRect(0, y, width, BLOCK);
    if(progress < 1) allDone = false;
  }
  if(allDone){
    // Si on n'a pas encore retiré, faire le retrait ici (cas legacy)
    if(sweepsWillRemove){
      const rowsToRemove = sweeps.map(s=>s.row).sort((a,b)=>b-a);
      for(const rowIndex of rowsToRemove){
        grid.splice(rowIndex, 1);
        grid.unshift(Array(COLS).fill(0));
      }
    }
    sweeps.length = 0;
    sweepsWillRemove = true; // reset
  }
  return sweeps.length>0;
}

function lockPiece(){
  if(!cur) return; const shape = cur.shape; for(let r=0;r<4;r++) for(let c=0;c<4;c++) if(shape[r][c]){ const x=cur.x+c, y=cur.y+r; if(y>=0 && y<ROWS && x>=0 && x<COLS) grid[y][x] = cur.type; }
  playSfx('lock'); const cleared = clearLinesWithSweep();
  if(cleared) { triggerClearEffect(cleared, lastClearedRows); registerClear(cleared); updateScore(cleared); playSfx('clear'); cur = null; }
  else { registerClear(0); spawn(); }
  // S'assurer que les previews se mettent à jour même si l'animation bloque une frame
  try{ renderNext(); }catch{}
  if(isDuoMode) publishDuoState();
}

// Niveau interne commence à 0, on affiche +1 pour l'utilisateur
function updateScore(cleared){ 
  const pts = [0,100,300,500,800]; 
  score += (pts[cleared]||0) * (level+1); 
  lines += cleared; 
  const prevLevel = level;
  
  // Niveau monte encore plus rapidement : tous les 2 lignes au lieu de 3
  level = Math.floor(lines/2); 
  
  // Difficulté augmente moins vite (était level*70, maintenant level*25)
  dropInterval = Math.max(100, 800 - level*25); 
  
  // Changer l'atmosphère tous les 5 niveaux
  // Utiliser (level+1) pour que ça se déclenche au niveau affiché à l'utilisateur
  const atmosphereLevel = Math.floor((level+1)/5);
  const prevAtmosphereLevel = Math.floor((prevLevel+1)/5);
  if(atmosphereLevel !== prevAtmosphereLevel) {
    changeAtmosphere(atmosphereLevel);
  }
  
  // Update desktop UI
  document.getElementById('score').innerText = score; 
  document.getElementById('level').innerText = (level+1); 
  document.getElementById('lines').innerText = lines; 
  
  // Update mobile UI
  const mobileScore = document.getElementById('mobileScore');
  const mobileLevel = document.getElementById('mobileLevel');
  const mobileLines = document.getElementById('mobileLines');
  if(mobileScore) mobileScore.innerText = score;
  if(mobileLevel) mobileLevel.innerText = (level+1);
  if(mobileLines) mobileLines.innerText = lines;
  
  if(score > highscore){ 
    highscore = score; 
    localStorage.setItem('tetris_hs', highscore); 
    document.getElementById('hsValue').innerText = highscore; 
  }
}

function changeAtmosphere(atmosphereLevel) {
  const atmosphereIndex = atmosphereLevel % 10; // Cycle tous les 10 paliers d'atmosphère
  
  // Supprimer toutes les classes d'atmosphère existantes
  for(let i = 0; i < 10; i++) {
    document.body.classList.remove(`atmosphere-${i}`);
  }
  
  // Ajouter la nouvelle classe d'atmosphère
  document.body.classList.add(`atmosphere-${atmosphereIndex}`);
  
  // Changer la couleur de bordure iPhone selon l'atmosphère
  const themeColors = [
    '#071020', // atmosphère 0 : bleu foncé
    '#1a0a1a', // atmosphère 1 : magenta foncé
    '#1a0a2e', // atmosphère 2 : violet
    '#2e0a1a', // atmosphère 3 : rouge foncé
    '#2e1a0a', // atmosphère 4 : orange
    '#0a2e1a', // atmosphère 5 : vert
    '#1a2e0a', // atmosphère 6 : vert-jaune
    '#2e2e0a', // atmosphère 7 : jaune
    '#0a0a2e', // atmosphère 8 : violet foncé
    '#2e0a0a'  // atmosphère 9 : rouge vif
  ];
  
  const themeColorMeta = document.getElementById('themeColorMeta');
  if(themeColorMeta) {
    themeColorMeta.setAttribute('content', themeColors[atmosphereIndex]);
  }
  
  // Optionnel: changer aussi la couleur de bordure du canvas
  const boardCanvas = document.getElementById('board') || document.getElementById('mobileBoard');
  if(boardCanvas) {
    const atmosphereColors = [
      'rgba(255,255,255,0.12)', // atmosphère 0 : bleu foncé (niveaux 1-4)
      'rgba(199,21,133,0.15)',  // atmosphère 1 : magenta foncé (niveaux 5-9)
      'rgba(186,85,211,0.15)',   // atmosphère 2 : violet (niveaux 10-14)
      'rgba(220,20,60,0.15)',    // atmosphère 3 : rouge foncé (niveaux 15-19)
      'rgba(255,140,0,0.15)',    // atmosphère 4 : orange (niveaux 20-24)
      'rgba(50,205,50,0.15)',    // atmosphère 5 : vert (niveaux 25-29)
      'rgba(154,205,50,0.15)',   // atmosphère 6 : vert-jaune (niveaux 30-34)
      'rgba(255,255,0,0.15)',    // atmosphère 7 : jaune (niveaux 35-39)
      'rgba(138,43,226,0.15)',   // atmosphère 8 : violet foncé (niveaux 40-44)
      'rgba(255,0,0,0.15)'       // atmosphère 9 : rouge vif (niveaux 45+)
    ];
    
    // Transition smooth immédiate - plus de setTimeout
    boardCanvas.style.borderColor = atmosphereColors[atmosphereIndex];
  }
}

let hardDropEffect = null; // {t,duration,xs:[],ys:[],color}
function hardDrop(){
  if(!cur) return;
  let dist=0; while(!collides(cur,0,1)){ cur.y++; dist++; }
  playSfx('drop');
  // enregistrer positions des blocs pour effet
  const cells=[]; for(let r=0;r<4;r++) for(let c=0;c<4;c++) if(cur.shape[r][c]){ const x=cur.x+c, y=cur.y+r; if(y>=0) cells.push({x,y}); }
  const color = COLORS[cur.type];
  hardDropEffect = { t:0, duration:300, cells, color, dist };
  lockPiece();
  if(isDuoMode) publishDuoState();
}
// Rotation SRS (Standard) avec wall-kicks
// Tables d'offsets pour JLSTZ et I (sens horaire uniquement ici)
function getSRSOffsets(type, from, to){
  // normaliser 0,1,2,3
  from = ((from%4)+4)%4; to = ((to%4)+4)%4;
  // JLSTZ
  const JLSTZ = {
    '0>1': [[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]],
    '1>0': [[0,0],[1,0],[1,-1],[0,2],[1,2]],
    '1>2': [[0,0],[1,0],[1,-1],[0,2],[1,2]],
    '2>1': [[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]],
    '2>3': [[0,0],[1,0],[1,1],[0,-2],[1,-2]],
    '3>2': [[0,0],[-1,0],[-1,-1],[0,2],[-1,2]],
    '3>0': [[0,0],[1,0],[1,1],[0,-2],[1,-2]],
    '0>3': [[0,0],[-1,0],[-1,-1],[0,2],[-1,2]],
  };
  // I piece
  const I = {
    '0>1': [[0,0],[-2,0],[1,0],[-2,-1],[1,2]],
    '1>0': [[0,0],[2,0],[-1,0],[2,1],[-1,-2]],
    '1>2': [[0,0],[-1,0],[2,0],[-1,2],[2,-1]],
    '2>1': [[0,0],[1,0],[-2,0],[1,-2],[-2,1]],
    '2>3': [[0,0],[2,0],[-1,0],[2,1],[-1,-2]],
    '3>2': [[0,0],[-2,0],[1,0],[-2,-1],[1,2]],
    '3>0': [[0,0],[1,0],[-2,0],[1,-2],[-2,1]],
    '0>3': [[0,0],[-1,0],[2,0],[-1,2],[2,-1]],
  };
  const key = `${from}>${to}`;
  if(type==='I') return I[key] || [[0,0]];
  return JLSTZ[key] || [[0,0]];
}

function rotatePiece(){
  if(!cur) return;
  // On laisse la pièce O inchangée (pas de rotation nécessaire visuellement)
  if(cur.type === 'O') return;
  const from = cur.rotIndex % 4;
  const to = (from + 1) % 4; // rotation horaire
  const nextShape = cur.rots && cur.rots[to] ? cur.rots[to] : null;
  if(!nextShape) return;
  const offsets = getSRSOffsets(cur.type, from, to);
  for(const [ox, oy] of offsets){
    if(!collides(cur, ox, oy, nextShape)){
      cur.rotIndex = to;
      cur.shape = nextShape;
      cur.x += ox;
      cur.y += oy;
      playSfx('rotate');
      if(isDuoMode) publishDuoState();
      return;
    }
  }
}
function movePiece(dx,dy){ if(!cur) return false; if(!collides(cur,dx,dy)){ cur.x += dx; cur.y += dy; if(isDuoMode) publishDuoState(); return true; } return false; }

// main loop
function loop(now=0){ if(!running) return; if(pauseOpen) { requestAnimationFrame(loop); return; }
  const dt = now - lastTime; lastTime = now; lastDrop += dt;
  const sweeping = processSweeps(dt);
  if(!sweeping){
  if(lastDrop > dropInterval){ lastDrop = 0; if(!movePiece(0,1)) { lockPiece(); } }
  } else {
    // during sweep animation: do not fall; when sweep ends, respawn if needed
  }
  if(!sweeps.length && !cur){ spawn(); }
  updateParticles(); updateClearEffect(dt);
  drawBoard(); drawParticles(); drawClearEffectOverlay(); drawHardDropEffect(); requestAnimationFrame(loop); }

// game over
function onGameOver(){
  running = false;
  stopMusic();
  if(isDuoMode){
    // Pas d'overlay plein écran: on grise le board (fait dans drawBoard) et on affiche le texte directement dans la zone de jeu
    // Ne pas arrêter le chrono en Duo: il continue de tourner
    // Continuer d'afficher l'adversaire grâce au mini plateau
    // On publie aussi l'état KO
  // Mémoriser le timestamp de fin local (basé sur l’horloge) et publier
  try{ if(!duoLocal.finishedAt) duoLocal.finishedAt = Date.now(); if(typeof window!=='undefined') window.duoFinishedAt = duoLocal.finishedAt; }catch{}
  try{ publishDuoState(); }catch{}
  // Redessiner le plateau local en mode grisé
  drawBoard();
    // Dessiner 'GAME OVER' en rouge au centre du canvas
    try{
      ctx.save();
      ctx.fillStyle = '#ff3b3b';
      ctx.font = `900 ${Math.floor(BLOCK*1.4)}px Inter, system-ui, Arial`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.lineWidth = 6;
      ctx.strokeStyle = 'rgba(0,0,0,0.55)';
      ctx.strokeText('GAME OVER', boardCanvas.width/2, boardCanvas.height/2);
      ctx.fillText('GAME OVER', boardCanvas.width/2, boardCanvas.height/2);
      ctx.restore();
    }catch{}
  // Plus d'affichage immédiat - on attend que les deux joueurs aient fini
  console.log('Duo game over - local player finished, waiting for remote...');
  return;
  }
  const overlay = document.getElementById('gameOverOverlay'); overlay.style.display='flex'; const goText = document.getElementById('gameOverText');
  // restart animation
  goText.style.opacity = 0; void goText.offsetWidth; goText.style.opacity = 1;
  const replayBtn = document.getElementById('replayBtn');
  // snapshot niveau avant éventuelle modification
  const finalLevel = level;
  const finalScore = score;
  // maj stats overlay
  const st = document.getElementById('gameOverStats');
  if(st){
    const sEl = document.getElementById('goScore'); if(sEl) sEl.textContent = finalScore;
    const lEl = document.getElementById('goLevel'); if(lEl) lEl.textContent = finalLevel+1;
    const liEl = document.getElementById('goLines'); if(liEl) liEl.textContent = lines;
    requestAnimationFrame(()=>{ st.style.opacity = 1; st.style.transform='translateY(0)'; });
  }
  const menuBtn = document.getElementById('menuBtnFromGO');
  if(menuBtn){ menuBtn.onclick = ()=>{ overlay.style.display='none'; showMenu(); } }
  if(replayBtn){ replayBtn.onclick = (ev)=>{ ev.stopPropagation(); overlay.style.display='none';
      try{ clearNextPreviews(); }catch{}
      startGameFromMenu();
    } }
  // tentative d’enregistrement du score
  submitScoreToLeaderboard(finalScore, finalLevel).catch(()=>{});
}

// keyboard bindings: default WASD
let bindings = JSON.parse(localStorage.getItem('tetris_bindings')||'null') || { left:'KeyA', right:'KeyD', rotate:'KeyW', down:'KeyS', hardDrop:'Space', pause:'KeyP', restart:'KeyR' };

// keyboard handler
window.addEventListener('keydown', (e)=>{ if(e.repeat && e.code !== bindings.down) return;
  // Menu visible -> seules certaines touches utiles
  if(menuScreen.style.display !== 'none'){ // on est au menu
    if(typeof waitingFor === 'string' && waitingFor){ e.preventDefault(); const code = e.code==='Space' ? 'Space' : e.code; bindings[waitingFor] = code; localStorage.setItem('tetris_bindings', JSON.stringify(bindings)); const rf = (window.refreshKeyFields||null); if(rf) rf(); waitingFor = null; return; }
    if(e.code === 'Enter' || e.code === 'Space'){
      const btn = document.getElementById('startGameBtn'); if(btn) btn.click();
    }
    return;
  }
  // Input capture for remapping
  if(typeof waitingFor === 'string' && waitingFor){ e.preventDefault(); const code = e.code==='Space' ? 'Space' : e.code; bindings[waitingFor] = code; localStorage.setItem('tetris_bindings', JSON.stringify(bindings)); const rf = (window.refreshKeyFields||null); if(rf) rf(); waitingFor = null; return; }
  // In-game
  if(pauseOpen){ 
    // Si la modal de confirmation est ouverte, la fermer d'abord
    if(quitConfirmModal.classList.contains('show')) {
      if(e.code==='KeyP' || e.code==='Escape'){ 
        hideQuitConfirmModal(); 
        hidePause(); 
      }
    } else {
      if(e.code==='KeyP' || e.code==='Escape'){ hidePause(); }
    }
    return; 
  }
  if(!running) return;
  if(e.code === bindings.left) movePiece(-1,0);
  else if(e.code === bindings.right) movePiece(1,0);
  else if(e.code === bindings.down) movePiece(0,1);
  else if(e.code === bindings.rotate) rotatePiece();
  else if(e.code === bindings.hardDrop){ e.preventDefault(); hardDrop(); }
  else if(e.code === bindings.pause){ togglePause(); }
});

// touch controls
function hookTouch(id,fn){ const el=document.getElementById(id); if(!el) return; el.addEventListener('touchstart',(ev)=>{ ev.preventDefault(); fn(); }); el.addEventListener('mousedown',(ev)=>{ ev.preventDefault(); fn(); }); }

// Fonction spéciale pour le hold (maintenir appuyé)
function hookTouchHold(id, fn, interval = 150) {
  const el = document.getElementById(id);
  if (!el) return;
  
  let holdTimer = null;
  let isHolding = false;
  
  const startHold = (ev) => {
    ev.preventDefault();
    if (isHolding) return;
    isHolding = true;
    fn(); // Premier appel immédiat
    holdTimer = setInterval(fn, interval);
  };
  
  const stopHold = (ev) => {
    if (ev) ev.preventDefault();
    isHolding = false;
    if (holdTimer) {
      clearInterval(holdTimer);
      holdTimer = null;
    }
  };
  
  el.addEventListener('touchstart', startHold);
  el.addEventListener('mousedown', startHold);
  el.addEventListener('touchend', stopHold);
  el.addEventListener('mouseup', stopHold);
  el.addEventListener('touchcancel', stopHold);
  el.addEventListener('mouseleave', stopHold);
}

// Gestionnaire des nouveaux contrôles mobiles
function setupMobileControls(){
  hookTouch('mLeft', ()=>{ if(running && !pauseOpen) movePiece(-1,0); });
  hookTouch('mRight', ()=>{ if(running && !pauseOpen) movePiece(1,0); });
  hookTouch('mRotate', ()=>{ if(running && !pauseOpen) rotatePiece(); });
  hookTouchHold('mDown', ()=>{ if(running && !pauseOpen) movePiece(0,1); }, 100); // Hold avec interval de 100ms
  hookTouch('mDrop', ()=>{ if(running && !pauseOpen) hardDrop(); });
  // Désactivé en Duo: pas de pause; sur solo on garde la touche P mais on ne mappe plus le bouton mobile explicitement
  const pbtn = document.getElementById('pauseBtn');
  if(pbtn){
    pbtn.addEventListener('click', (ev)=>{ ev.preventDefault(); if(running && !isDuoMode) togglePause(); });
    pbtn.addEventListener('touchstart', (ev)=>{ ev.preventDefault(); if(running && !isDuoMode) togglePause(); });
  }
}

// Initialiser les contrôles mobiles
document.addEventListener('DOMContentLoaded', setupMobileControls);

// UI bindings: menu <-> game
const menuScreen = document.getElementById('menuScreen');
const gameScreen = document.getElementById('gameScreen');
const pauseOverlay = document.getElementById('pauseOverlay');
const pauseContinueBtn = document.getElementById('pauseContinueBtn');
const pauseMenuBtn = document.getElementById('pauseMenuBtn');
const toggleMusicBtn = document.getElementById('toggleMusicBtn');
const toggleSfxBtn = document.getElementById('toggleSfxBtn');
const pauseAudioRow = document.getElementById('pauseAudioRow');
let pauseOpen = false;
function showPause(){
  if(isDuoMode) return; // pas de pause en duo
  pauseOpen = true; pauseOverlay.style.display='flex';
  // afficher boutons audio seulement mobile
  if(isMobile && pauseAudioRow){ pauseAudioRow.style.display='flex'; updateAudioToggleButtons(); }
  // pause musique sans réinitialiser
  if(audioEl && !audioEl.paused){ try{ audioEl.pause(); audioEl._wasPlaying = true; }catch(e){} }
  
  // Ajouter l'écouteur pour fermer en cliquant en dehors du contenu
  setTimeout(() => {
    pauseOverlay.addEventListener('click', closePauseOnClickOutside);
  }, 100);
}
function hidePause(){
  if(isDuoMode) return; // pas de pause en duo
  pauseOpen = false; pauseOverlay.style.display='none';
  if(isMobile && pauseAudioRow){ pauseAudioRow.style.display='none'; }
  // reprendre musique si elle jouait
  if(audioEl && audioEl._wasPlaying && musicOn){ try{ audioEl.play(); }catch(e){} audioEl._wasPlaying=false; }
  
  // Retirer l'écouteur de clic en dehors
  pauseOverlay.removeEventListener('click', closePauseOnClickOutside);
}

function closePauseOnClickOutside(event) {
  // Vérifier si le clic est en dehors du contenu du modal de pause
  const pauseContent = event.target.closest('div[style*="background:linear-gradient(180deg,#0a1822,#07141b)"]');
  if (!pauseContent) {
    hidePause(); // Reprendre le jeu
  }
}
function togglePause(){ if(!running) return; if(isDuoMode) return; pauseOpen ? hidePause() : showPause(); }
if(pauseContinueBtn) pauseContinueBtn.addEventListener('click', ()=>{ hidePause(); });
if(pauseMenuBtn) pauseMenuBtn.addEventListener('click', ()=>{ showQuitConfirmModal(); });

// Modal de confirmation pour quitter
const quitConfirmModal = document.getElementById('quitConfirmModal');
const quitContinueBtn = document.getElementById('quitContinue');
const quitConfirmBtn = document.getElementById('quitConfirm');

function showQuitConfirmModal() {
  if (!running) return; // Jeu déjà arrêté

  // Si aucun point encore (score==0), pas de confirmation: retour direct menu
  if (score <= 0) {
    if (pauseOpen) hidePause(); // fermer pause si ouverte
    showMenu();
    return;
  }

  // Mettre à jour les stats dans la modal (partie avancée seulement si score>0)
  const qs = document.getElementById('quitScore'); if(qs) qs.textContent = score;
  const ql = document.getElementById('quitLevel'); if(ql) ql.textContent = level + 1;
  const qlignes = document.getElementById('quitLines'); if(qlignes) qlignes.textContent = lines;

  quitConfirmModal.classList.add('show');
}

function hideQuitConfirmModal() {
  quitConfirmModal.classList.remove('show');
}

function saveResultAndQuit() {
  // Sauvegarder le résultat actuel avant de quitter
  const finalScore = score;
  const finalLevel = level;
  
  // Soumettre le score au leaderboard (même logique que dans onGameOver)
  submitScoreToLeaderboard(finalScore, finalLevel).catch(() => {});
  
  // Cacher la modal, fermer la pause et aller au menu
  hideQuitConfirmModal();
  hidePause();
  showMenu();
}

// Event listeners pour la modal de confirmation
if(quitContinueBtn) quitContinueBtn.addEventListener('click', () => {
  hideQuitConfirmModal();
  hidePause(); // Reprendre le jeu
});

if(quitConfirmBtn) quitConfirmBtn.addEventListener('click', saveResultAndQuit);

// Fermer la modal en cliquant en dehors
quitConfirmModal.addEventListener('click', (e) => {
  if (e.target === quitConfirmModal) {
    hideQuitConfirmModal();
    hidePause(); // Reprendre le jeu
  }
});

function updateAudioToggleButtons(){
  if(toggleMusicBtn) toggleMusicBtn.textContent = 'Musique: ' + (musicOn? 'ON':'OFF');
  if(toggleSfxBtn) toggleSfxBtn.textContent = 'SFX: ' + (sfxOn? 'ON':'OFF');
  if(toggleMusicBtn) toggleMusicBtn.style.background = musicOn? 'linear-gradient(135deg,#064758,#0b6b85)':'rgba(255,255,255,0.07)';
  if(toggleSfxBtn) toggleSfxBtn.style.background = sfxOn? 'linear-gradient(135deg,#064758,#0b6b85)':'rgba(255,255,255,0.07)';
}
if(toggleMusicBtn){
  toggleMusicBtn.addEventListener('click', ()=>{
    musicOn = !musicOn;
    if(musicOn){ ensureAudio(); startMusic(); } else { stopMusic(); }
    updateAudioToggleButtons();
  });
}
if(toggleSfxBtn){
  toggleSfxBtn.addEventListener('click', ()=>{
    sfxOn = !sfxOn;
    updateAudioToggleButtons();
  });
}

// Menu pages (no tabs): show/hide pages
const menuPages = {
  home: document.getElementById('tab-home'),
  help: document.getElementById('tab-help'),
  settings: document.getElementById('tab-settings'),
  leaderboard: document.getElementById('tab-leaderboard'),
};
function showMenuPage(name){
  // Masquer toutes les pages du menu et retirer la classe active
  Object.values(menuPages).forEach(el=>{
    if(el) {
      el.style.display='none';
      el.classList.remove('active');
    }
  });
  
  // Afficher la page demandée et ajouter la classe active
  if(menuPages[name]){
    menuPages[name].style.display = 'flex';
    menuPages[name].classList.add('active');
    if(window.refreshTitleLayouts){
      // recalcul initial
      setTimeout(()=>refreshTitleLayouts(),40);
      // recalcul après stabilisation (padding/marges)
      setTimeout(()=>refreshTitleLayouts(),180);
      // second passage après éventuel scroll bar apparition
      setTimeout(()=>refreshTitleLayouts(),400);
    }
  }
}

// Primary buttons
document.getElementById('startGameBtn').addEventListener('click', ()=>{ startGameFromMenu(); });
const duoBtn = document.getElementById('duoGameBtn');
if(duoBtn){
  duoBtn.addEventListener('click', ()=>{
    document.getElementById('duoWaitOverlay').style.display = 'flex';
    
    // Initialiser la connexion duo avec Supabase
    handleDuoConnection();
    
    // Animation points
    let dots = 0;
    const dotsEl = document.getElementById('duoWaitDots');
    if(dotsEl){
      clearInterval(window._duoDotsIntv);
      window._duoDotsIntv = setInterval(()=>{
        dots = (dots+1)%4;
        dotsEl.textContent = '.'.repeat(dots);
      }, 500);
    }
    // Animation carrousel cubes améliorée
    const colors = [
      '#FFD166', // jaune
      '#1FB6FF', // bleu
      '#2BD4A4', // vert
      '#FF6B6B', // rouge
      '#9B5DE5'  // violet
    ];
    const animWrap = document.getElementById('duoWaitAnim');
    if(animWrap){
      animWrap.innerHTML = '';
      let pos = 0;
      let cubes = [];
      const cubeSize = 20;
      const spacing = 24;
      const centerOffset = -((4-1)*spacing)/2; // Centre les 4 cubes

      for(let i=0;i<4;i++){
        const div = document.createElement('div');
        div.className = 'duoCube';
        div.style.width = cubeSize + 'px';
        div.style.height = cubeSize + 'px';
        div.style.background = colors[(pos+i)%5];
        div.style.borderRadius = '5px';
        div.style.position = 'absolute';
        div.style.left = '50%';
        div.style.top = '50%';
        div.style.transition = 'transform .65s cubic-bezier(.4,.8,.3,1), opacity .4s ease';
        div.style.opacity = '1';
        div.style.transform = `translate(-50%, -50%) translateX(${centerOffset + i*spacing}px)`;
        div.style.zIndex = 1;
        animWrap.appendChild(div);
        cubes.push(div);
      }

      let isMoving = false;
      clearInterval(window._duoCubeIntv);

      function animateCarousel(){
        if(isMoving) return;
        isMoving = true;

        // Le dernier cube (index 3) disparaît en se déplaçant vers la droite
        cubes[3].style.opacity = '0';
        cubes[3].style.transform = `translate(-50%, -50%) translateX(${centerOffset + 4*spacing}px) scale(0.7)`;

        // Déplacement fluide des cubes 0 et 2 vers la droite
        cubes[0].style.transform = `translate(-50%, -50%) translateX(${centerOffset + 1*spacing}px)`;
        cubes[2].style.transform = `translate(-50%, -50%) translateX(${centerOffset + 3*spacing}px)`;

        // Rotation simple du cube 1 de la case 2 à la case 3
        cubes[1].style.zIndex = 10;
        cubes[1].style.transition = 'transform .6s cubic-bezier(.4,.8,.3,1), opacity .4s ease';
        cubes[1].style.transform = `translate(-50%, -50%) translateX(${centerOffset + 2*spacing}px) rotate(180deg)`;

        // Pas de setTimeout nécessaire, juste la rotation fluide

        setTimeout(()=>{
          // Mise à jour des positions et couleurs (recule pour faire avancer visuellement)
          pos = (pos-1+5)%5;

          // Réorganise l'ordre des cubes (le dernier sort, nouveau arrive au début)
          const exitedCube = cubes.pop();
          cubes.unshift(exitedCube);

          // Reset toutes les transitions et positions
          for(let i=0;i<4;i++){
            cubes[i].style.transition = 'none';
            cubes[i].style.background = colors[(pos+i)%5];
            cubes[i].style.opacity = '1';
            cubes[i].style.transform = `translate(-50%, -50%) translateX(${centerOffset + i*spacing}px)`;
            cubes[i].style.zIndex = 1;
          }

          // Animation d'entrée du nouveau cube (vient de la gauche)
          cubes[0].style.opacity = '0';
          cubes[0].style.transform = `translate(-50%, -50%) translateX(${centerOffset - 1*spacing}px) scale(0.7)`;

          setTimeout(()=>{
            cubes[0].style.transition = 'transform .5s cubic-bezier(.4,.8,.3,1), opacity .4s ease';
            cubes[0].style.opacity = '1';
            cubes[0].style.transform = `translate(-50%, -50%) translateX(${centerOffset}px) scale(1)`;

            // Remettre la transition normale pour tous
            setTimeout(()=>{
              for(let i=0;i<4;i++){
                cubes[i].style.transition = 'transform .65s cubic-bezier(.4,.8,.3,1), opacity .4s ease';
              }
              isMoving = false;
            }, 100);
          }, 50);
        }, 700);
      }

      window._duoCubeIntv = setInterval(animateCarousel, 1800);
    }
    // Texte visible
    const duoWaitStatus = document.getElementById('duoWaitStatus');
    if(duoWaitStatus) duoWaitStatus.style.display = '';
    const duoWaitCount = document.getElementById('duoWaitCount');
    if(duoWaitCount) duoWaitCount.style.display = '';
  });
}

const duoBackBtn = document.getElementById('duoBackBtn');
if(duoBackBtn){
  duoBackBtn.addEventListener('click', ()=>{
    // Masque l'overlay d'attente duo
    document.getElementById('duoWaitOverlay').style.display = 'none';
    // Nettoyer la connexion Supabase
    if(window.duoConnectionId) {
      cleanupDuoConnection();
    }
  });
}

// Fonction pour nettoyer la connexion duo
async function cleanupDuoConnection() {
  // Cette fonction sera redéfinie dans le module Supabase
  if(window.supabaseCleanupDuo) {
    await window.supabaseCleanupDuo();
  }
}

// Fonction principale pour gérer la connexion duo
async function handleDuoConnection() {
  // Cette fonction sera redéfinie dans le module Supabase
  if(window.supabaseHandleDuo) {
    await window.supabaseHandleDuo();
  }
}
document.getElementById('backBtn').addEventListener('click', ()=>{ 
  if(isDuoMode) return; // Pas de retour en Duo
  // Si le jeu est en cours, afficher la modal de confirmation
  if(running) {
    showQuitConfirmModal();
  } else {
    showMenu();
  }
});

// Nettoyage duo best-effort à la fermeture de l'onglet
try{
  window.addEventListener('beforeunload', (e)=>{
    try{
      // Utiliser l'implémentation locale si présente (module supabase)
      if(typeof cleanupDuoConnection === 'function'){
        // Best effort sans await (évite de bloquer la fermeture)
        cleanupDuoConnection();
      } else if(window.supabaseCleanupDuo){
        window.supabaseCleanupDuo();
      }
    }catch{}
    // Pas de e.preventDefault() pour ne pas bloquer
  });
}catch{}
const helpBtn = document.getElementById('helpBtn');
const settingsBtn = document.getElementById('settingsBtn');
const helpBackBtn = document.getElementById('helpBackBtn');
const settingsBackBtn = document.getElementById('settingsBackBtn');
const leaderboardBtn = document.getElementById('leaderboardBtn');
if(helpBtn){ helpBtn.addEventListener('click', ()=>{ showMenuPage('help'); }); }
if(settingsBtn){ settingsBtn.addEventListener('click', ()=>{ showMenuPage('settings'); }); }
if(helpBackBtn){ helpBackBtn.addEventListener('click', ()=>{ showMenuPage('home'); }); }
if(settingsBackBtn){ settingsBackBtn.addEventListener('click', ()=>{ showMenuPage('home'); }); }
if(leaderboardBtn){ leaderboardBtn.addEventListener('click', ()=>{ showMenuPage('leaderboard'); fetchLeaderboard(); }); }
// Pause desktop
const pauseBtnDesktop = document.getElementById('pauseBtnDesktop');
// Bouton pause desktop supprimé

// Switch leaderboard solo/duo
const lbTabSolo = document.getElementById('lbTabSolo');
const lbTabDuo = document.getElementById('lbTabDuo');
const lbSoloPanel = document.getElementById('lbSoloPanel');
const lbDuoPanel = document.getElementById('lbDuoPanel');
if(lbTabSolo && lbTabDuo && lbSoloPanel && lbDuoPanel){
  lbTabSolo.addEventListener('click', ()=>{
    lbTabSolo.style.background = '#1FB6FF';
    lbTabSolo.style.color = '#fff';
    lbTabDuo.style.background = '#ff6b6b22';
    lbTabDuo.style.color = '#ff6b6b';
    lbSoloPanel.style.display = '';
    lbDuoPanel.style.display = 'none';
  });
  lbTabDuo.addEventListener('click', ()=>{
    lbTabSolo.style.background = '#1FB6FF22';
    lbTabSolo.style.color = '#1FB6FF';
    lbTabDuo.style.background = '#ff6b6b';
    lbTabDuo.style.color = '#fff';
    lbSoloPanel.style.display = 'none';
    lbDuoPanel.style.display = '';
  });
  // Par défaut solo actif
  lbTabSolo.style.background = '#1FB6FF';
  lbTabSolo.style.color = '#fff';
  lbTabDuo.style.background = '#ff6b6b22';
  lbTabDuo.style.color = '#ff6b6b';
  lbSoloPanel.style.display = '';
  lbDuoPanel.style.display = 'none';
}

// Settings: key rebinding
function codeToLabel(code){ if(code==='Space') return 'Espace'; return code.replace('Key',''); }
const keyFields = {
  left: document.getElementById('keyLeft'),
  right: document.getElementById('keyRight'),
  rotate: document.getElementById('keyRotate'),
  down: document.getElementById('keyDown'),
  hardDrop: document.getElementById('keyDrop'),
  pause: document.getElementById('keyPause'),
};
window.refreshKeyFields = function(){ if(!keyFields.left) return; keyFields.left.value = codeToLabel(bindings.left); keyFields.right.value = codeToLabel(bindings.right); keyFields.rotate.value = codeToLabel(bindings.rotate); keyFields.down.value = codeToLabel(bindings.down); keyFields.hardDrop.value = codeToLabel(bindings.hardDrop); keyFields.pause.value = codeToLabel(bindings.pause); };
window.refreshKeyFields();
let waitingFor = null;
Object.entries(keyFields).forEach(([name, input])=>{
  if(!input) return;
  input.addEventListener('click', ()=>{ waitingFor = name; input.value = '...'; input.focus(); });
});
const saveSettingsBtn = document.getElementById('saveSettingsBtn');
if(saveSettingsBtn){ saveSettingsBtn.addEventListener('click', ()=>{
  localStorage.setItem('tetris_bindings', JSON.stringify(bindings));
  saveSettingsBtn.innerText = 'Enregistré ✔';
  setTimeout(()=>{ saveSettingsBtn.innerText='Enregistrer'; }, 1200);
}); }
const resetBindingsBtn = document.getElementById('resetBindingsBtn');
if(resetBindingsBtn){ resetBindingsBtn.addEventListener('click', ()=>{
  bindings = { left:'KeyA', right:'KeyD', rotate:'KeyW', down:'KeyS', hardDrop:'Space', pause:'KeyP', restart:'KeyR' };
  localStorage.setItem('tetris_bindings', JSON.stringify(bindings));
  refreshKeyFields();
}); }

// Préférence contrôles tactiles
const touchToggle = document.getElementById('toggleTouchControls');
if(touchToggle){
  // Initialiser état
  const pref = localStorage.getItem('tetris_touch_controls');
  if(pref === null){
    // auto -> ne coche pas forcément, on affiche mobile par logique mais laisse case refléter l'état effectif (donc coché si auto-mobile)
    const ua = navigator.userAgent.toLowerCase();
    const isMobile = /iphone|ipad|ipod|android|mobile/.test(ua) || ('ontouchstart' in window && window.innerWidth <= 900);
    touchToggle.checked = isMobile;
  } else {
    touchToggle.checked = (pref === '1');
  }
  touchToggle.addEventListener('change', ()=>{
    localStorage.setItem('tetris_touch_controls', touchToggle.checked? '1':'0');
    // Appliquer immédiatement uniquement si une partie est en cours
    if(typeof running !== 'undefined' && running){
      const mtcEl = document.getElementById('mobileTouchControls');
      if(mtcEl){
        mtcEl.style.display = 'block';
        const groups = [
          document.getElementById('touchLeftWrap'),
          document.getElementById('touchRightWrap'),
          document.getElementById('touchBottomWrap')
        ];
        groups.forEach(g=>{ if(g) g.style.display = touchToggle.checked? 'flex':'none'; });
        // pauseBtn reste visible
        const pauseBtn = document.getElementById('pauseBtn');
        if(pauseBtn) pauseBtn.style.display = 'flex';
      }
    }
  });
}

// Default menu page
showMenuPage('home');

function startGameFromMenu(){ 
  dinfo('Start new game');
  
  // ARRÊT TOTAL de toute activité précédente
  running = false;

  // Masquer/Reset les overlays de fin si présents (solo/duo)
  try{ const go = document.getElementById('gameOverOverlay'); if(go) go.style.display='none'; }catch{}
  try{ const dres = document.getElementById('duoResultOverlay'); if(dres) dres.style.display='none'; }catch{}
  // Reset des drapeaux de synchronisation du modal Duo pour permettre un nouvel affichage
  try{ duoResultShown = false; }catch{}
  try{ duoResultScheduled = false; }catch{}
  try{ duoResultTargetAt = null; }catch{}
  try{ duoResultBroadcasted = false; }catch{}
  try{ duoScoreSubmitted = false; }catch{}
  // Purger les timestamps de fin Duo de la partie précédente
  try{ if(typeof duoLocal !== 'undefined'){ duoLocal.finishedAt = null; duoLocal.elapsedSec = null; } }catch{}
  try{ if(typeof duoRemote !== 'undefined'){ duoRemote.finishedAt = null; duoRemote.elapsedSec = null; } }catch{}
  
  // RESET COMPLET de l'état
  resetGrid();
  sweeps.length = 0; 
  particles.length = 0; 
  lastClearedRows = [];
  clearEffect = null; 
  hardDropEffect = null;
  combo = 0; 
  lines = 0; 
  level = 0; 
  score = 0;
  changeAtmosphere(0);
  
  // RESET TOTAL des pièces - TRÈS IMPORTANT
  bag = [];
  nextQueue = [];
  cur = null;
  
  dlog('State reset');
  
  // Remise à zéro UI (desktop + mobile)
  const sEl = document.getElementById('score'); if(sEl) sEl.innerText = 0;
  const lEl = document.getElementById('level'); if(lEl) lEl.innerText = 1;
  const liEl = document.getElementById('lines'); if(liEl) liEl.innerText = 0;
  const ms = document.getElementById('mobileScore'); if(ms) ms.innerText = 0;
  const ml = document.getElementById('mobileLevel'); if(ml) ml.innerText = 1;
  const mli = document.getElementById('mobileLines'); if(mli) mli.innerText = 0;
  
  // NETTOYAGE TOTAL des previews AVANT de remplir la queue
  clearNextPreviews();
  
  // REMPLIR la queue avec de NOUVELLES pièces
  fillQueue();
  dlog('Queue filled:', nextQueue.map(p => p?.type));
  
  // PREMIER spawn
  spawn(); 
  dlog('After spawn:', nextQueue.map(p => p?.type));
  
  // PREMIER dessin
  try { drawBoard(); } catch(e) { console.error('drawBoard error:', e); }

  // AFFICHAGE de l'écran de jeu
  menuScreen.style.display = 'none';
  gameScreen.style.display = 'flex';
  
  // FORCE le rendu des previews après affichage
  setTimeout(() => {
  dlog('Force previews after display');
    forceRenderPreviews();
  }, 50);

  // DÉMARRAGE du jeu
  running = true;
  lastTime = performance.now();
  lastDrop = 0;
  ensureAudio();
  startMusic();
  pauseOpen = false;
  
  dinfo('Game started');
  // Afficher contrôles tactiles selon préférence
  const pref = localStorage.getItem('tetris_touch_controls');
  let show = false;
  if(pref === null){
    const ua = navigator.userAgent.toLowerCase();
    const isMobile = /iphone|ipad|ipod|android|mobile/.test(ua) || ('ontouchstart' in window && window.innerWidth <= 900);
    show = isMobile; // par défaut actif sur mobile
  } else {
    show = (pref === '1');
  }
  const mtcEl = document.getElementById('mobileTouchControls');
  if(mtcEl){
    // Toujours afficher le conteneur pour garder le bouton Pause
  mtcEl.style.display = 'block';
    const groups = [
      document.getElementById('touchLeftWrap'),
      document.getElementById('touchRightWrap'),
      document.getElementById('touchBottomWrap')
    ];
    groups.forEach(g=>{ if(g) g.style.display = show? 'flex':'none'; });
  const pauseBtn = document.getElementById('pauseBtn');
  if(pauseBtn) pauseBtn.style.display = isDuoMode? 'none' : 'flex';
  }
  // Si on vient du mode Duo, masquer le score
  if(isDuoMode){ applyDuoUiMode(true); }
  // Chrono duo (mm:ss)
  if(isDuoMode){
    const hud = document.getElementById('duoHudTop');
    if(hud){
      hud.style.display='block';
      // Utiliser startAt synchronisé si disponible
      const startTs = (typeof duoStartAt==='number' && duoStartAt) ? duoStartAt : Date.now();
      duoLocal.startAt = startTs;
      clearInterval(hud._intv); hud._intv = setInterval(()=>{
        // Si le joueur local a déjà perdu, figer le chrono sur son temps de défaite
        const now = Date.now();
        let effectiveNow = (duoLocal && duoLocal.finishedAt) ? duoLocal.finishedAt : now;
        // Si les deux ont fini, figer sur le max des deux (cas double KO)
        if(duoLocal && duoLocal.finishedAt && duoRemote && duoRemote.finishedAt){
          effectiveNow = Math.max(duoLocal.finishedAt, duoRemote.finishedAt);
        }
        const t = Math.max(0, Math.floor((effectiveNow - startTs)/1000));
        duoLocal.elapsedSec = t;
        const mm = String(Math.floor(t/60)).padStart(2,'0');
        const ss = String(t%60).padStart(2,'0');
        hud.textContent = `${mm}:${ss}`;
        // Arrêter la mise à jour si le local est KO (chrono figé pour le perdant)
        if(duoLocal && duoLocal.finishedAt && hud && hud._intv){ clearInterval(hud._intv); hud._intv = null; }
      }, 250);
    }
    const mini = document.getElementById('opponentMini'); if(mini) mini.style.display='block';
  } else {
    const hud = document.getElementById('duoHudTop'); if(hud){ hud.style.display='none'; clearInterval(hud._intv); }
    const mini = document.getElementById('opponentMini'); if(mini) mini.style.display='none';
  }
  requestAnimationFrame(loop);
}
function showMenu(){ // stop and return
  dlog('showMenu');
  
  running = false; stopMusic(); menuScreen.style.display='flex'; gameScreen.style.display='none'; const go = document.getElementById('gameOverOverlay'); if(go) go.style.display='none';
  // Cacher complètement l'overlay de contrôles mobiles au menu
  const mtc = document.getElementById('mobileTouchControls'); if(mtc) mtc.style.display='none';
  // Quitter le mode Duo UI si actif
  if(isDuoMode){ applyDuoUiMode(false); isDuoMode=false; }
  const hud = document.getElementById('duoHudTop'); if(hud){ hud.style.display='none'; clearInterval(hud._intv); }
  const mini = document.getElementById('opponentMini'); if(mini) mini.style.display='none';
  
  // Réinitialiser complètement le jeu
  score = 0; level = 0; lines = 0; combo = 0;
  resetGrid(); 
  
  // RESET COMPLET des pièces
  bag=[]; 
  nextQueue=[]; 
  cur=null; 
  sweeps.length=0; 
  particles.length=0; 
  clearEffect=null; 
  hardDropEffect=null;
  
  // Préviews nettoyés au menu pour éviter un état figé
  dlog('clear previews (menu)');
  try{ clearNextPreviews(); }catch{}
  
  // Update desktop UI
  document.getElementById('score').innerText = 0; 
  document.getElementById('level').innerText = 1; 
  document.getElementById('lines').innerText = 0;
  
  // Update mobile UI
  const mobileScore = document.getElementById('mobileScore');
  const mobileLevel = document.getElementById('mobileLevel');
  const mobileLines = document.getElementById('mobileLines');
  if(mobileScore) mobileScore.innerText = 0;
  if(mobileLevel) mobileLevel.innerText = 1;
  if(mobileLines) mobileLines.innerText = 0;
  
  // Réinitialiser l'atmosphère au menu
  changeAtmosphere(0);
}

// ===== Résultat Duo =====
function formatMmSsFromMs(ms){ const s = Math.max(0, Math.floor(ms/1000)); const mm=String(Math.floor(s/60)).padStart(2,'0'); const ss=String(s%60).padStart(2,'0'); return `${mm}:${ss}`; }
function getPlayerDisplayName(id){
  try{
    const s = id? String(id).toLowerCase() : '';
    if(s.includes('sanaa')) return 'Sanaa';
    if(s.includes('ben')) return 'Benjamin';
    if(s.includes('benjamin')) return 'Benjamin';
    return 'Joueur';
  }catch{ return 'Joueur'; }
}
function finalizeDuoResult(){
  // Afficher/mettre à jour le modal de résultat Duo UNIQUEMENT quand les deux joueurs ont fini.
  try{
    if(!(duoLocal && duoLocal.finishedAt && duoRemote && duoRemote.finishedAt)){
  dlog('finalizeDuoResult: wait both', {
        localFinished: !!(duoLocal && duoLocal.finishedAt),
        remoteFinished: !!(duoRemote && duoRemote.finishedAt)
      });
      return;
    }
    const overlay = document.getElementById('duoResultOverlay'); if(!overlay) return;
    // Masquer HUD Duo s'il existe
    const hud = document.getElementById('duoHudTop'); if(hud){ hud.style.display='none'; }
    // S'assurer que l'overlay est visible au moins une fois
    if(!duoResultShown){ overlay.style.display = 'flex'; duoResultShown = true; }
    // Initialiser UI rematch
    try{
      const rb0 = document.getElementById('duoReplayBtn');
      if(rb0){ rb0.textContent = 'Rejouer 0/2'; }
      // démarrer le polling si pas déjà actif, afin d’actualiser le compteur en temps réel côté deux joueurs
      if(!duoRematchLoop){ duoRematchLoop = setInterval(pollRematch, 700); }
    }catch{}
    // Calculer durées à partir du startAt sync
    const startTs = (duoLocal.startAt || duoRemote.startAt || duoStartAt || Date.now());
    const p1DurMs = Math.max(0, (duoLocal.finishedAt||Date.now()) - startTs);
    const p2DurMs = Math.max(0, (duoRemote.finishedAt||Date.now()) - startTs);
    // Vainqueur = celui qui a duré le plus longtemps
    const localName = getPlayerDisplayName(window?.duoPlayerId)||'Joueur 1';
    const remoteName = getPlayerDisplayName(duoRemote.id)||'Joueur 2';
    let winnerName = localName, loserName = remoteName;
    if(p2DurMs > p1DurMs){ winnerName = remoteName; loserName = localName; }
    const winTime = formatMmSsFromMs(Math.max(p1DurMs,p2DurMs));
    const loseTime = formatMmSsFromMs(Math.min(p1DurMs,p2DurMs));
    const wTitle = document.getElementById('duoWinnerTitle');
    if(wTitle){
      wTitle.innerHTML = `<span style="color:#2BD4A4">${winnerName}</span> gagne ! <span style="opacity:.85">(${winTime})</span>`;
    }
    // Badges et ordre
    const localBadge = document.getElementById('duoLocalBadge');
    const remoteBadge = document.getElementById('duoRemoteBadge');
    if(localBadge) localBadge.textContent = localName === winnerName ? 'Gagnant' : 'Perdant';
    if(remoteBadge) remoteBadge.textContent = remoteName === winnerName ? 'Gagnant' : 'Perdant';
    const localCard = document.getElementById('duoCardLocal');
    const remoteCard = document.getElementById('duoCardRemote');
    if(localCard && remoteCard){
      // Place le gagnant à gauche visuellement
      const container = localCard.parentElement;
      if(winnerName === remoteName){
        container.insertBefore(remoteCard, localCard);
      } else {
        container.insertBefore(localCard, remoteCard);
      }
    }
    // Renseigner panneaux
  const p1Name = document.getElementById('duoP1Name'); if(p1Name) p1Name.textContent = localName;
    const p1Time = document.getElementById('duoP1Time'); if(p1Time) p1Time.textContent = formatMmSsFromMs(p1DurMs);
    const p1Score = document.getElementById('duoP1Score'); if(p1Score) p1Score.textContent = String(score);
    const p1Level = document.getElementById('duoP1Level'); if(p1Level) p1Level.textContent = String(level);
    const p1Lines = document.getElementById('duoP1Lines'); if(p1Lines) p1Lines.textContent = String(lines);
    const rs = duoRemote.state || { score:0, level:1, lines:0 };
  const p2Name = document.getElementById('duoP2Name'); if(p2Name) p2Name.textContent = remoteName;
    const p2Time = document.getElementById('duoP2Time'); if(p2Time) p2Time.textContent = formatMmSsFromMs(p2DurMs);
    const p2Score = document.getElementById('duoP2Score'); if(p2Score) p2Score.textContent = String(rs.score||0);
    const p2Level = document.getElementById('duoP2Level'); if(p2Level) p2Level.textContent = String(rs.level||1);
    const p2Lines = document.getElementById('duoP2Lines'); if(p2Lines) p2Lines.textContent = String(rs.lines||0);
    // Afficher (ou garder visible) l'overlay
    overlay.style.display = 'flex';
    // Bind boutons
    const rb = document.getElementById('duoReplayBtn'); if(rb){ rb.onclick = async ()=>{
        // Toggle rematch_ready sur Supabase: un second clic annule la participation
        try{
          // Interroger notre ligne pour savoir si on est déjà rematch_ready
          const { data: myRows } = await supabase.from('duo_live').select('etat, data').eq('room_id', duoConnectionId).eq('joueur', duoPlayerId).maybeSingle();
          const alreadyReady = !!(myRows && myRows.etat === 'rematch_ready');
          if(alreadyReady){
            // Annuler la participation
            await supabase.from('duo_live').update({ etat:'waiting' }).eq('room_id', duoConnectionId).eq('joueur', duoPlayerId);
            duoRematchReadyLocal = false; duoIsRematch = false;
          } else {
            duoResultShown = false; duoScoreSubmitted = false; duoCountdownPinned = false; duoStarted = false; duoCountdownActive = false;
            duoLocal = { startAt:null, finishedAt:null, elapsedSec:null };
            duoRematchReadyLocal = true; duoRematchReadyRemote = false;
            duoIsRematch = true;
            // Nettoyer flags menu/rematch_block dans data sans écraser le reste
            let d = myRows && myRows.data ? (typeof myRows.data === 'string' ? JSON.parse(myRows.data) : myRows.data) : {};
            d.menu = false; d.rematch_block = false;
            await supabase.from('duo_live').update({ etat:'rematch_ready', data: d }).eq('room_id', duoConnectionId).eq('joueur', duoPlayerId);
          }
          if(duoRematchLoop){ clearInterval(duoRematchLoop); }
          // Rafraîchir tout de suite puis continuer à poller
          await pollRematch();
          duoRematchLoop = setInterval(pollRematch, 700);
        }catch(e){ console.warn('rematch ready error', e); }
      } }
  const mb = document.getElementById('duoMenuBtn'); if(mb){ mb.onclick = async ()=>{
        // Signaler qu'on quitte en désactivant rematch côté supabase et en posant un flag data.menu (merge sans écraser role/seed)
        try{
          const { data: cur } = await supabase.from('duo_live').select('data').eq('room_id', duoConnectionId).eq('joueur', duoPlayerId).maybeSingle();
          let d = cur && cur.data ? (typeof cur.data === 'string' ? JSON.parse(cur.data) : cur.data) : {};
          d.menu = true; d.rematch_block = true;
          await supabase.from('duo_live').update({ etat:'waiting', data: d }).eq('room_id', duoConnectionId).eq('joueur', duoPlayerId);
        }catch{}
    duoIsRematch = false;
        overlay.style.display='none'; showMenu();
      } }

    // Enregistrement en base duo_scores - uniquement si on est le gagnant et pas déjà soumis
    try{
      const bothFinished = !!(duoLocal.finishedAt && duoRemote.finishedAt);
  dinfo('[DUO] finalize -> winnerLocal=%s, bothFinished=%s, submitted=%s', (winnerName===localName), bothFinished, duoScoreSubmitted);
      if(!duoScoreSubmitted && winnerName === localName && bothFinished){
        duoScoreSubmitted = true;
        const winner = winnerName;
        // Temps en secondes pour la table (spécification: integer seconds)
        const secSanaa = (localName==='Sanaa'? Math.round(p1DurMs/1000) : (remoteName==='Sanaa'? Math.round(p2DurMs/1000) : null));
        const secBen = (localName==='Benjamin'? Math.round(p1DurMs/1000) : (remoteName==='Benjamin'? Math.round(p2DurMs/1000) : null));
        submitDuoScore({ gagnant: winner, temps_sanaa: secSanaa, temps_benjamin: secBen });

        // Enregistrer aussi le score du gagnant dans le leaderboard solo (tetris_scores) si disponible
        try{
          const lvlWinner = (localName===winnerName) ? level : (rs.level||1);
          const scoreWinner = (localName===winnerName) ? score : (rs.score||0);
          submitScoreToLeaderboard(scoreWinner, lvlWinner).catch(()=>{});
        }catch(_){ }
      } else {
  dlog('[DUO] skip insert (conditions non réunies)');
        // Fallback tardif: réessayer brièvement si l'info finishedAt distante arrive en retard
        setTimeout(()=>{
          try{
            const ready = !!(duoLocal.finishedAt && duoRemote.finishedAt);
            if(!duoScoreSubmitted && (winnerName===localName) && ready){
              duoScoreSubmitted = true;
              const secSanaa2 = (localName==='Sanaa'? Math.round(p1DurMs/1000) : (remoteName==='Sanaa'? Math.round(p2DurMs/1000) : null));
              const secBen2 = (localName==='Benjamin'? Math.round(p1DurMs/1000) : (remoteName==='Benjamin'? Math.round(p2DurMs/1000) : null));
              submitDuoScore({ gagnant: winnerName, temps_sanaa: secSanaa2, temps_benjamin: secBen2 });
            }
          }catch{}
        }, 1500);
      }
    }catch(_){ /* non bloquant */ }
  }catch(e){ console.warn('finalizeDuoResult error', e); }
  // Remettre l'état en 'waiting' après finalisation pour permettre le rematch simple
  try{ supabase.from('duo_live').update({ etat:'waiting' }).eq('room_id', duoConnectionId).eq('joueur', duoPlayerId); }catch{}
}

// Envoi d'un résultat Duo vers public.duo_scores
async function submitDuoScore(row){
  try{
    if(!window.supabase){ console.warn('Supabase indisponible'); return; }
    if(!row || !row.gagnant){ return; }
    const payload = {
      gagnant: String(row.gagnant).substring(0,64),
      temps_sanaa: (typeof row.temps_sanaa === 'number'? row.temps_sanaa : null),
      temps_benjamin: (typeof row.temps_benjamin === 'number'? row.temps_benjamin : null)
    };
  console.info('[DUO] insert duo_scores ->', payload);
  const { error } = await window.supabase.from('duo_scores').insert(payload);
  if(error){ console.warn('duo_scores insert error', error.message); }
  else { console.info('[DUO] duo_scores insert OK'); }
  }catch(e){ console.warn('submitDuoScore error', e); }
}

// mute buttons
// audio boutons desktop supprimés (uniquement dans pause mobile maintenant)

// next rendering
// (ancienne fonction renderNext supprimée - remplacée par version unifiée plus haut)

// init
resetGrid(); fillQueue(); spawn(); renderNext(); changeAtmosphere(0);

// Initialize mobile/desktop specific features
initPlatformSettings();
initMobileSettings();

// small helpers to expose/change keyboard mapping if needed later
window.tetrisSetBindings = function(newBindings){ bindings = Object.assign({}, bindings, newBindings); localStorage.setItem('tetris_bindings', JSON.stringify(bindings)); };



// Animation carrousel personnalisée du titre TETRIS
// Spécifications :
// - 4 cubes défilent (tapis roulant) autour du mot
// - Pause de 2s entre chaque rotation
// - Mouvement vers la droite: chaque cube avance d'une position, le dernier réapparaît à gauche
// - Le cube "au centre" (devant le mot) se dilate et sert de fond dynamique derrière le mot
// - Quand il quitte le centre il redevient un cube normal
// Implémentation: positionnement absolu avec interpolation transform; morph en pleine largeur du mot
function initTitleAnimation(){
  const titles = document.querySelectorAll('.tetrisTitle');
  titles.forEach(title=>{
    const word = title.querySelector('.tetrisWord');
    if(!word) return;
    let cubes = Array.from(title.querySelectorAll('.t')).filter(el=>!el.classList.contains('tetrisWord'));
    if(cubes.length!==5) return; // besoin de 5
    // On force le cube violet (bT) à être centre initial
    const violet = cubes.find(c=>c.classList.contains('bT'));
    if(violet){
      cubes = cubes.filter(c=>c!==violet);
      const midIndex = Math.floor(cubes.length/2);
      cubes.splice(midIndex,0,violet); // replacer au milieu de la liste
    }
    function computeLayout(){
      const rect = word.getBoundingClientRect();
      const titleRect = title.getBoundingClientRect();
      const wordWidth = rect.width;
      const startX = rect.left - titleRect.left; // position du mot
      const centerX = titleRect.width / 2; // centre global
      // Décalage encore plus marqué demandé
      let shiftLeft = Math.min(wordWidth * 0.54, 170); // léger plus
      // Sécurité : ne pas dépasser trop loin (laisser 40px avant le début du mot)
      if(centerX - shiftLeft < startX - 40){
        shiftLeft = centerX - (startX - 40);
      }
      const centerPos = centerX - shiftLeft;
      const gap = Math.max(30, Math.min(64, wordWidth*0.13)); // légère adaptation de l'espacement
      return {wordWidth,startX,gap,centerX,centerPos};
    }
    let layout = computeLayout();
    window.addEventListener('resize', ()=>{ layout = computeLayout(); placeInstant(); });
    let logical = cubes.map((el,i)=>({el,i})); // positions -2,-1,0,+1,+2
    const PAUSE=2000; const MOVE_DUR=700;
    let animating=false, paused=true;

    function posX(pos){ // pos ∈ {-2,-1,0,1,2}
      const {startX, gap, centerPos, wordWidth} = layout;
      if(pos===0) return centerPos;
      const wordRight = startX + wordWidth;
      const base = gap * 0.9; // rapproché
      const outerFactor = 1.85; // un peu moins large
      const globalShiftLeft = gap * 0.35; // décale tout vers la gauche
      if(pos>0){
        const offset = (pos===1? base : base*outerFactor);
        let x = wordRight + offset - globalShiftLeft;
        const minSpace = 8; // garder un léger espace
        if(x < wordRight + minSpace) x = wordRight + minSpace;
        return x;
      } else {
        const p = -pos;
        const offset = (p===1? base : base*outerFactor);
        let x = startX - offset - globalShiftLeft;
        return x;
      }
    }

    function morphCenter(el,instant){
      el.classList.add('bgMorph');
      const {wordWidth,centerPos} = layout;
      // Si page aide ou settings => autoriser un peu plus de largeur
      const parentPage = title.closest('.menuPage');
      // Encore moins large et un peu plus modeste
  const widenFactor = parentPage && (parentPage.id==='tab-help' || parentPage.id==='tab-settings') ? 1.055 : 1.045;
  const targetW = Math.min(wordWidth + 10, wordWidth * widenFactor);
      const targetH = Math.min(62, Math.max(44, wordWidth * 0.19));
      el.style.zIndex=0;
      if(instant){
        el.style.width=targetW+'px';
        el.style.height=targetH+'px';
        el.style.borderRadius='10px';
        el.style.transform = `translate(${centerPos}px,-50%)`;
      } else {
        el.style.transition='transform .7s cubic-bezier(.4,.85,.25,1),width .55s,height .55s,border-radius .55s';
        requestAnimationFrame(()=>{
          el.style.width=targetW+'px';
          el.style.height=targetH+'px';
          el.style.borderRadius='10px';
          el.style.transform = `translate(${centerPos}px,-50%)`;
        });
      }
    }
    function demorph(el){
      if(!el.classList.contains('bgMorph')) return;
      // on conserve une transition fluide pour width/height/border-radius
      el.classList.remove('bgMorph');
      el.style.transition = 'transform .65s cubic-bezier(.4,.85,.25,1), width .55s, height .55s, border-radius .55s, opacity .55s';
      requestAnimationFrame(()=>{
        el.style.width='16px';
        el.style.height='16px';
        el.style.borderRadius='5px';
        el.style.zIndex=1;
      });
    }
    function placeInstant(){
      logical.forEach((obj,index)=>{
        const pos = index-2; // map index 0..4 -> -2..2
        const {el}=obj; if(pos===0) morphCenter(el,true); else demorph(el);
        el.style.transition='none';
        el.style.opacity=1;
        el.style.transform = `translate(${posX(pos)}px,-50%)`;
      });
      requestAnimationFrame(()=>logical.forEach(o=>o.el.style.transition=''));
    }
    function step(){
      if(animating) return; animating=true; paused=false;
      // cube de droite (pos +2) disparaît (shrink + fade) SANS translation re-apparente
      const outgoing = logical[logical.length-1].el;
      outgoing.style.transition='transform .45s ease,opacity .45s ease';
      // figer sa position actuelle avant shrink
      const current = outgoing.getBoundingClientRect(); // (force layout)
      requestAnimationFrame(()=>{
        outgoing.style.opacity='0';
        outgoing.style.transform += ' scale(0.1)';
      });
      setTimeout(()=>{
        const moved = logical.pop();
        logical.unshift(moved);
        // réapparaît directement à gauche (pos -2) sans translation animée (seulement scale/opacity)
        const leftPos = posX(-2);
        moved.el.style.transition='none';
        demorph(moved.el);
        moved.el.style.opacity='0';
        moved.el.style.transform = `translate(${leftPos}px,-50%) scale(0.1)`;
        // forcer reflow
        void moved.el.offsetWidth;
        moved.el.style.transition='opacity .55s ease, transform .55s cubic-bezier(.4,.85,.25,1)';
        requestAnimationFrame(()=>{
          moved.el.style.opacity='1';
          moved.el.style.transform = `translate(${leftPos}px,-50%) scale(1)`;
        });
        // autres cubes se déplacent vers leur nouvelle position
        logical.forEach((obj,index)=>{
          const pos = index-2;
          if(obj.el===moved.el) return; // déjà positionné
          if(pos===0) morphCenter(obj.el,false); else if(obj.el.classList.contains('bgMorph')) demorph(obj.el);
          obj.el.style.transition = obj.el.classList.contains('bgMorph')
            ? 'transform .7s cubic-bezier(.4,.85,.25,1), width .55s, height .55s, border-radius .55s'
            : 'transform .65s cubic-bezier(.4,.85,.25,1), width .55s, height .55s, border-radius .55s';
          requestAnimationFrame(()=>{ obj.el.style.transform = `translate(${posX(pos)}px,-50%)`; });
        });
        setTimeout(()=>{ animating=false; paused=true; schedule(); }, MOVE_DUR+90);
      }, 460);
    }
    function schedule(){ if(paused) setTimeout(step, PAUSE); }
    placeInstant(); schedule();
  });
}
initTitleAnimation();

// Relancer layout sur changement de page (aide / paramètres)
function refreshTitleLayouts(){
  document.querySelectorAll('.tetrisTitle').forEach(t=>{
    // Forcer re-init en relançant initTitleAnimation sur ce titre unique: simple approche -> supprimer attribut data-inited
    // Pour rester léger, on ne reconstruit pas tout; on peut déclencher un resize pour recalculer positions.
  });
  window.dispatchEvent(new Event('resize'));
}

</script>
<script>
// Indicateur utilisateur (session) pour Tetris paramètres
document.addEventListener('DOMContentLoaded', ()=>{
  const user = sessionStorage.getItem('currentUser') || localStorage.getItem('lastUser') || 'Benjamin';
  const ind = document.getElementById('settingsUserIndicator');
  if(ind){
    const iconSpan = document.getElementById('settingsUserIcon');
    const textSpan = document.getElementById('settingsUserText');
    let base = user.trim().toLowerCase();
    let badgeLetter = base.startsWith('ben')? 'B' : base.startsWith('san')? 'S' : user[0]?.toUpperCase()||'?';
    if(iconSpan) iconSpan.textContent = badgeLetter;
    if(textSpan){
      let label = (base.startsWith('ben'))? 'Benjamin' : (base.startsWith('san')? 'Sanaa' : user);
      textSpan.innerHTML = `Connecté en tant que <strong>${label}</strong>`;
    }
  }
});
</script>
<script type="module">
// ====== SUPABASE LEADERBOARD INTEGRATION ======
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
const SUPA_URL = 'https://ocdloxagawjkokiheuiu.supabase.co';
const SUPA_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im9jZGxveGFnYXdqa29raWhldWl1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTI1MTM1NTQsImV4cCI6MjA2ODA4OTU1NH0.OFC4QyrCKtyY_2JA2I5MnI8JjmuFBYHuJH7nO1Vyu5o';
const supabase = createClient(SUPA_URL, SUPA_ANON_KEY);
// Exposer pour les autres scripts (non-module) qui publient l'état Duo
try { window._supabaseClient = supabase; window.supabase = supabase; } catch {}

// ====== FONCTIONS DUO MODE ======
// Variables globales pour le mode duo
let duoConnectionId = null;
let duoPlayerId = null;
let duoSubscription = null;
let duoHandshakeComplete = false;
let duoConnecting = false; // empêche d'écraser le statut "Connexion :P"
let duoRole = null; // 'host' ou 'guest'
let duoSeed = null;
let duoStartAt = null; // timestamp ms de départ synchronisé
let duoStateLoop = null;
let duoStarted = false;
let duoHealthLoop = null;
let duoRealtimeReady = false; // abonnement realtime établi

// Synchronisation d'affichage du modal Duo
let duoResultScheduled = false;
let duoResultTargetAt = null; // timestamp global à partir duquel on autorise l'affichage
let duoResultBroadcasted = false; // signal du résultat diffusé

function scheduleDuoResultModal(){
  try{
    if(!(duoLocal && duoLocal.finishedAt && duoRemote && duoRemote.finishedAt)) return;
    const maxFinish = Math.max(duoLocal.finishedAt, duoRemote.finishedAt);
    // Buffer pour absorber la latence réseau et aligner l'affichage
    const bufferMs = 800;
    duoResultTargetAt = maxFinish + bufferMs;
    if(duoResultScheduled) return;
    duoResultScheduled = true;
    const delay = Math.max(0, duoResultTargetAt - Date.now());
    setTimeout(()=>{ tryFinalizeDuoAtTarget(); }, delay);

    // Diffuser un signal commun dans duo_live.data pour aider l'autre client à s'aligner
    if(!duoResultBroadcasted && window.supabase && duoConnectionId && duoPlayerId){
      duoResultBroadcasted = true;
      (async ()=>{
        try{
          const { data: myRow } = await supabase
            .from('duo_live')
            .select('data')
            .eq('room_id', duoConnectionId)
            .eq('joueur', duoPlayerId)
            .maybeSingle();
          let d = myRow && myRow.data ? (typeof myRow.data === 'string' ? JSON.parse(myRow.data) : myRow.data) : {};
          d.result_ready = true;
          d.result_at = duoResultTargetAt; // facultatif: cible commune
          await supabase.from('duo_live').update({ data: d }).eq('room_id', duoConnectionId).eq('joueur', duoPlayerId);
        }catch(_){ /* ignore */ }
      })();
    }
  }catch{}
}

function tryFinalizeDuoAtTarget(){
  try{
    if(duoResultShown) return;
    if(!(duoLocal && duoLocal.finishedAt && duoRemote && duoRemote.finishedAt)) return;
    if(duoResultTargetAt && Date.now() < duoResultTargetAt) {
      // sécurité: replanifier si on arrive en avance
      setTimeout(()=>{ tryFinalizeDuoAtTarget(); }, Math.max(0, duoResultTargetAt - Date.now()));
      return;
    }
    finalizeDuoResult();
  }catch{}
}
let duoStatePollLoop = null;  // fallback polling si websocket échoue
let duoOpponentHydrateLoop = null; // polling initial pour récupérer l'état adverse
let duoOpponentHydrated = false;
let duoHandshakeWatchLoop = null; // polling résilient du handshake jusqu'au départ
let duoHandshakeTs = { seed: 0, ready: 0 }; // timestamps locaux des étapes envoyées
let duoOpponentDisconnected = false; // indicateur de présence adverse
let duoOpponentLastSeen = 0; // ms
let duoNotifPermissionAsked = false; // permission notifications
let duoScoreSubmitted = false; // éviter doublons et limiter l'insert au gagnant
let duoReadyHostNow = null; // référence temporelle host pour startAt (corrige le décalage d'horloge)
let duoCountdownPinned = false; // une fois le compte à rebours lancé, ne plus recalculer startAt
let duoOppStaleStrikes = 0; // compte les checks consécutifs en retard avant de marquer déconnecté
let duoLastDiscNotify = 0; // ms: anti-spam notifications
// duoResultShown & duoCountdownActive déclarés plus haut
let duoWaitStartTs = 0; // début d'attente en salle (pour migration matchmaking)
let duoMigratingRoom = false; // évite migrations concurrentes
// Rematch dans la même salle
var duoRematchReadyLocal = false;
var duoRematchReadyRemote = false;
var duoRematchLoop = null;
var duoIsRematch = false;

function updateRematchStatusUI(count){
  try{
  const rb = document.getElementById('duoReplayBtn');
  if(rb){ rb.textContent = `Rejouer ${count}/2`; }
  }catch{}
}

// Exposer pour utilisation croisée
try { window.updateRematchStatusUI = updateRematchStatusUI; } catch{}

async function pollRematch(){
  try{
    if(!duoConnectionId) return;
    const { data } = await supabase
      .from('duo_live')
      .select('joueur, etat, data')
      .eq('room_id', duoConnectionId);
    const rows = data || [];
    const readyCount = rows.filter(r=> r.etat === 'rematch_ready').length;
    updateRematchStatusUI(readyCount);
    // Déterminer état de l'adversaire (menu / prêt)
    let opp = null, oppData = null, oppAtMenu = false;
    try{
      opp = rows.find(r=> r.joueur !== duoPlayerId) || null;
      oppData = opp && opp.data ? (typeof opp.data === 'string' ? JSON.parse(opp.data) : opp.data) : null;
      oppAtMenu = !!(oppData && (oppData.menu === true || oppData.rematch_block === true));
      duoRematchReadyRemote = !!(opp && opp.etat === 'rematch_ready');
    }catch{}
    // Gérer l'état du bouton local selon l'état adverse
    try{
      const rb = document.getElementById('duoReplayBtn');
      if(rb){
        if(oppAtMenu){
          rb.disabled = true; rb.style.opacity = '0.6'; rb.textContent = 'Adversaire au menu';
        } else {
          rb.disabled = false; rb.style.opacity = '';
          // Le texte est déjà mis à jour via updateRematchStatusUI
        }
      }
    }catch{}
    if(readyCount >= 2){
      if(duoRematchLoop){ clearInterval(duoRematchLoop); duoRematchLoop = null; }
      beginRematch();
    }
  }catch{}
}

try { window.pollRematch = pollRematch; } catch{}

async function beginRematch(){
  try{
    // Préparer le redémarrage dans la même room
  duoStarted = false; duoCountdownPinned = false; duoCountdownActive = false; duoScoreSubmitted = false; duoResultShown = false;
  // Reset synchronisation modal
  try{ duoResultScheduled = false; }catch{}
  try{ duoResultTargetAt = null; }catch{}
  try{ duoResultBroadcasted = false; }catch{}
    duoLocal = { startAt:null, finishedAt:null, elapsedSec:null };
    duoRemote = { startAt:null, finishedAt:null, elapsedSec:null, state:null, id: duoRemote.id||null };
    // Afficher overlay d'attente Duo
    try{
      const ov = document.getElementById('duoWaitOverlay'); if(ov) ov.style.display = 'flex';
      const statusEl = document.getElementById('duoWaitStatus'); if(statusEl) statusEl.textContent = 'Démarrage imminent...';
      const countEl = document.getElementById('duoWaitCount'); if(countEl) countEl.textContent = 'Synchronisation...';
    }catch{}
    // Masquer l'overlay de résultat
  try{ const res = document.getElementById('duoResultOverlay'); if(res) res.style.display='none'; }catch{}
    // Host: proposer seed + ready; Guest: attendra 'ready'
    if(duoRole === 'host'){
      duoSeed = Math.random().toString(36).slice(2,10); if(typeof window!=='undefined') window.duoSeed = duoSeed;
      duoReadyHostNow = Date.now();
      // rematch: démarrer plus vite
      duoStartAt = duoReadyHostNow + 1200;
  await updateOwnDuoState('ready', { role:'host', seed:duoSeed, startAt:duoStartAt, hostNow:duoReadyHostNow });
  // Démarrer localement le compte à rebours synchronisé sans attendre un écho
  scheduleDuoStart();
    } else {
      await updateOwnDuoState('waiting', { role:'guest' });
      await checkPlayerCount();
    }
    // Relance watchdog court
    if(!duoHandshakeWatchLoop){
      duoHandshakeWatchLoop = setInterval(()=>{ if(duoStarted){ clearInterval(duoHandshakeWatchLoop); duoHandshakeWatchLoop=null; } else { checkPlayerCount(); } }, 900);
    }
  }catch(e){ console.warn('beginRematch error', e); }
}
try { window.beginRematch = beginRematch; } catch{}

// Fonction pour nettoyer la connexion duo
async function cleanupDuoConnection() {
  if(duoSubscription) {
    await supabase.removeChannel(duoSubscription);
    duoSubscription = null;
  }
  if(duoConnectionId && duoPlayerId) {
    try {
      await supabase.from('duo_live').delete().eq('room_id', duoConnectionId).eq('joueur', duoPlayerId);
    } catch(e) {
      console.warn('Erreur cleanup duo:', e);
    }
  }
  duoConnectionId = null;
  duoPlayerId = null;
  duoHandshakeComplete = false;
  duoConnecting = false;
  duoRole = null;
  duoSeed = null; if(typeof window!=='undefined') window.duoSeed = null;
  duoStartAt = null;
  duoStarted = false;
  if(duoStateLoop){ clearInterval(duoStateLoop); duoStateLoop = null; }
  if(duoHealthLoop){ clearInterval(duoHealthLoop); duoHealthLoop = null; }
  if(duoStatePollLoop){ clearInterval(duoStatePollLoop); duoStatePollLoop = null; }
  if(duoOpponentHydrateLoop){ clearInterval(duoOpponentHydrateLoop); duoOpponentHydrateLoop = null; }
  if(duoHandshakeWatchLoop){ clearInterval(duoHandshakeWatchLoop); duoHandshakeWatchLoop = null; }
  duoHandshakeTs = { seed: 0, ready: 0 };
  duoOpponentHydrated = false;
  duoOpponentDisconnected = false;
  duoOpponentLastSeen = 0;
  duoScoreSubmitted = false;
  duoReadyHostNow = null;
  duoCountdownPinned = false;
  duoOppStaleStrikes = 0;
  duoRealtimeReady = false;
  window.duoConnectionId = null;
  try { window.duoPlayerId = null; } catch {}
  duoResultShown = false;
  duoCountdownActive = false;
  duoWaitStartTs = 0;
  duoMigratingRoom = false;
  // Reset synchronisation modal (prochaine partie)
  try{ duoResultScheduled = false; }catch{}
  try{ duoResultTargetAt = null; }catch{}
  try{ duoResultBroadcasted = false; }catch{}
}

// Fonction principale pour gérer la connexion duo (avec réutilisation d'une session en attente)
async function handleDuoConnection() {
  try {
  // Reset léger du contexte handshake pour éviter les restes d'une partie précédente
  try{
    duoSeed = null; if(typeof window!=='undefined') window.duoSeed = null;
    duoStarted = false; duoCountdownPinned = false; duoCountdownActive = false; duoHandshakeComplete = false;
    duoLocal = { startAt:null, finishedAt:null, elapsedSec:null }; duoRemote = { startAt:null, finishedAt:null, elapsedSec:null, state:null, id:null };
    duoScoreSubmitted = false; duoResultShown = false;
  }catch{}
  const user = sessionStorage.getItem('currentUser') || localStorage.getItem('lastUser') || 'Benjamin';
  duoPlayerId = user;
  try { window.duoPlayerId = duoPlayerId; } catch {}
  // Préparer les notifications si supportées
  ensureNotificationPermission();
    const duoWaitCountEl = document.getElementById('duoWaitCount');
    const feedback = (msg)=>{ if(duoWaitCountEl) duoWaitCountEl.textContent = msg; };
    const STALE_MS = 15000;

    // 0. Purger anciennes entrées du même joueur (sessions abandonnées)
    try {
      await supabase.from('duo_live').delete().eq('joueur', duoPlayerId).lt('updated_at', new Date(Date.now()-STALE_MS).toISOString());
    } catch(_e) {/* ignore */}

    // 1. Chercher une room active (1 joueur != current, récence < STALE_MS)
    let reuseId = null;
    try {
      const since = new Date(Date.now()-STALE_MS).toISOString();
      const { data: openRows, error: openErr } = await supabase
        .from('duo_live')
        .select('room_id, joueur, updated_at, etat')
        .gt('updated_at', since);
      if(!openErr && openRows?.length){
        const byRoom = new Map();
        openRows.forEach(r=>{ if(!byRoom.has(r.room_id)) byRoom.set(r.room_id, []); byRoom.get(r.room_id).push(r); });
        for(const [rid, rows] of byRoom.entries()){
          if(rows.length===1 && rows[0].joueur !== duoPlayerId){ reuseId = rid; break; }
        }
      }
    } catch(_e){ }

    // 2. Fixer l'id (nouvelle room si aucune salle à rejoindre)
    duoConnectionId = reuseId ?? generateConnectionId();
    window.duoConnectionId = duoConnectionId;

    // 3. Vérifier si on est déjà inscrit (reload éventuel)
    const { data: existing, error: existErr } = await supabase
      .from('duo_live')
      .select('joueur')
      .eq('room_id', duoConnectionId)
      .eq('joueur', duoPlayerId)
      .limit(1);
    if(existErr){ console.warn('Check exist failed', existErr); }

    if(!existing || !existing.length){
      const { error: insertError } = await supabase.from('duo_live').insert({ room_id: duoConnectionId, joueur: duoPlayerId, etat: 'waiting' });
      if(insertError){
        console.error('Erreur insertion duo_live:', insertError);
        feedback('Erreur connexion duo');
        return;
      }
    }

    // Affichage initial sûr
    feedback('Joueurs connectés : 1/2');

    // 5. Vérifier combien de joueurs sont connectés
  await checkPlayerCount();

    // 6. S'abonner aux changements temps réel (une seule fois)
    if(!duoSubscription){
      duoSubscription = supabase
        .channel('duo_live_changes')
        .on('postgres_changes', 
          { event: '*', schema: 'public', table: 'duo_live', filter: `room_id=eq.${duoConnectionId}` },
          (payload) => {
            console.log('Changement duo_live:', payload);
            handleDuoLiveChange(payload);
          }
        )
        .subscribe((status)=>{
          if(status === 'SUBSCRIBED'){
            duoRealtimeReady = true;
            console.log('Realtime duo SUBSCRIBED');
          }
        });
      // Fallback: démarrer un polling si pas SUBSCRIBED rapidement
      let waited = 0;
      const waitInt = setInterval(()=>{
        waited += 300;
        if(duoRealtimeReady){ clearInterval(waitInt); return; }
        if(waited >= 1800){
          clearInterval(waitInt);
          if(!duoRealtimeReady && !duoStatePollLoop){
            console.warn('Realtime non prêt, fallback polling activé');
            duoStatePollLoop = setInterval(()=>{ if(!duoStarted) checkPlayerCount(); else { clearInterval(duoStatePollLoop); duoStatePollLoop=null; } }, 1200);
          }
        }
      }, 300);
    }

    // Watchdog supplémentaire: même si le realtime marche, on s'assure de ne pas rester bloqué
    if(!duoHandshakeWatchLoop){
      duoHandshakeWatchLoop = setInterval(()=>{
        if(duoStarted){ clearInterval(duoHandshakeWatchLoop); duoHandshakeWatchLoop = null; return; }
        checkPlayerCount();
      }, 1200);
    }
  // Marquer le début d'attente pour potentielle migration
  duoWaitStartTs = Date.now();
  } catch(e) {
    console.error('Erreur handleDuoConnection:', e);
    const duoWaitCountEl = document.getElementById('duoWaitCount');
    if(duoWaitCountEl) duoWaitCountEl.textContent = 'Erreur connexion duo';
  }
}

// Vérifier le nombre de joueurs connectés
async function checkPlayerCount() {
  try {
    const { data, error } = await supabase
      .from('duo_live')
      .select('joueur, etat, updated_at, data')
      .eq('room_id', duoConnectionId);
    
    if(error) {
      console.error('Erreur checkPlayerCount:', error);
      return;
    }
    
  processDuoRoomSnapshot(data);
    
  } catch(e) {
    console.error('Erreur checkPlayerCount:', e);
  }
}

// (Ancien handshake supprimé)

function processDuoRoomSnapshot(rows){
  const duoWaitCount = document.getElementById('duoWaitCount');
  const statusEl = document.getElementById('duoWaitStatus');
  if(!rows) return;
  const NOW = Date.now();
  const STALE_MS = 15000;
  // Filtrer lignes trop anciennes
  let filtered = rows.filter(r=> NOW - new Date(r.updated_at).getTime() < STALE_MS);
  // Garder seulement la plus récente par joueur (évite doubles reloads)
  const latestByPlayer = new Map();
  filtered.forEach(r=>{
    const t = new Date(r.updated_at).getTime();
    if(!latestByPlayer.has(r.joueur) || t > latestByPlayer.get(r.joueur)._t){
      latestByPlayer.set(r.joueur, {...r, _t:t});
    }
  });
  filtered = [...latestByPlayer.values()];
  const playerCount = filtered.length;
  if(duoWaitCount && !duoCountdownActive) duoWaitCount.textContent = `Joueurs connectés : ${playerCount}/2`;

  // Déterminer host/guest de façon stable: prioriser data.role==='host', sinon fallback à l'antériorité
  const parsed = filtered.map(r=>{
    let d = r.data; if(typeof d==='string'){ try{ d = JSON.parse(d); }catch{ d = {}; } }
    return { ...r, _data: d||{} };
  });
  let hostRow = parsed.find(r => r._data && r._data.role === 'host');
  let guestRow = null;
  if(!hostRow){
    const sorted = [...parsed].sort((a,b)=> new Date(a.updated_at) - new Date(b.updated_at));
    hostRow = sorted[0] || null;
    guestRow = sorted[1] || null;
  } else {
    guestRow = parsed.find(r => r.joueur !== hostRow.joueur) || null;
  }

  // Mettre à jour "last seen" de l'adversaire
  try{
    const opp = filtered.find(r=> r.joueur !== duoPlayerId);
    if(opp){ duoOpponentLastSeen = new Date(opp.updated_at).getTime(); }
  }catch{}

  if(!duoRole){
    if(hostRow && hostRow.joueur === duoPlayerId) duoRole = 'host';
    else if(guestRow && guestRow.joueur === duoPlayerId) duoRole = 'guest';
  }

  if(playerCount === 1){
  if(statusEl && !duoCountdownActive) statusEl.textContent = "En attente d'un joueur...";
  setDuoBackDisabled(false);
  // Si on est seul trop longtemps, tenter une migration vers une autre salle ouverte (évite le deadlock 1/2 vs 1/2)
  try{ maybeMigrateToOpenRoom(); }catch{}
    // Marquer son rôle comme host dès maintenant (idempotent)
    try{
      const selfRow = parsed[0];
      let d = selfRow? selfRow._data||{} : {};
      if(d.role !== 'host'){
        d = { ...d, role:'host' };
        // On reste en etat 'waiting'
        supabase.from('duo_live').update({ data: d }).eq('room_id', duoConnectionId).eq('joueur', duoPlayerId).then(()=>{}).catch(()=>{});
      }
      duoRole = 'host';
    }catch{}
    // Dessiner si l'adversaire (seul autre joueur) a déjà un état
    try{
      const opp = filtered.find(r=> r.joueur !== duoPlayerId);
      if(opp && opp.data){
        let d = opp.data; if(typeof d === 'string'){ try{ d = JSON.parse(d); }catch{} }
        if(d && d.state){ const wrap = document.getElementById('opponentMini'); if(wrap) wrap.style.display='block'; drawOpponentMini(d.state); }
      }
    }catch{}
    return;
  }
  if(playerCount > 2){
  if(statusEl && !duoCountdownActive) statusEl.textContent = 'Salle pleine (erreur)';
  setDuoBackDisabled(false);
    return;
  }

  let hostData = (hostRow && (hostRow._data || hostRow.data)) || {};
  let guestData = (guestRow && (guestRow._data || guestRow.data)) || {};
  if(typeof hostData === 'string'){ try{ hostData = JSON.parse(hostData);}catch{hostData={};} }
  if(typeof guestData === 'string'){ try{ guestData = JSON.parse(guestData);}catch{guestData={};} }

  // Si aucun rôle n'est défini côté serveur pour host/guest, élire un host de secours de manière déterministe
  try{
    const hasRoles = !!(hostRow && hostRow._data && hostRow._data.role) || !!(guestRow && guestRow._data && guestRow._data.role);
    if(!hasRoles && hostRow && guestRow){
      const myIsCandidate = duoPlayerId && [hostRow.joueur, guestRow.joueur].sort()[0] === duoPlayerId;
      if(myIsCandidate){
        // Se proclamer host si personne ne l'a fait après un petit délai
        const ageMs = NOW - new Date(hostRow.updated_at).getTime();
        if(ageMs > 800){ // petit délai pour éviter collision
          supabase.from('duo_live').update({ data: { role:'host' } }).eq('room_id', duoConnectionId).eq('joueur', duoPlayerId).then(()=>{}).catch(()=>{});
          duoRole = 'host';
        }
      }
    }
  }catch{}

  // Résoudre conflit de seeds éventuel: prioriser la seed du host (plus ancien)
  if(hostData && guestData && hostData.seed && guestData.seed && hostData.seed !== guestData.seed){
    if(duoRole === 'guest'){
      duoSeed = hostData.seed; if(typeof window!=='undefined') window.duoSeed = duoSeed;
      updateOwnDuoState('seed_ack', { role:'guest', seed:duoSeed, ack:true });
    }
  }

  if(duoRole === 'host' && !hostData.seed){
    duoSeed = Math.random().toString(36).slice(2,10); if(typeof window!=='undefined') window.duoSeed = duoSeed;
    hostData = { role:'host', seed:duoSeed };
    updateOwnDuoState('seed', hostData);
  if(statusEl) statusEl.textContent = 'Joueur trouvé ! Génération seed...'; setDuoBackDisabled(false);
    return;
  }
  if(duoRole === 'guest' && hostRow && hostRow.etat === 'seed' && hostData.seed && (!guestRow || guestRow.etat==='waiting' || guestRow.etat==='seed')){
    duoSeed = hostData.seed; if(typeof window!=='undefined') window.duoSeed = duoSeed;
    guestData = { role:'guest', seed:duoSeed, ack:true };
    updateOwnDuoState('seed_ack', guestData);
  if(statusEl) statusEl.textContent = 'Seed reçue. Synchronisation...'; setDuoBackDisabled(false);
    return;
  }
  if(duoRole === 'host' && hostRow && hostRow.etat==='seed' && guestRow && guestRow.etat==='seed_ack' && hostData.seed){
    duoSeed = hostData.seed; if(typeof window!=='undefined') window.duoSeed = duoSeed;
    // Démarrage dans 5s basé sur l'horloge du host pour corriger les décalages
    if(!duoCountdownPinned){
      duoReadyHostNow = Date.now();
      duoStartAt = duoReadyHostNow + 5000;
    }
    hostData = { role:'host', seed:duoSeed, startAt:duoStartAt, hostNow: duoReadyHostNow };
    updateOwnDuoState('ready', hostData);
  if(statusEl) statusEl.textContent = 'Synchronisation prête...'; setDuoBackDisabled(false);
    return;
  }
  if(duoRole === 'guest' && hostRow && hostRow.etat==='ready' && hostData.startAt){
    duoSeed = hostData.seed; if(typeof window!=='undefined') window.duoSeed = duoSeed;
    // Ajuster startAt local en compensant l'offset d'horloge: startAtHost - (hostNow - nowLocal)
    if(!duoCountdownPinned){
      const nowLocal = Date.now();
      const hostNowRef = (typeof hostData.hostNow === 'number') ? hostData.hostNow : (hostData.startAt - 5000);
      const skew = hostNowRef - nowLocal;
      duoStartAt = hostData.startAt - skew;
    }
    if(!duoStarted){
      scheduleDuoStart();
  if(statusEl) statusEl.textContent = 'Démarrage imminent...';
  setDuoBackDisabled(true);
    }
    return;
  }
  if(duoRole === 'host' && hostRow && hostRow.etat==='ready' && guestRow && guestRow.etat==='seed_ack' && hostData.startAt){
    duoSeed = hostData.seed; if(typeof window!=='undefined') window.duoSeed = duoSeed;
    // Rester cohérent avec la première publication
    duoStartAt = hostData.startAt;
    if(!duoStarted){
      scheduleDuoStart();
      if(statusEl) statusEl.textContent = 'Démarrage imminent...';
  setDuoBackDisabled(true);
    }
    return;
  }

  // Relances idempotentes si une étape semble bloquée (timeouts légers)
  try{
    const nowMs = Date.now();
    if(playerCount===2){
      // Host a proposé seed mais pas d'ACK depuis >3s => republier pour réveiller l'autre
  if(duoRole==='host' && hostRow && hostRow.etat==='seed' && (!guestRow || guestRow.etat!=='seed_ack')){
        if(nowMs - (duoHandshakeTs.seed||0) > 3000 && hostData.seed){
          updateOwnDuoState('seed', { role:'host', seed: hostData.seed });
          duoHandshakeTs.seed = nowMs;
        }
      }
      // Guest a vu host en seed mais n'a pas encore ack -> ack forcé si retard >2s
  if(duoRole==='guest' && hostRow && hostRow.etat==='seed' && hostData.seed && (!guestRow || guestRow.etat==='waiting' || guestRow.etat==='seed')){
        const hostAge = nowMs - new Date(hostRow.updated_at).getTime();
        if(hostAge > 2000){
          duoSeed = hostData.seed; if(typeof window!=='undefined') window.duoSeed = duoSeed;
          updateOwnDuoState('seed_ack', { role:'guest', seed: duoSeed, ack:true });
        }
      }
      // Host en ready mais l'autre n'a pas réagi → republier ready chaque 3s maxi
  if(duoRole==='host' && hostRow && hostRow.etat==='ready' && hostData.startAt){
        if(guestRow && guestRow.etat!=='ready' && nowMs - (duoHandshakeTs.ready||0) > 3000){
          const repHostNow = (typeof hostData.hostNow==='number') ? hostData.hostNow : (duoReadyHostNow||null);
          updateOwnDuoState('ready', { role:'host', seed: hostData.seed, startAt: hostData.startAt, hostNow: repHostNow });
          duoHandshakeTs.ready = nowMs;
        }
      }
      // Si startAt est passé côté guest (événement raté), démarrer quand même (sans recalcul si déjà épinglé)
  if(duoRole==='guest' && hostRow && hostRow.etat==='ready' && hostData.startAt && !duoStarted){
        duoSeed = hostData.seed; if(typeof window!=='undefined') window.duoSeed = duoSeed;
        if(!duoCountdownPinned){
          const nowLocal2 = Date.now();
          const hostNowRef2 = (typeof hostData.hostNow === 'number') ? hostData.hostNow : (hostData.startAt - 5000);
          const skew2 = hostNowRef2 - nowLocal2;
          duoStartAt = hostData.startAt - skew2;
        }
        scheduleDuoStart();
        if(statusEl) statusEl.textContent = 'Démarrage imminent...'; setDuoBackDisabled(true);
      }
    }
  }catch{ /* soft */ }
}

async function updateOwnDuoState(etat, dataObj){
  try { await supabase.from('duo_live').update({ etat, data: dataObj }).eq('room_id', duoConnectionId).eq('joueur', duoPlayerId); }
  catch(e){ console.warn('updateOwnDuoState error', e); }
  // mémoriser timestamps locaux pour watchdog
  try{
    if(etat==='seed') duoHandshakeTs.seed = Date.now();
    if(etat==='ready') duoHandshakeTs.ready = Date.now();
  }catch{}
}

function scheduleDuoStart(){
  const now = Date.now();
  let delay = Math.max(0, duoStartAt - now);
  // Si on est en rematch, partir plus vite; sinon garder un petit tampon
  if(duoIsRematch){
    if(delay < 200) { duoStartAt = now + 300; delay = 300; }
  } else {
    if(delay < 600) { duoStartAt = now + 800; delay = 800; }
  }
  duoCountdownPinned = true; // ne plus recalculer duoStartAt après ce point
  duoCountdownActive = true;
  duoStarted = true;
  if(!duoHealthLoop){ duoHealthLoop = setInterval(checkDuoHealth, 5000); }
  if(!duoSeed){ console.warn('Duo: démarrage sans seed défini'); }
  // Compte à rebours visuel sur l'overlay d'attente Duo
  try{
    const statusEl = document.getElementById('duoWaitStatus');
    const countEl = document.getElementById('duoWaitCount');
    let remainingMs = delay;
    if(statusEl){ statusEl.textContent = 'Démarrage imminent...'; }
    setDuoBackDisabled(true);
    // Rafraîchir toutes les ~200ms pour un affichage fluide
    const tick = () => {
      remainingMs = Math.max(0, duoStartAt - Date.now());
      const s = Math.ceil(remainingMs/1000);
      if(countEl){ countEl.textContent = `Départ dans ${s}s`; }
      if(remainingMs <= 0){
        if(countEl) countEl.textContent = 'Départ!';
        startDuoGame();
        duoCountdownActive = false;
      } else {
        setTimeout(tick, 200);
      }
    };
    tick();
  }catch{ setTimeout(()=>{ startDuoGame(); }, delay); }
}

async function checkDuoHealth(){
  if(!duoConnectionId) return;
  try {
    const { data, error } = await supabase
      .from('duo_live')
      .select('joueur, updated_at')
      .eq('room_id', duoConnectionId);
    if(error) return;
  // Fallback: si les deux ont une fin, assurer l'affichage du résultat
  try{ if(duoLocal.finishedAt && duoRemote.finishedAt && !duoResultShown){ scheduleDuoResultModal(); } }catch{}
    const now = Date.now();
    const oppRow = data.find(r=> r.joueur !== duoPlayerId);
    const THRESH = (typeof isMobile !== 'undefined' && isMobile) ? 22000 : 12000; // seuil plus large sur mobile
    const oppIsStale = oppRow ? (now - new Date(oppRow?.updated_at||0).getTime() > THRESH) : true;
    if(oppIsStale){
      if(!duoStarted){
        const duoWaitCount = document.getElementById('duoWaitCount');
        if(duoWaitCount) duoWaitCount.textContent = 'Joueur inactif, fermeture.';
        setTimeout(()=>{ cleanupDuoConnection(); const ov=document.getElementById('duoWaitOverlay'); if(ov) ov.style.display='none'; },1400);
      } else {
        // Strikes avant notification pour éviter faux positifs
        const needed = (typeof isMobile !== 'undefined' && isMobile) ? 3 : 2;
        duoOppStaleStrikes = Math.min(needed, duoOppStaleStrikes + 1);
        if(duoOppStaleStrikes >= needed){
          if(!duoOpponentDisconnected){ markOpponentDisconnected('Adversaire déconnecté'); }
          // Si l'adversaire est considéré inactif, verrouiller sa fin si non définie
          try{ if(!duoRemote.finishedAt){ duoRemote.finishedAt = Date.now(); } }catch{}
          // Si notre partie est finie, afficher le résultat maintenant
          try{ if(duoLocal.finishedAt && duoRemote.finishedAt && !duoResultShown){ scheduleDuoResultModal(); } }catch{}
        } else {
          // Plus de condition sur duoLocal.finishedAt seulement - on attend TOUJOURS les deux
        }
      }
    } else {
      // Si tout va bien, enlever éventuellement le badge
      duoOppStaleStrikes = 0;
      if(duoOpponentDisconnected){ clearOpponentDisconnectedBadge(); }
    }
  } catch(e){ console.warn('checkDuoHealth error', e);} 
}

// Cherche une autre salle ouverte avec 1 joueur et migre si disponible (corrige deadlock 1/2 contre 1/2)
async function maybeMigrateToOpenRoom(){
  if(duoStarted || duoMigratingRoom) return;
  const waited = Date.now() - (duoWaitStartTs||Date.now());
  // N'essayer qu'après un court délai
  if(waited < 2500) return;
  duoMigratingRoom = true;
  try{
    const since = new Date(Date.now()-15000).toISOString();
    const { data: openRows, error } = await supabase
      .from('duo_live')
      .select('room_id, joueur, updated_at')
      .gt('updated_at', since);
    if(error){ duoMigratingRoom = false; return; }
    // Grouper par room et trouver une room avec exactement 1 joueur (≠ moi) qui n'est pas la mienne
    const byRoom = new Map();
    (openRows||[]).forEach(r=>{ if(!byRoom.has(r.room_id)) byRoom.set(r.room_id, []); byRoom.get(r.room_id).push(r); });
    let target = null;
    for(const [rid, rows] of byRoom.entries()){
      if(rid === duoConnectionId) continue;
      if(rows.length === 1 && rows[0].joueur !== duoPlayerId){ target = { room_id: rid, row: rows[0] }; break; }
    }
    if(target){ await migrateToRoom(target.room_id); }
  }catch(_){ /* ignore */ }
  finally{ duoMigratingRoom = false; }
}

// Migre vers une autre room: désabonne l'ancienne, supprime sa ligne et rejoint la nouvelle room
async function migrateToRoom(newRoomId){
  try{
    // Se désabonner de l'ancienne room
    if(duoSubscription){ try{ await supabase.removeChannel(duoSubscription); }catch{} duoSubscription = null; }
    // Supprimer sa ligne de l'ancienne room
    try{ await supabase.from('duo_live').delete().eq('room_id', duoConnectionId).eq('joueur', duoPlayerId); }catch{}
    // Basculer sur la nouvelle room
    duoConnectionId = newRoomId; window.duoConnectionId = newRoomId;
    duoRole = null; duoSeed = null; duoStartAt = null; duoCountdownPinned = false; duoStarted = false; duoOpponentHydrated = false; duoResultShown = false; duoHandshakeComplete = false;
    // Inscription dans la nouvelle room
    try{ await supabase.from('duo_live').insert({ room_id: duoConnectionId, joueur: duoPlayerId, etat: 'waiting' }); }catch{}
    // Ré-abonnement realtime pour la nouvelle room
    duoSubscription = supabase
      .channel('duo_live_changes')
      .on('postgres_changes', { event:'*', schema:'public', table:'duo_live', filter:`room_id=eq.${duoConnectionId}` }, (payload)=>{ handleDuoLiveChange(payload); })
      .subscribe((status)=>{ if(status==='SUBSCRIBED'){ duoRealtimeReady = true; } });
    // Re-check immédiat
    const duoWaitCountEl = document.getElementById('duoWaitCount'); if(duoWaitCountEl) duoWaitCountEl.textContent = 'Joueurs connectés : 1/2';
    duoWaitStartTs = Date.now();
    await checkPlayerCount();
  }catch(e){ console.warn('Migration room duo échouée', e); }
}

// Lancer le jeu duo
async function startDuoGame() {
  console.log('Lancement du jeu duo !');
  
  // Masquer l'overlay d'attente
  document.getElementById('duoWaitOverlay').style.display = 'none';
  duoConnecting = false;
  duoHandshakeComplete = true;
  if(duoStatePollLoop){ clearInterval(duoStatePollLoop); duoStatePollLoop=null; }

  // Démarrer une partie identique au solo, mais en mode Duo (score masqué)
  isDuoMode = true;
  applyDuoUiMode(true);
  setDuoBackDisabled(false);
  startGameFromMenu();

  // Hydratation initiale du mini plateau adverse: récupérer le dernier état connu de l'autre joueur
  try{
    const { data, error } = await supabase
      .from('duo_live')
      .select('joueur, data, updated_at')
      .eq('room_id', duoConnectionId)
      .neq('joueur', duoPlayerId)
      .order('updated_at', { ascending: false })
      .limit(1);
    if(!error && data && data.length && data[0].data){
      let d = data[0].data; if(typeof d === 'string'){ try{ d = JSON.parse(d); }catch{} }
      if(d && d.state){
        const wrap = document.getElementById('opponentMini'); if(wrap) wrap.style.display = 'block';
        drawOpponentMini(d.state);
        duoOpponentHydrated = true;
        duoRemote.state = d.state; duoRemote.id = data[0].joueur; duoRemote.startAt = d.startAt || duoStartAt; duoRemote.finishedAt = d.state.finishedAt || (d.state.alive? null : Date.now());
      }
    }
  }catch(e){ /* non bloquant */ }

  // Si non hydraté, petit polling jusqu'à réception (10s max)
  if(!duoOpponentHydrated && !duoOpponentHydrateLoop){
    const startedAt = Date.now();
    duoOpponentHydrateLoop = setInterval(async ()=>{
      if(Date.now() - startedAt > 10000){ clearInterval(duoOpponentHydrateLoop); duoOpponentHydrateLoop=null; return; }
      try{
        const { data } = await supabase
          .from('duo_live')
          .select('joueur, data, updated_at')
          .eq('room_id', duoConnectionId)
          .neq('joueur', duoPlayerId)
          .order('updated_at', { ascending: false })
          .limit(1);
        if(data && data.length && data[0].data){
          let d = data[0].data; if(typeof d === 'string'){ try{ d = JSON.parse(d); }catch{} }
          if(d && d.state){
            const wrap = document.getElementById('opponentMini'); if(wrap) wrap.style.display = 'block';
            drawOpponentMini(d.state);
            duoOpponentHydrated = true;
            clearInterval(duoOpponentHydrateLoop); duoOpponentHydrateLoop=null;
          }
        }
      }catch(_){ /* ignore */ }
    }, 600);
  }
}

// Gérer les changements temps réel de duo_live
function handleDuoLiveChange(payload) {
  if(payload.eventType === 'INSERT' || payload.eventType === 'UPDATE') {
    // Un joueur s'est connecté ou a changé de statut
    setTimeout(() => {
      checkPlayerCount();
  // Rafraîchir immédiatement l'état rematch (compteur x/2, verrouillage bouton)
  try{ pollRematch(); }catch{}
      // Afficher mini plateau adverse en Duo
      try{
        const row = payload.new || payload.record || null;
        if(row && row.joueur && row.joueur !== duoPlayerId && row.data){
          // marque la présence adverse
          duoOpponentLastSeen = Date.now();
          duoOppStaleStrikes = 0;
          if(duoOpponentDisconnected){ clearOpponentDisconnectedBadge(); }
          let d = row.data; if(typeof d === 'string'){ try{ d = JSON.parse(d); }catch{} }
          if(d && d.state){
            const wrap = document.getElementById('opponentMini'); if(wrap) wrap.style.display = 'block';
            drawOpponentMini(d.state);
            duoOpponentHydrated = true;
            // Stocker état et finishedAt distant
            duoRemote.state = d.state;
            duoRemote.id = row.joueur;
            duoRemote.startAt = d.startAt || duoRemote.startAt || duoStartAt;
            duoRemote.finishedAt = d.state.finishedAt || (d.state.alive? null : Date.now());
            // Si les deux ont un finishedAt connu, afficher immédiatement le résultat (idempotent)
            if(duoLocal.finishedAt && duoRemote.finishedAt && !duoResultShown){ scheduleDuoResultModal(); }
            // Synchronisation supplémentaire: si un client publie data.result_ready, utiliser son horloge cible
            try{
              if(d.result_ready && !duoResultShown){
                if(duoLocal.finishedAt && duoRemote.finishedAt){
                  if(typeof d.result_at === 'number' && !isNaN(d.result_at)){
                    duoResultTargetAt = d.result_at;
                    if(!duoResultScheduled){
                      duoResultScheduled = true;
                      const delay = Math.max(0, duoResultTargetAt - Date.now());
                      setTimeout(()=>{ tryFinalizeDuoAtTarget(); }, delay);
                    }
                  } else if(!duoResultScheduled){
                    scheduleDuoResultModal();
                  }
                }
              }
            }catch{}
            // Si les deux sont KO, arrêter et figer le chrono Duo puis afficher résultat
            try{
              const hud = document.getElementById('duoHudTop');
              const localAlive = !!running;
              const oppAlive = !!(d.state.alive);
              if(!localAlive && !oppAlive && hud && hud._intv){
                // Figer sur le même temps (max des deux finishedAt)
                if(!duoLocal.finishedAt) duoLocal.finishedAt = Date.now();
                const freezeAt = Math.max(duoLocal.finishedAt||0, duoRemote.finishedAt||0);
                const startTs = duoLocal.startAt || duoStartAt || Date.now();
                const t = Math.max(0, Math.floor((freezeAt-startTs)/1000));
                duoRemote.elapsedSec = Math.max(duoLocal.elapsedSec||t, t);
                const mm = String(Math.floor(t/60)).padStart(2,'0');
                const ss = String(t%60).padStart(2,'0');
                hud.textContent = `${mm}:${ss}`;
                clearInterval(hud._intv); hud._intv = null;
                // Plus de finalizeDuoResult() immédiat - on attend les deux joueurs
                console.log('Local player finished, waiting for remote player...');
              }
            }catch{}
          }
        }
      }catch{}
    }, 300);
  } else if(payload.eventType === 'DELETE') {
    // Un joueur s'est déconnecté
    const duoWaitCount = document.getElementById('duoWaitCount');
    if(!duoStarted) {
      if(duoWaitCount) duoWaitCount.textContent = 'Joueur perdu, retour menu.';
      setTimeout(()=>{
        cleanupDuoConnection();
        const ov = document.getElementById('duoWaitOverlay'); if(ov) ov.style.display = 'none';
      }, 1500);
    } else {
      // Pendant la partie
  // Si l'adversaire se déconnecte sans avoir publié finishedAt, fixer un timestamp de fin côté distant
  try{ if(!duoRemote.finishedAt){ duoRemote.finishedAt = Date.now(); } }catch{}
      if(duoLocal.finishedAt){
        // Notre partie est déjà finie: tenter d'afficher le résultat, puis revenir au menu
        // Plus de finalizeDuoResult() immédiat - on attend les deux joueurs
        console.log('Game over in duo mode, waiting for both players to finish...');
        setTimeout(()=>{ const ov = document.getElementById('duoResultOverlay'); if(ov) ov.style.display='none'; showMenu(); }, 1200);
      } else {
        // Sinon, notifier la déconnexion mais laisser continuer (règle Duo)
        markOpponentDisconnected('Votre adversaire a quitté la partie');
        showUserNotification('Adversaire déconnecté', 'Votre adversaire a quitté la partie.');
      }
    }
  }
}

// Générer un ID de connexion unique
function generateConnectionId() {
  return 'duo_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
}

// Maintenir la connexion active (ping toutes les 10 secondes)
setInterval(async () => {
  if(duoConnectionId && duoPlayerId) {
    try {
      await supabase
        .from('duo_live')
        .update({ updated_at: new Date().toISOString() })
        .eq('room_id', duoConnectionId)
        .eq('joueur', duoPlayerId);
    } catch(e) {
      console.warn('Erreur ping duo:', e);
    }
  }
}, 10000);

// UI: badge de déconnexion adverse sur le mini-plateau
function markOpponentDisconnected(msg){
  duoOpponentDisconnected = true;
  const wrap = document.getElementById('opponentMini');
  if(!wrap) return;
  // Atténuer visuellement
  try { wrap.style.opacity = '0.55'; } catch{}
  try { wrap.classList.add('opponentMini--disconnected'); } catch{}
  let badge = document.getElementById('opDiscBadge');
  if(!badge){
    badge = document.createElement('div');
    badge.id = 'opDiscBadge';
    badge.textContent = msg || 'Adversaire déconnecté';
    wrap.style.position = 'relative';
    wrap.appendChild(badge);
  } else {
    badge.textContent = msg || 'Adversaire déconnecté';
  }
  // Notification/toast utilisateur
  const now = Date.now();
  if(now - duoLastDiscNotify > 10000){ // intervalle min 10s
    duoLastDiscNotify = now;
    showUserNotification('Adversaire déconnecté', msg || 'Adversaire déconnecté');
  }
}

function clearOpponentDisconnectedBadge(){
  duoOpponentDisconnected = false;
  const wrap = document.getElementById('opponentMini');
  if(wrap){
    try { wrap.style.opacity = '1'; } catch{}
  try { wrap.classList.remove('opponentMini--disconnected'); } catch{}
    const badge = document.getElementById('opDiscBadge');
    if(badge){ try{ badge.remove(); }catch{} }
  }
}

// Notifications: wrapper + fallback toast
function ensureNotificationPermission(){
  try{
    if(typeof Notification === 'undefined') return;
    if(!duoNotifPermissionAsked && Notification.permission === 'default'){
      duoNotifPermissionAsked = true;
      Notification.requestPermission().catch(()=>{});
    }
  }catch{}
}

function showUserNotification(title, body){
  try{
    if(typeof Notification !== 'undefined' && Notification.permission === 'granted'){
      new Notification(title || 'Notification', { body: body || '', silent: false });
      return;
    }
  }catch{}
  // Fallback toast
  showToast(body || title || 'Notification');
}

function showToast(msg){
  try{
    let cont = document.getElementById('toastContainer');
    if(!cont){
      cont = document.createElement('div');
      cont.id = 'toastContainer';
      cont.style.position = 'fixed';
      cont.style.right = '16px';
      cont.style.bottom = '16px';
      cont.style.zIndex = '9999';
      cont.style.display = 'flex';
      cont.style.flexDirection = 'column';
      cont.style.gap = '8px';
      document.body.appendChild(cont);
    }
    const t = document.createElement('div');
    t.textContent = msg;
    t.style.background = 'rgba(0,0,0,0.85)';
    t.style.color = '#fff';
    t.style.padding = '10px 12px';
    t.style.borderRadius = '8px';
    t.style.boxShadow = '0 6px 18px rgba(0,0,0,0.35)';
    t.style.fontSize = '13px';
    t.style.maxWidth = '60vw';
    t.style.border = '1px solid rgba(255,255,255,0.2)';
    t.style.opacity = '0';
    t.style.transform = 'translateY(8px)';
    t.style.transition = 'opacity .2s ease, transform .2s ease';
    cont.appendChild(t);
    requestAnimationFrame(()=>{ t.style.opacity = '1'; t.style.transform = 'translateY(0)'; });
    setTimeout(()=>{
      t.style.opacity = '0'; t.style.transform = 'translateY(8px)';
      setTimeout(()=>{ try{ t.remove(); }catch{} }, 220);
    }, 4200);
  }catch{}
}

// Exposer les fonctions au scope global
window.supabaseHandleDuo = handleDuoConnection;
window.supabaseCleanupDuo = cleanupDuoConnection;

// ====== LEADERBOARD FUNCTIONS ======

async function fetchLeaderboard(){
  const tabSoloBtn = document.getElementById('lbTabSolo');
  const tabDuoBtn = document.getElementById('lbTabDuo');
  const soloPanel = document.getElementById('lbSoloPanel');
  const duoPanel = document.getElementById('lbDuoPanel');
  const isDuo = duoPanel && duoPanel.style.display !== 'none';
  const status = document.getElementById('lbStatus');
  if(isDuo){
    await fetchLeaderboardDuo();
    if(status) status.textContent = 'Duo';
    return;
  }
  const bodyEl = document.getElementById('lbBody');
  if(status) status.textContent = 'Chargement…';
  if(bodyEl) bodyEl.innerHTML = '<tr><td colspan="6" style="padding:12px;font-size:12px;color:#6d8089">Chargement…</td></tr>';
  const { data, error } = await supabase.from('tetris_scores').select('*').order('score',{ascending:false}).limit(20);
  if(error){ if(status) status.textContent = 'Erreur chargement'; console.error(error); return; }
  if(status) status.textContent = `Top ${data.length}`;
  if(bodyEl){
    bodyEl.innerHTML = '';
    if(!data.length){ bodyEl.innerHTML = '<tr><td colspan="6" style="padding:10px;font-size:12px;color:#6d8089">Aucun score pour le moment.</td></tr>'; return; }
    data.forEach((row,idx)=>{
      const tr = document.createElement('tr');
      if(idx===0){ tr.style.background = 'linear-gradient(90deg,rgba(255,209,102,0.22),rgba(255,209,102,0.06))'; }
      else if(idx===1){ tr.style.background = 'linear-gradient(90deg,rgba(215,222,226,0.25),rgba(215,222,226,0.07))'; }
      else if(idx===2){ tr.style.background = 'linear-gradient(90deg,rgba(205,138,50,0.25),rgba(205,138,50,0.07))'; }
      else { tr.style.background = idx%2? 'rgba(255,255,255,0.03)': 'transparent'; }
  // Date d'affichage: created_at si dispo, sinon updated_at, sinon tiret
  const createdRaw = row.created_at || row.updated_at || null;
  const created = createdRaw ? new Date(createdRaw) : null;
  const dateStr = created? created.toLocaleDateString('fr-FR',{day:'2-digit',month:'2-digit'})+' '+created.toLocaleTimeString('fr-FR',{hour:'2-digit',minute:'2-digit'}) : '–';
      let lvl = (row.level != null ? row.level : null);
      let lineCount = (typeof row.lines === 'number') ? row.lines : null;
      if((lvl === null || lvl === 0) && lineCount && lineCount>0){ lvl = Math.floor(lineCount/10)+1; }
      if(lvl === null) lvl = Math.floor((row.score||0)/1000)+1;
      if(lineCount === null){ lineCount = (lvl-1)*10; }
      let rankStyle = '', playerStyle = 'color:#fff;font-weight:600;', scoreStyle = 'color:#FFD166;font-weight:700;';
      if(idx===0){ playerStyle = 'color:#FFD166;font-weight:800;text-shadow:0 0 6px rgba(255,209,102,0.35)'; scoreStyle = 'color:#FFD166;font-weight:900;text-shadow:0 0 8px rgba(255,209,102,0.35)'; rankStyle = 'color:#FFD166;font-weight:800;'; }
      else if(idx===1){ playerStyle = 'color:#d7dee2;font-weight:700;'; scoreStyle = 'color:#d7dee2;font-weight:800;'; rankStyle = 'color:#d7dee2;font-weight:700;'; }
      else if(idx===2){ playerStyle = 'color:#d2904a;font-weight:700;'; scoreStyle = 'color:#d2904a;font-weight:800;'; rankStyle = 'color:#d2904a;font-weight:700;'; }
      tr.innerHTML = `
  <td style="padding:6px 8px;color:#9bb4c0;font-weight:600;${rankStyle}">${idx+1}</td>
  <td style="padding:6px 8px;${playerStyle}">${escapeHtml(row.player||'Anonyme')}</td>
  <td style="padding:6px 8px;color:#4DD2FF;font-weight:700;text-align:right">${lvl}</td>
  <td style="padding:6px 8px;color:#2BD4A4;font-weight:700;text-align:right">${lineCount}</td>
  <td style="padding:4px 6px;${scoreStyle};text-align:right;width:clamp(70px,10vw,150px);white-space:nowrap">${row.score}</td>
  <td style="padding:6px 8px;color:#9bb4c0;font-size:11px">${dateStr}</td>`;
      bodyEl.appendChild(tr);
    });
  }
}

// Récupération leaderboard Duo
function formatSecToMmSs(sec){ try{ const s = Math.max(0, Math.floor(sec||0)); const mm=String(Math.floor(s/60)).padStart(2,'0'); const ss=String(s%60).padStart(2,'0'); return `${mm}:${ss}`; }catch{ return '00:00'; } }
async function fetchLeaderboardDuo(){
  try{
    const status = document.getElementById('lbStatus');
    const body = document.getElementById('lbDuoBody');
    const sanaaWinsEl = document.getElementById('lbDuoSanaaWins');
    const sanaaBestEl = document.getElementById('lbDuoSanaaBest');
    const benWinsEl = document.getElementById('lbDuoBenWins');
    const benBestEl = document.getElementById('lbDuoBenBest');
    if(status) status.textContent = 'Chargement Duo…';
    if(body) body.innerHTML = '<tr><td colspan="4" style="padding:10px;font-size:12px;color:#6d8089">Chargement…</td></tr>';

    // Éviter 400 si created_at n'existe pas: trier par id, sinon sans tri
    let data = null, error = null;
    const r2 = await supabase.from('duo_scores').select('*').order('id',{ascending:false}).limit(100);
    data = r2.data; error = r2.error;
    if(error){
      const r3 = await supabase.from('duo_scores').select('*').limit(100);
      data = r3.data; error = r3.error;
    }
    if(error){ if(status) status.textContent = 'Erreur chargement Duo'; console.warn('duo_scores fetch error', error.message); }

    // Stats: victoires et meilleur chrono (survie la plus longue => max)
    let sanaaWins = 0, benWins = 0;
    let sanaaBest = null, benBest = null;
    (data||[]).forEach(row=>{
      const gagnantRaw = (row.gagnant||'').trim();
      const gagnant = gagnantRaw.toLowerCase();
      if(gagnant === 'sanaa') sanaaWins++;
      if(gagnant === 'benjamin' || gagnant === 'ben') benWins++;
      if(typeof row.temps_sanaa === 'number'){
        sanaaBest = (sanaaBest==null)? row.temps_sanaa : Math.max(sanaaBest, row.temps_sanaa);
      }
      if(typeof row.temps_benjamin === 'number'){
        benBest = (benBest==null)? row.temps_benjamin : Math.max(benBest, row.temps_benjamin);
      }
    });

    if(sanaaWinsEl) sanaaWinsEl.textContent = `Victoires : ${sanaaWins}`;
    if(benWinsEl) benWinsEl.textContent = `Victoires : ${benWins}`;
    if(sanaaBestEl) sanaaBestEl.textContent = `Meilleur chrono : ${sanaaBest!=null? formatSecToMmSs(sanaaBest) : '–'}`;
    if(benBestEl) benBestEl.textContent = `Meilleur chrono : ${benBest!=null? formatSecToMmSs(benBest) : '–'}`;

    // Tableau historique
    if(body){
      body.innerHTML = '';
      if(!data || !data.length){
        body.innerHTML = '<tr><td colspan="4" style="padding:10px;font-size:12px;color:#6d8089">Aucune partie duo enregistrée.</td></tr>';
      } else {
        data.forEach((row, idx)=>{
          const tr = document.createElement('tr');
          const createdRaw = row.created_at || row.updated_at || null;
          const created = createdRaw ? new Date(createdRaw) : null;
          const dateStr = created? created.toLocaleDateString('fr-FR',{day:'2-digit',month:'2-digit'})+' '+created.toLocaleTimeString('fr-FR',{hour:'2-digit',minute:'2-digit'}) : '–';
          const chronoSec = (typeof row.temps_sanaa==='number' || typeof row.temps_benjamin==='number')
            ? Math.max(row.temps_sanaa||0, row.temps_benjamin||0)
            : null;
          const chronoStr = chronoSec!=null? formatSecToMmSs(chronoSec) : '–';
          tr.innerHTML = `
            <td style="padding:6px 8px;color:#9bb4c0;font-weight:600">${idx+1}</td>
            <td style="padding:6px 8px;color:#fff;font-weight:700">${escapeHtml(row.gagnant||'-')}</td>
            <td style="padding:6px 8px;color:#4DD2FF;font-weight:700;text-align:right">${chronoStr}</td>
            <td style="padding:6px 8px;color:#9bb4c0;font-size:11px">${dateStr}</td>
          `;
          body.appendChild(tr);
        });
      }
    }
    if(status) status.textContent = 'Duo';
  }catch(e){ console.warn('fetchLeaderboardDuo error', e); }
}

function escapeHtml(str){ return String(str).replace(/[&<>'"]/g,s=>({"&":"&amp;","<":"&lt;",">":"&gt;","'":"&#39;","\"":"&quot;"}[s])); }

async function submitScoreToLeaderboard(score, lvl){
  try{
    if(!score || score<=0) return;
    const user = (sessionStorage.getItem('currentUser') || localStorage.getItem('lastUser') || 'Benjamin').substring(0,24);
  // fallback si lvl undefined
  if(typeof lvl !== 'number' || isNaN(lvl)) { try{ lvl = (typeof level !== 'undefined') ? level : null; }catch(_){} }
  const payload = { player:user, score:Math.floor(score) };
  if(typeof lvl === 'number' && !isNaN(lvl)) payload.level = (lvl+1); // stocker niveau humain (>=1)
  // Ajouter lignes si la colonne existe (optionnel) -> retirer si 400
  try{ if(typeof lines === 'number') payload.lines = lines; }catch(_){ }
  // ne pas inclure 'lines' (colonne absente)
  console.log('Envoi score ->', payload, 'niveau:', payload.level, 'pour user:', user);
  const { error } = await supabase.from('tetris_scores').insert(payload);
  if(error) console.warn('Score non enregistré', error.message);
  else { console.log('Score enregistré'); fetchGlobalHighscore().catch(()=>{}); fetchPersonalBest().catch(()=>{}); }
  }catch(e){ console.warn('Submit score error', e); }
}
window.fetchLeaderboard = fetchLeaderboard; // exposer
window.submitScoreToLeaderboard = submitScoreToLeaderboard;

// Récupération du meilleur score global (top 1) pour affichage dans le menu
async function fetchGlobalHighscore(){
  try{
    const { data, error } = await supabase.from('tetris_scores').select('score').order('score',{ascending:false}).limit(1);
    if(error) { console.warn('Fetch global highscore error', error.message); return; }
    if(data && data.length){
      const remote = Number(data[0].score)||0;
      if(remote > highscore){ highscore = remote; }
      // Ne pas mettre à jour hsValue ici pour éviter d'écraser temporairement le score personnel
      // L'affichage sera géré par fetchPersonalBest()
    }
  }catch(e){ console.warn('Global HS fetch failed', e); }
}
window.fetchGlobalHighscore = fetchGlobalHighscore;

// Récupère meilleurs score / niveau / lignes pour l'utilisateur connecté
async function fetchPersonalBest(){
  try{
    // Afficher un indicateur de chargement pendant la requête
    const hsEl = document.getElementById('hsValue'); if(hsEl) hsEl.textContent = '-';
    const lvlEl = document.getElementById('hsLevel'); if(lvlEl) lvlEl.textContent = '-';
    const liEl = document.getElementById('hsLines'); if(liEl) liEl.textContent = '-';
    
    const rawUser = sessionStorage.getItem('currentUser') || localStorage.getItem('lastUser') || 'Benjamin';
    const user = rawUser.substring(0,24);
    console.log('Recherche stats pour:', user); // Debug
    // Deux requêtes: 1) meilleur score + level associé 2) max lignes (si stocké)
    // On suppose colonne lines possible. Si absence -> ignore.
    const { data:scoreRows, error:err1 } = await supabase.from('tetris_scores').select('score,level,lines').eq('player', user).order('score',{ascending:false}).limit(1);
    if(err1){ console.warn('PB score error', err1.message); return; }
    console.log('Résultats trouvés:', scoreRows); // Debug
    let bestScore = null, bestLevel = null, bestLines = null;
    if(scoreRows && scoreRows.length){
      bestScore = Number(scoreRows[0].score)||0;
      bestLevel = Number(scoreRows[0].level)||1; // niveau déjà humain (>0)
      if(typeof scoreRows[0].lines === 'number') bestLines = scoreRows[0].lines;
      // Estimation lignes si pas fourni
      if((bestLines===null || bestLines===0) && bestLevel>1) bestLines = (bestLevel-1)*10;
      if(bestLines===null) bestLines = 0;
    }
    if(hsEl) hsEl.textContent = (bestScore===null || bestScore===0)? '-' : bestScore;
    if(lvlEl) lvlEl.textContent = (bestLevel===null || bestScore===0)? '-' : bestLevel;
    if(liEl) liEl.textContent = (bestLines===null || bestScore===0)? '-' : bestLines;
  }catch(e){ console.warn('Personal best fetch failed', e); }
}
window.fetchPersonalBest = fetchPersonalBest;

// Fonctions d'authentification
function isAuthenticated() {
    const authStatus = sessionStorage.getItem('isAuthenticated');
    const authTime = sessionStorage.getItem('authTime');

    if (!authStatus || authStatus !== 'true') {
        return false;
    }

    // Vérifier que l'authentification n'est pas trop ancienne (5 minutes)
    if (authTime) {
        const currentTime = new Date().getTime();
        const timeDiff = currentTime - parseInt(authTime);
        const minutesDiff = timeDiff / (1000 * 60);

        if (minutesDiff > 5) {
            sessionStorage.removeItem('isAuthenticated');
            sessionStorage.removeItem('authTime');
            return false;
        }
    }

    return true;
}

function redirectToLogin() {
    window.location.href = 'index.html';
}

document.addEventListener('DOMContentLoaded', ()=>{
  // Vérifier l'authentification au chargement de la page
  // if (!isAuthenticated()) {
  //   redirectToLogin();
  //   return;
  // }
  
  const lbRefresh = document.getElementById('lbRefreshBtn');
  if(lbRefresh) lbRefresh.addEventListener('click', ()=>fetchLeaderboard());
  // Tabs Solo/Duo
  const lbTabSolo = document.getElementById('lbTabSolo');
  const lbTabDuo = document.getElementById('lbTabDuo');
  const lbSoloPanel = document.getElementById('lbSoloPanel');
  const lbDuoPanel = document.getElementById('lbDuoPanel');
  if(lbTabSolo && lbTabDuo && lbSoloPanel && lbDuoPanel){
    lbTabSolo.addEventListener('click', ()=>{
      lbSoloPanel.style.display='block';
      lbDuoPanel.style.display='none';
      fetchLeaderboard();
    });
    lbTabDuo.addEventListener('click', ()=>{
      lbSoloPanel.style.display='none';
      lbDuoPanel.style.display='block';
      fetchLeaderboard();
    });
  }
  const lbBack = document.getElementById('leaderboardBackBtn');
  if(lbBack) lbBack.addEventListener('click', ()=>showMenuPage('home'));
  // Charger d'abord les scores personnels, puis le highscore global
  fetchPersonalBest().then(()=>{
    fetchGlobalHighscore();
  }).catch(()=>{
    fetchGlobalHighscore();
  });
  
  // Initialisation du jeu seulement si authentifié
  resizeBoard(); 
  drawBoard(); 
  renderNext(); 
  changeAtmosphere(0);

  // Pause auto en solo si l'onglet perd le focus; en duo, on continue
  try{
    document.addEventListener('visibilitychange', ()=>{
      if(document.hidden){
        if(!isDuoMode && running && !pauseOpen){
          showPause();
        }
      } else {
        // ne rien faire au retour; l'utilisateur reprend manuellement
      }
    });
  }catch{}
});
</script>

</body>
</html>
